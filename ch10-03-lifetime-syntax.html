<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Validating References with Lifetimes - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html" class="active"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong aria-hidden="true">20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong aria-hidden="true">20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong aria-hidden="true">20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong aria-hidden="true">20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.6.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch10-03-lifetime-syntax.html#Проверка-ссылок-с-помощью-lifetimes" id="Проверка-ссылок-с-помощью-lifetimes"><h2>Проверка ссылок с помощью Lifetimes</h2></a>
<p>Когда мы говорили о ссылках в Главе 4, мы опустили весьма важную деталь:
каждая ссылка в Rust имеет <em>время жизни</em>. Это область действия, в которой она является
действительной.</p>
<p>Lifetimes являются уникальной парадигмой языка Rust. Эта тема несколько обширна, что
в этой главе мы сможем изложить только синтаксис. В Главе 19 вы узнаете больше и
подробнее о возможностях этой парадигмы программирования на Rust.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#lifetimes-защищают-программу-от-недействительных-ссылок" id="lifetimes-защищают-программу-от-недействительных-ссылок"><h3>Lifetimes защищают программу от недействительных ссылок</h3></a>
<p>Самое важное свойство lifetimes - это предотвращение недействительных ссылок. Такую
ошибку весьма трудно заметить. Это весьма коварная ошибка. Для примера, давайте
рассмотрим код (10-18). Здесь демонстрируется поведение переменных в различных
областях видимости. Во внешней области видимости мы декларируем переменную <code>r</code> без
её инициализации. Во внутренней области видимости мы декларируем переменную <code>x</code> и
инициализируем её значением <code>5</code>. Внутри области видимости переменой <code>x</code> мы присваиваем,
точнее, пытаемся присвоить значение переменной <code>r</code>. Присваиваем её ссылочное значение
переменной <code>x</code>. Затем, мы хотим напечатать содержимое переменной <code>r</code> во внешней
области видимости:</p>
<pre><code class="language-rust ignore">fn main(){
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Listing 10-18: Попытка использования ссылки, которая стала
недействительной после выхода переменной из внутренней области видимости</span></p>
<blockquote>
<a class="header" href="ch10-03-lifetime-syntax.html#Неинициализированные-переменные-не-использоваться-в-выражениях-параметрах" id="Неинициализированные-переменные-не-использоваться-в-выражениях-параметрах"><h4>Неинициализированные переменные не использоваться (в выражениях, параметрах</h4></a>
</blockquote>
<p>вызова функций или методов и пр.)</p>
<blockquote>
<p>Следующие примеры демонстрируют объявление переменных без их инициализации.
Имя переменной существует во внешней области видимости.</p>
</blockquote>
<p>Сообщение об ошибке:</p>
<pre><code class="language-text">error: `x` does not live long enough
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>Переменная <code>x</code> больше не существует, т.к. её области видимости закончилась сразу же
после выхода за пределы области её объявления. В тоже время переменная <code>r</code> продолжает
находится в зоне свого объявления. Как же в таком случае компилятор Rust понимает,
что содержание переменной уже недействительно?</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Проверка-заимствования" id="Проверка-заимствования"><h4>Проверка заимствования</h4></a>
<p>У в состав компилятора Rust входит функционал называющий ся <em>провека заимствования</em>.
Демонстрационный код (10-19) иллюстрирует всё тот же пример (10-18), графически
изображая область действия имеющихся переменных:</p>
<pre><code class="language-rust ignore">{
    let r;         // -------+-- 'a
                   //        |
    {              //        |
        let x = 5; // -+-----+-- 'b
        r = &amp;x;    //  |     |
    }              // -+     |
                   //        |
    println!(&quot;r: {}&quot;, r); // |
                   //        |
                   // -------+
}
</code></pre>
<p><span class="caption">Пример кода 10-19: Описание времени жизни переменных <code>r</code> и
<code>x</code>, с помощью идентификаторов <code>'a</code> и <code>'b</code></span></p>
<!-- Just checking I'm reading this right: the inside block is the b lifetime,
correct? I want to leave a note for production, make sure we can make that
clear -->
<!-- Yes, the inside block for the `'b` lifetime starts with the `let x = 5;`
line and ends with the first closing curly brace on the 7th line. Do you think
the text art comments work or should we make an SVG diagram that has nicer
looking arrows and labels? /Carol -->
<p>Мы описываем время жизни переменной <code>r</code> с помощью <code>'a</code> и время жизни переменной <code>x</code>
с помощью описательной переменной <code>'b</code>. Обратите внимание, что блок <code>'b</code> находится
внутри блока <code>'a</code> и значительно меньше. Во время компиляции, компилятор Rust сравнивает
два идентификатора времени жизни и получается так, что описание времени жизни переменной
<code>r</code> находится в идентификаторе времени жизни <code>'a</code>, но в тоже время хранит в себе
ссылку на объект с идентификатором времени жизни <code>'b</code>. Такая программа не компилируется,
т.к. время жизни <code>'b</code> короче, чем время жизни <code>'a</code>, время жизни переменой больше,
чем её содержание. Это неприемлемо.</p>
<p>Рассмотрим другой пример (10-20), в котором нет проблем с недействительными ссылками.
В нём просто закомментировали наличие вложенного блока кода. Данный код пройдет тест
на ссылочную целостность и будет  принят компиляторов, как действительный и готовый
к исполнению:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // -----+-- 'b
    //{                   //      |
    let r = &amp;x;           // --+--+-- 'a
    //}                   //   |  |
    println!(&quot;r: {}&quot;, r); //   |  |
                          // --+  |
}                         // -----+
#}</code></pre></pre>
<p><span class="caption">Блок кода 10-20: Все ссылки действительные, т.к. и данные и
ссылка имеют одинаковое время жизни</span></p>
<p>В данном примере переменная <code>x</code> имеет время жизни <code>'b</code>, что большое чем время жизни
<code>'a</code>. Это означает, что переменная <code>r</code> может ссылаться на переменную <code>x</code> и её значение
будет действительно при введении значения на консоль и до конца блока, в котором
переменная <code>x</code>  была объявлена.</p>
<p>В этом пример мы рассмотрели и проанализировали работу анализатора времени жизни
переменных. Далее, рассмотрим время жизни обобщенных переменных, а также возвращаемых
функциями значений.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Идентификаторы-времени-жизни-обобщенных-типов-данных-в-функциях" id="Идентификаторы-времени-жизни-обобщенных-типов-данных-в-функциях"><h3>Идентификаторы времени жизни обобщенных типов данных в функциях</h3></a>
<p>Напишем функцию, которая возвращает наибольшую по длине строку. Эта функция
должна получать две переменные в качестве параметров функции и возвращать результат.
В строке вывода должно быть напечатано <code>The longest string is abcd</code>.
Пример кода (10-21):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Пример кода 10-21: Функция <code>main</code> вызывает функцию <code>longest</code>
для поиска наибольшей строки</span></p>
<p>Обратите внимание, что мы хотим иметь в качестве параметров срезы строк (которые
являются ссылками (об этом мы говорили в Главе 4)). Это делается для того, чтобы
не передавать владение в функцию передаваемых аргументов. Мы хотим, чтобы функция
принимала в качестве аргументов строковые срезы.</p>
<!-- why is `a` a slice and `b` a literal? You mean "a" from the string "abcd"? -->
<!-- I've changed the variable names to remove ambiguity between the variable
name `a` and the "a" from the string "abcd". `string1` is not a slice, it's a
`String`, but we're going to pass a slice that refers to that `String` to the
`longest` function (`string1.as_str()` creates a slice that references the
`String` stored in `string1`). We chose to have `string2` be a literal since
the reader might have code with both `String`s and string literals, and the way
most readers first get into problems with lifetimes is involving string slices,
so we wanted to demonstrate the flexibility of taking string slices as
arguments but the issues you might run into because string slices are
references.
All of the `String`/string slice/string literal concepts here are covered
thoroughly in Chapter 4, which is why we put two back references here (above
and below). If these topics are confusing you in this context, I'd be
interested to know if rereading Chapter 4 clears up that confusion.
/Carol -->
<p>Освежим в памяти материал Главы 4 (секцию &quot;Срезы строк в качестве аргументов&quot;)
для того, чтобы хорошо представлять особенности а тонкости рассматриваемого вопроса
в данном примере.</p>
<p>Если просто реализовать функции так, как это показано в примере кода (10-22), то
то программа не будет скомпилирована:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Код программы 10-22: Пример реализации функции <code>longest</code>,
которая возвращает наибольший срез строки, но пока ещё не компилируется (содержит
в себе ошибку)</span></p>
<p>В описании ошибки компилятор сообщает о проблемах в определении времени жизни:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   |
1  | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |                                 ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
   signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>Описание ошибки давольно-таки информативно, но всё-таки не очень понятно.
Ясно одно - анализатору времени жизни переменных не хватает данных для анализа
корректности ссылочной целостности. Необходимо видоизменить код функции так, чтобы
было устранить неопределенность и дать возможность компилятору провести все необходимые
проверки.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Синтаксис-описания-времени-жизни-переменных" id="Синтаксис-описания-времени-жизни-переменных"><h3>Синтаксис описания времени жизни переменных</h3></a>
<p>Описания времени жизни не может изменить время жизни ссылок в программе.
Также как функции могут принимать любые входные данные удовлетворяющие условиям,
также функции потенциально могут принимать любые ссылки с любым временем жизни.
Описание времени жизни связывает между собой ссылки.</p>
<p>Описание времени жизни имеет необычный синтаксис: имена параметров времени жизни
обязаны начинаться с символа <code>'</code>. Имена их обычно пишутся в нижнем регистре и также,
как обобщенные типы данных, их имена очень короткие. Обычно, по умолчанию используется
<code>'a</code>. Параметры описания времени жизни следуют после символа <code>&amp;</code> ссылочного типа данных
и разделяются пробелом от названия тип данных.</p>
<p>Пример ссылки на переменную типа данных <code>i32</code>:</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
</code></pre>
<p>Пример ссылки на переменную типа данных <code>i32</code> с описанием времени жизни <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;'a i32     // a reference with an explicit lifetime
</code></pre>
<p>Пример изменяемой переменной типа данных <code>i32</code> с описанием времени жизни <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<p>Само по себе описание времени жизни не имеет значения: оно сообщает компилятору Rust,
как обобщенные параметры времени жизни изменяемой переменных связаны между собой.
Если у нас есть функция с параметром <code>first</code>, которая имеет ссылочный тип данных <code>i32</code> и
имеет описание времени жизни <code>'a</code> и эта функция имеет другой параметр с именем
<code>second</code>, который в свою очередь является ссылкой на переменную типа <code>i32</code> и имеет
описание времени жизни <code>'a</code>, то, следовательно у них одно и тоже описание времени
жизни. Следовательно эти ссылки существовать столько же, сколько существует обобщенное
описание времени жизни.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Описания-времени-жизни-в-синтаксисе-функций" id="Описания-времени-жизни-в-синтаксисе-функций"><h3>Описания времени жизни в синтаксисе функций</h3></a>
<p>Теперь когда мы познакомились с аннотациями времени жизни переменных, применим
эти знания. В функцию <code>longest</code> внесём описания времени жизни переменных. Обратите
внимание, что аннотации в функциях располагаются в том же мести и квадратных скобках,
также как и обобщенные типы данных. Ограничение которое мы хотим внести в данную
функцию следующее: время жизни параметров и возвращаемого значения одно и тоже.
Пример (10-23):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-23: В функции <code>longest</code> определено время жизни
ссылочных переменных <code>'a</code>, благодаря чему компилятор может провести соответствующие проверки
корректности кода </span></p>
<p>Теперь код (10-21) использующий эту функцию может быть скомпилирован.</p>
<p>Компилятор теперь знает достаточно, о функции <code>longest</code>, чтобы убедиться в ссылочной
целостности.</p>
<p>Когда необходимо описание времени жизни функций, это описание может располагаться
только в заголовке функции. Это описание необходимо, как тонкая настройка целостности
данных.</p>
<p>Т.к. время жизни переменных может отличаться друг от друга при использовании данной
функции берется наименьшее значение. Только в этом случае мы можем гарантировать,
что возвращаемое значение будет иметь действительное время жизни.</p>
<p>Рассмотрим пример ограничений времени жизни работает на следующем примере (10-24):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p><span class="caption">Код программы 10-24: Использование функции <code>longest</code> и ссылок
на строковые данные <code>String</code>, которые имеют разное время жизни</span></p>
<p>Далее, рассмотрим пример, которые покажет, что время жизни результата работы
функции минимальное из имеющихся. Мы переместим определение переменной <code>result</code>
из внутренней области видимости, но присвоим значение внутри внутренней области
видимости. При таких условиях, пример кода 10-25 не будет скомпилирован:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-25: Попытка использование переменной <code>result</code>
после выхода переменной <code>string2</code> за пределы области видимости</span></p>
<p>Описание ошибки:</p>
<pre><code class="language-text">error: `string2` does not live long enough
   |
6  |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
7  |     }
   |     ^ `string2` dropped here while still borrowed
8  |     println!(&quot;The longest string is {}&quot;, result);
9  | }
   | - borrowed value needs to live until here
</code></pre>
<p>Эта ошибка возникает из-за минимального значения времени жизни одного из значений
входных данных функции.</p>
<p>Пожалуйста, поэкспериментируйте со значениями времени жизни ссылок! Посмотрите,
какая из ссылок используется для определения времени жизни результата.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Думай-категориями-времени-жизни" id="Думай-категориями-времени-жизни"><h3>Думай категориями времени жизни</h3></a>
<p>Для того, чтобы точно определить время жизни параметров необходимо точно знать,
что будет делать функция. Например, если мы изменили реализацию функции <code>longest</code>
в новой редакции функция будет всегда возвращать первый аргумент, то в этом случае
нет необходимости устанавливать время жизни параметра <code>y</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>Для того, чтобы не было сообщений компилятора о неиспользуемом параметре, сделайте,
как рекомендуется:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, _y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>В этом примере мы сообщили параметр времени жизни <code>'a</code> для параметра <code>x</code> и возвращаемого
значения, но не для параметра <code>y</code>.</p>
<p>Если же в коде метода возвращаемая ссылка не будет ссылаться на какой-либо из аргументов,
тогда эта ссылка при выходе из области видимости станет недействительной, что приведёт
к ошибке компиляции и другим тревожным сообщениям:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Даже если будет установлен параметр время жизни у возвращаемого значения, этот код
также не будет скомпилирован, т.к. возвращаемое значение не будет связано с временем
жизни какого-либо из параметров.</p>
<p>Сообщение об ошибке:</p>
<pre><code class="language-text">error: `result` does not live long enough
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the block
at 1:44...
  |
1 | fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
  |                                             ^
</code></pre>
<p>Т.к. время жизни переменной истекает после выхода её из области видимости функции,
такой код не будет скомпилирован.</p>
<p>Как только будет установлена связь времени жизни входящих переменных и возвращаемого
значения - для компилятора будет достаточно информации, чтобы сделать проверки и
скомпилировать код, исключив возможность появления недействительных ссылок.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Определение-времени-жизни-при-объявлении-структур" id="Определение-времени-жизни-при-объявлении-структур"><h3>Определение времени жизни при объявлении структур</h3></a>
<p>До сих пор мы объявляли структуры, которые содержали нессылочные типы данных.
Также возможно в структурах использовать ссылочные типы данных, но при этом необходимо
добавить описание времени жизни каждой ссылки в определение структуры. Пример кода
10-26 описывает структуру <code>ImportantExcerpt</code> содержащую срезы строковых данных:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };

    println!(&quot;{}&quot;,i.part);
}
</code></pre></pre>
<p><span class="caption">Пример кода 10-26: Структура, которая содержит ссылку и определение
времени жизни</span></p>
<p>Обратите внимание, что поле структуры <code>ImportantExcerpt</code> содержит ссылку</p>
<p>Синтаксис такой же, как и при работе с обобщенными типами данных.</p>
<p>Функция <code>main</code> создаёт экземпляр структуры <code>ImportantExcerpt</code>, который содержит
ссылку на перовое предложение из переменной <code>novel</code>.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Правила-неявного-определения-времени-жизни" id="Правила-неявного-определения-времени-жизни"><h3>Правила неявного определения времени жизни</h3></a>
<p>Подведём промежуточные итоги изучения описания времени жизни. Из этой части главы
мы узнали, что каждая ссылка имеет время жизни и нам нужно устанавливать параметры
времени жизни для функций или структур, которые используют ссылки.</p>
<p>Также, изучая материал Главы 4, мы создали функции (в секции “String Slices”), которая
также использует ссылки, но при этом компилятор для её работы не требует информации
о времени жизни (Пример кода 10-27):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p><span class="caption">Код программы 10-27: Обратите внимание, что функция, которою
мы определили в Главе 4 компилируется без описания времени жизни ссылок, несмотря на
то, что и входной параметр и выходной - ссылки</span></p>
<p>Причина по которой это код может быть скомпилирован - историческая, первые версии
Rust предполагали явное указание подобной функциональности.
Сейчас мы рекомендуем написать данный код следующим образом, чтобы иметь возможность
использовать возможности компилятора по анализ возможных ошибок:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>После продолжительной работы и накопления большого опыта, разработчики языка Rust
обнаружили, что описания времени жизни программисты пишут в определённых шаблонных
решениях, практиках. Программисты Rust решили сделать так, что в таких случаях
сам компилятор может расставлять переменные времени жизни без явного объявления его
в коде программы.</p>
<p>Т.к. язык Rust постоянно развивается, возможно, в будущем роль переменных времени
жизни будут уменьшиться и больше будет случает в описаниях функций и перечислений.</p>
<p>Шаблоны, по которым компилятор Rust анализирует ссылки называется <em>правилами неявного
поредения времени жизни</em>. Эти правила существую для компилятора, а не для пишущего
программы на Rust программиста. Знание этих правил позволит не описывать время
жизни ссылок там, где это делать необязательно.</p>
<p>Неявные правила не имеет четких ограничений. Эти правила выводятся на основе имеющихся
данных в коде программы. Если этих данных не будет достаточно - компилятор выведет
соответствующие сообщения и не скомпилирует код.</p>
<p>Сейчас мы рассмотрим правила анализа переменных времени жизни.
Первое правило применяется к входным переменным. Последующие два правила применяются
к выходным переменным. Если компилятор применил эти правила и в результате этого
он не смог определить связывание данных переменных компилятор остановит свою работу и
сообщит об ошибке. Вот эти правила:</p>
<ol>
<li>
<p>Каждый параметр является ссылкой получающей свой собственный параметр времени жизни.
Другими словами, функция с одним параметром получает один параметр времени жизни:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>. Функция с двумя аргументами получает два различных
параметров времени жизни: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code> и так далее.</p>
</li>
<li>
<p>Если существует одни параметр времени жизни он связывается со всеми выходными
параметрами: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
</li>
<li>
<p>Если есть множество входных параметров времени жизни и один из них является
ссылкой <code>&amp;self</code> или <code>&amp;mut self</code> (т.к. это ссылка на метод структуры или перечисления
то в этом случае, параметр времени жизни <code>self</code> будет связан со всеми выходными
параметрами времени жизни.</p>
</li>
</ol>
<p>Вооружившись этими знаниями вернёмся к функции <code>first_word</code> и рассмотрим подробнее
анализ компилятора её заголовка. В нём нет описания времени жизни:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Далее, применим первое правило, которое говорит, что каждый параметр получает свой
собственный параметр времени жизни. Пропишем это условие явным образом:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>Второе правило таки применяется, т.к. здесь только один входной параметр времени
жизни. Следовательно, данная переменная времени жизни свяжется с выходной переменной
времени жизни. Перепишем заголовок функции с учётом этого правила:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Теперь все ссылки в этой функции имеют параметры времени жизни и компилятор может
продолжить свой анализ без необходимости получить дополнительную информацию от
программиста.</p>
<p>Давайте рассмотрим ещё один пример - заголовок функции <code>longest</code>, в котором нет
параметров времени жизни из примера 10-22:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Применим правила времени жизни:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Второе правило нельзя применить, т.к. входных параметров несколько. Смотрим
третье правило. Оно также не применимо, т.к. это функция, а не метод. Поэтому
компилятор в данном случае сообщит об ошибке (Пример кода 10-22)</p>
<p>Т.к. третье правило применяется только к методам, давайте рассмотрим работу этого
правила подробнее.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Описание-времени-жизни-в-определении-методов" id="Описание-времени-жизни-в-определении-методов"><h3>Описание времени жизни в определении методов</h3></a>
<!-- Is this different to the reference lifetime annotations, or just a
finalized explanation? -->
<!-- This is about lifetimes on references in method signatures, which is where
the 3rd lifetime elision rule kicks in. It can also be confusing where lifetime
parameters need to be declared and used since the lifetime parameters could go
with the struct's fields or with references passed into or returned from
methods. /Carol -->
<p>Когда мы реализуем методы в структурах с описанием времени жизни, синтаксис
описаний схож с аннотациями обобщенного программирования (Пример кода 10-11).
Место где описания времени жизни определяется и используется зависит от того
с чем он связывается - с полем структуры либо с аргументами методов и возвращаемыми
значениями.</p>
<p>Имена переменных времени жизни для полей структур всегда должны описывается после
ключевого слова <code>impl</code> и затем помещаться после имени структуры, т.к. это имя -
неотъемлемая часть типа данных структуры.</p>
<p>В описании методов внутри блока <code>impl</code>, ссылки могут быть связаны с ссылками полей
или могут быть независимыми. Дополнительно, правила неявного использования
времени жизни делают использование переменных времени жизни необязательными.
Рассмотрим пример кода. Используем структуру <code>ImportantExcerpt</code> из примера 10-26.</p>
<p>Здесь метод в методе <code>level</code> входной параметр - ссылка на <code>self</code> и возвращаемое
значение типа <code>i32</code> (не ссылка):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<p>Описание параметра времени жизни находится после <code>impl</code> и используется после имени.
Нам не надо добавлять информацию к входному параметру (правило 1).</p>
<p>Пример применения третьего правила:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
#}</code></pre></pre>
<p>Тут два входных параметра. Применяем первое правило. Т.к. один из параметров <code>&amp;self</code>
возвращаемое значения будет иметь время жизни переменой <code>&amp;self</code></p>
<a class="header" href="ch10-03-lifetime-syntax.html#Статическая-переменная-времени-жизни" id="Статическая-переменная-времени-жизни"><h3>Статическая переменная времени жизни</h3></a>
<p>Существует ещё одно особенное врем жизни - 'static`. Оно описывает всё врем жизни
программы. Все строковые литералы имеют этот тип времени жизни, которое мы можем
указать явным образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
#}</code></pre></pre>
<p>Содержание этой строки сохраняется внутри бинарного кода вашей программы и всегда
доступно для использования. Поэтому время жизни всех строковых литералов <code>'static</code>.</p>
<!-- How would you add a static lifetime (below)? -->
<!-- Just like you'd specify any lifetime, see above where it shows `&'static str`. /Carol -->
<p>В сообщениях компилятора могут быть сообщении использовать <code>'static</code>. Прежде чем
использовать данный тип переменной времени жизни, пожалуйста, подумайте, должна ли
данная переменна быть доступна во время работы программы. Очень часто такие ссылки
являются источником скрытых ошибок.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Обобщенные-типы-связывание-с-типажом-и-переменные-времени-жизни" id="Обобщенные-типы-связывание-с-типажом-и-переменные-времени-жизни"><h3>Обобщенные типы, связывание с типажом и переменные времени жизни</h3></a>
<p>Теперь когда мы узнали о синтаксисе переменных времени жизни настала пора
объединить эти знания с другими концепциями языка Rust. Рассмотрим пример определения
обобщенных параметров, типажа и переменных времени жизни вместе:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>Это видоизмененный пример функции <code>longest</code> (код прогрммы 10-23). Программа
возвращает наибольшую строку. Обратите внимание на дополнительный аргумент обобщенного
типа <code>ann: T</code>! Он может быть любым, реализующим типаж <code>Display</code>. Содержание данной
переменной будет напечатано прежде, чем будет произведено сравнение строк. Т.к. переменные
времени жизни - это разновидность обобщенного типа параметров, они располагаются
вместе.</p>
<a class="header" href="ch10-03-lifetime-syntax.html#Итоги" id="Итоги"><h2>Итоги</h2></a>
<p>В этой главе мы рассмотрели много важного материала для понимания работы переменных
времени жизни. Вы уже знаете достаточно, чтобы писать код программы и не дублировать
создаваемый вами код. Обобщенные параметры помогаю использовать код для различных
типов данных. Типажи и связывании с типажами помогает соблюсти конвенции и контракты
чтобы иметь предсказуемое поведение. Также у нас есть эффективных способ борьбы с
недействительными ссылками. Вся эта подготовительная работа проводиться в момент
компиляции. Есть ещё тему которые дополнят эту картину. В Главе 17 вы изучите
типажные объекты (это ещё один способ использовать типажи). В Главе 19 будет говориться
о сложных сценариях использования переменных времени жизни. В Главе 20 будет рассмотрена
система опций. В следующей главе будут рассказано, как написать тесты в Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch10-02-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch11-00-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch10-02-traits.html" class="nav-chapters previous" title="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch11-00-testing.html" class="nav-chapters next" title="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
