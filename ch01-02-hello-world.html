<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Hello, World! - Hello, World! - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }

            a .hljs {
                color: #4183c4;
            }

            .rust .content a .hljs,
            .coal .content a .hljs,
            .navy .content a .hljs {
                color: #2b79a2;
            }

            a:hover .hljs {
                text-decoration: underline;
            }

            /* Styles keystrokes such as ctrl-C */
            .keystroke {
                font-variant: small-caps;
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html" class="active"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong aria-hidden="true">20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong aria-hidden="true">20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong aria-hidden="true">20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong aria-hidden="true">20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.6.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators</a></li></ol></li></ol>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Hello, World! - The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="#hello-world" id="hello-world"><h2>Hello, World!</h2></a>
<p>Итак, когда Rust уже установлен можно приступать к написанию вашей первой программы.
<a href="https://ru.wikipedia.org/wiki/Hello,_world!">По традиции</a>, (а точнее с 1978 года, когда вышло в свет первое издание <a href="https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)">книги о Си</a>)
напишем небольшую программу, которая напечатает &quot;Привет, Мир!&quot; в строке вывода.</p>
<blockquote>
<p>Обратите внимание, что читатели должны быть знакомы с командной
строкой. TODO: Язык Rust не требует каких-то специальных настроек редакторов исходного
кода, настройкам инструментальных средств. IDE экономят время и если ещё дают
возможность тонкой настройки параметров запуска утилит - это замечательно. Как
бы там ни было, программист должен знать и уметь пользоваться командной строкой
и мы этому научим. :ODOT</p>
</blockquote>
<a class="header" href="#aСоздание-папки-проекта" id="aСоздание-папки-проекта"><h3>Создание папки проекта</h3></a>
<p>Первым делом создадим папку для хранения исходных кодов Rust. И хотя это не
обязательное условие для программирования на Rust, но всё же для удобства нашей
работы это будет лучшим решением.</p>
<blockquote>
<p>Т.к. команды в терминалах Linux и Mac идентичны, предлагаю, для краткости,
писать Unix, в тех случаях, когда мы будем описывать работу в терминале Linux
или Mac.</p>
</blockquote>
<p>Итак, приступим. Создадим папку <em>projects</em> и далее будем создавать проекты Rust
в этой директории. Для этого откроем программу-терминал и введём следующие команды:</p>
<p>Unix:</p>
<pre><code class="language-shell">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projects
&gt; cd %USERPROFILE%\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projects
&gt; cd $env:USERPROFILE\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<a class="header" href="#aНаписание-и-запуск-первой-программы" id="aНаписание-и-запуск-первой-программы"><h3>Написание и запуск первой программы</h3></a>
<p>Далее, создадим текстовый файл и назовём его <em>main.rs</em>.</p>
<blockquote>
<p>Все файлы исходного кода Rust имеют расширение <em>.rs</em> (ещё одна конвенция
упрощающая программирование).
Рекомендуем использовать символ подчёркивания для разделения слов в многословных
названиях. Во-первых, такие названия легче читать, а во-вторых, это упрощает
работу утилит. Пример: <em>i_like_hello_world.rs</em>.</p>
</blockquote>
<p>Теперь откроем файл <em>main.rs</em> для редактирования и введём следующие строки кода:</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, Rust world! Привет, Мир!&quot;);
}
</code></pre></pre>
<p>Сохраним файл и вернёмся в окно терминала. Введём следующие (две) команды:</p>
<p>Unix:</p>
<pre><code class="language-shell">$ rustc main.rs # нажмите клавишу Enter
$ ./main # нажмите клавишу Enter
Hello, Rust world! Привет, Мир!
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; rustc main.rs # нажмите клавишу Enter
&gt; main
Hello, Rust world! Привет, Мир!
</code></pre>
<p>Обратите внимание на отличия в запуске приложений в строке терминала Unix и Windows.
Если всё будет в порядке (вы не сделаете опечаток, не будет проблем в кодировках,
шрифтах или ещё с чем-нибудь ещё (&quot;не удаётся найти указанный файл&quot;, &quot;stream
did not contain valid UTF-8&quot;, ..)) - будет напечатана строка <code>Hello, Rust world! Привет, Мир!</code>.
Поздравляю! Вы написали первую программу на Rust! Добро пожаловать в увлекательное
путешествие в мир Rust! :-)</p>
<blockquote>
<p>Если вам уже понравилось писать на Rust, создайте файл <em>hello_world.rs</em> введите
тот же код и проверьте его работу. Далее создайте <em>i_like_hello_world.rs</em> и
проделайте тоже самое. Если программы будут работать корректно - будет печататься
тот же текст - вы закрепите свои первые навыки и почувствуете уверенность.
Желаю успеха!</p>
</blockquote>
<a class="header" href="#aКак-это-работает" id="aКак-это-работает"><h3>Как это работает</h3></a>
<p>Теперь, давайте разберёмся, как же работает ваша новая &quot;Hello Rust world!&quot;-программа.
Первым делом, разберем исходный код:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Этот текст определяет <em>Rust-функцию</em>. Функция <code>main</code> - особенная. Это т.н. точка
входа в программу (если читатель уже знаком с C, C++, Java, то тут тоже самое).
<code>main</code> - начало всех начал вашей программы. Т.е. этот текст значит следующее:
&quot;Объявление функции с именем <code>main</code>, у которой нет параметров и она ничего не
возвращает во внешнюю среду.&quot; Если же у неё были бы параметры, они были бы заключены
в круглые скобки <code>(</code> <code>)</code>.</p>
<p>Также обратите внимание, что содержимое функции обрамляется фигурными скобками.
<code>{</code> <code>}</code> (также как и в Си, С++, Java, Go). Эти скобки обязательны для описания
Rust-функций. Для повышения читаемости кода рекомендуем размещать открывающуюся
фигурную скобку <code>{</code> на той же строке, что и наименование функции и описание её
параметров и отделять её одним пробелом. Вот так: <code>fn main() {</code>.</p>
<p>Содержимое функции <code>main</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, Rust world! Привет, Мир!&quot;);
#}</code></pre></pre>
<p>Эта строчка кода описывает все действия программы: печать текста в терминальной
строке. Есть определённые стилистические уточнения. Первое, в стиле написания кода
на Rust используется четыре пробела вместо символа табуляции.</p>
<p>Второе, это <code>println!</code> (называется Rust макрос). Таким образом в Rust реализуется
метапрограммирование. Обратите, пожалуйста, внимание, что в конце слова <code>println</code>
стоит знак <code>!</code>. Именно этот знак говорит о том, что это макрос, а не функция.
Это важно! Пожалуйста обратите на это внимание!</p>
<p>Далее, в круглых скобках находится текст <code>&quot;Hello, Rust world! Привет, Мир!&quot;</code>.
Он имеет тип данных <em>строка</em>. Этот текст передаётся макросу <code>println!</code> как входные
данные. Далее, макрос выполняет печать данного текста в терминале. Всё
достаточно просто и понятно, не так ли?!</p>
<p>Строка заканчивается символом <code>;</code>. Этот символ информирует о том, что выражение
окончено, далее можно напечатать следующее.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, Rust world! Привет, Мир!&quot;);
    println!(&quot;Hello! Привет!&quot;);
#}</code></pre></pre>
<blockquote>
<p>Пожалуйста, добавьте новую строчку кода в вашу программу и проделайте необходимые
операции, для того чтобы увидеть новый текст в терминале!</p>
</blockquote>
<p>Unix:</p>
<pre><code class="language-shell">$ rustc main.rs
$ ./main
Hello, Rust world! Привет, Мир!
Hello! Привет!
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; rustc main.rs
&gt; main
Hello, Rust world! Привет, Мир!
Hello! Привет!
</code></pre>
<a class="header" href="#aКомпиляция-и-выполнения---это-два-различных-этапа-работы" id="aКомпиляция-и-выполнения---это-два-различных-этапа-работы"><h3>Компиляция и выполнения - это два различных этапа работы</h3></a>
<p>В разделе &quot;Написание и запуск первой программы&quot; было показано, как выполнить
созданную программу. Сейчас мы постараемся объяснить как это работает.</p>
<p>Прежде чем выполнить программму (т.е. вызвать в строке териминала исполняемый
файл программы <code>main</code>), необходимо скомпилировать её с помощью
программы-компилятора <code>rustc</code>.</p>
<p>Unix:</p>
<pre><code class="language-shell">$ rustc main.rs
</code></pre>
<p>Аналогично на Windows.</p>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; rustc main.rs
</code></pre>
<p>Таким же образом компилируются программы на C, C++, Java, Go. Результатом компиляции
Rust-программы является бинарный файл. Его можно увидеть в списке файлов:</p>
<p>Unix:</p>
<pre><code class="language-shell">$ ls
main  main.rs
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; dir /B
main.exe
main.rs
</code></pre>
<blockquote>
<p>опция /B позволяет отображать только файлы</p>
</blockquote>
<p>В списке присутствуют два файла: файл с исходным кодом программы <em>.rs</em> и бинарный
файл (<em>main.exe</em> в Windows, <em>main</em> на других операционных системах).</p>
<pre><code class="language-shell">$ ./main  #или .\main.exe на Windows
</code></pre>
<p>Если бы в исходном коде <em>main.rs</em> в входных параметрах макроса был введён текст
“Hello, world!”, то в строке терминала вы бы увидели <code>Hello, world!</code>.</p>
<blockquote>
<p>Пожалуйста, отредактируйте файл исходного кода и проверьте работу нового бинарного
файла!</p>
</blockquote>
<p>Если у Вас есть опыт программирования на динамически компилируемых языках, таких как
Ruby, Python или JavaScript то вас, наверное, удивит необходимость разделения
компиляции и выполнения программ. В составе утилит Rust есть <a href="https://ru.wikipedia.org/wiki/AOT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F">Ahead-of-Time</a> (AOT)
компилятор. Он позволяет создавать автономные бинарные файлы, которые позже могут
быть использованы там, где нет Rust утилит. Это весьма удобно, как для разработчиков
программного обеспечения, так и для пользователей. Динамически компилирумые
программы лишены такой возможности. Как бы там ни было, использование и динамически,
и статически компилируемых языков программирования имеет свои плюсы и минусы.</p>
<p>Компиляция простых программ с помощью <code>rustc</code> - это замечательно, но если ваш
проект начнёт разрастаться всё больше и больше, вам понадобятся средства
управления всеми компонентами, а также удобные возможности всего цикла командной
разработки. Далее, мы представим вам программу <code>cargo</code>, которая поможет создать
удобную среду разработки.</p>
<a class="header" href="#aПривет-cargo" id="aПривет-cargo"><h2>Привет, Cargo!</h2></a>
<p>Cargo - это система управления пакетами для разработки программ на Rust. Удобство
её использования оценили программисты Rust. Cargo позволяет упростить процесс
разработки. Например, Сargo поможет скомпилировать программу из исходного кода,
скачать требуемые библиотеки для вашего проекта. В терминах языка программирования
Rust внешние библиотеки называются <em>зависимостями</em> (<em>dependencies</em>).</p>
<p>Такая простая программа, которую мы написали (main) не имеет зависимостей. Поэтому
Cargo нам может понадобиться только лишь для компиляции. Если же Вы напишете
(когда-нибудь напишете) более сложную программу на Rust, то весь функционал Cargo,
который помогает добавить зависимости в инфраструктуру вашего проекта будет весьма
кстати.</p>
<p>Поскольку огромное (подчёркиваю огромное) количество Rust-проектов использует Cargo
мы предположим, что и вам его функционал придётся по вкусу и будет удобен. Всё что
вам нужно для его использования идёт в комплекте с компилятором и другими утилитами.
Для того, чтобы проверить правильно ли установлен Cargo, введите в терминал
следующую команду:</p>
<pre><code class="language-shell">$ cargo --version
cargo 0.21.0
</code></pre>
<p>Если будет выведена версия программы - Cargo скорее всего работает. А если
программа <code>cargo</code> не найдена - пожалуйста, постарайтесь устранить проблемы установки
(возможно, Вам понадобится установить Cargo с помощью различных способов, приведенных на
сайте <a href="http://doc.crates.io/">doc.crates.io</a>).</p>
<blockquote>
<p>Для того чтобы узнать подробнее о возможностях утилиты <code>cargo</code>, пожалуйста, введите
следующую команду:</p>
</blockquote>
<pre><code class="language-shell">$ cargo --help
</code></pre>
<a class="header" href="#aСоздание-cargo-проекта" id="aСоздание-cargo-проекта"><h3>Создание Cargo проекта</h3></a>
<p>Создадим проект используя Cargo! Думаю, что он будет отличаться от того проекта,
что был создан нами ранее (проект <code>main</code>):</p>
<p>Unix:</p>
<pre><code class="language-shell">$ cd ~/projects
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projects
</code></pre>
<p>Далее введём следующую команду:</p>
<pre><code class="language-shell">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<p>Мы устанавливаем аргумент <code>--bin</code> для cargo-команды <code>new</code> для того, чтобы по шаблону
была создана структура приложения командной строки - консольный проект (бинарное
приложение). <code>hello_cargo</code> - это название нашего нового Rust проекта.</p>
<p>Если мы просмотрим список созданных файлов, то мы увидим что внутри папки проекта
были созданы файлы и папка: <em>Cargo.toml</em>,<em>.gitignore</em>, <em>src</em>. Внутри папки <em>src</em>
находится файл <em>main.rs</em>. По умолчанию Cargo оснастил папку нашего проекта файлом
<em>.gitignore</em> - это служебный файл git хранилища. Вы можете создать проект и без
инициализации git хранилища (или какого-либо иного вида системы контроля версий файлов),
если воспользуетесь флагом <code>--vcs</code> при создании нового проекта:</p>
<pre><code class="language-shell">$ cargo new hello_cargo2 --bin --vcs none
$ cd hello_cargo2
</code></pre>
<p>Содержимое файла <em>Cargo.toml</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Это файл формата <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (Tom’s Obvious, Minimal
Language). Формат TOML очень похож на INI, однако имеет свои специфические
особенности.</p>
<p>На первой строке расположен заголовок секции<code>[package]</code>. Далее следует описание пакета.
По мере усложнения проекта, в данный файл будут добавлять другие секции.</p>
<p>Следующие строки - это строки описания пакета: имя, версия, авторы.
Если в строке у Вас написано имя компьютера, значит Вы ещё не до конца настроили
систему для работы с Cargo (Cargo не может считать информацию о вас, а также недоступны
другие опции работы с github). Информацию об авторстве Cargo берёт из параметров
вашего git вашей учетной записи. Подробнее с этим можно ознакомиться перейдя по
<a href="https://github.com/rust-lang/cargo/issues/1213">ссылке</a>.
Если вы хотите устранить этот недостаток, то для пользователей Windows предлагаю
следующее решение:</p>
<ol>
<li>Устанавливаете &quot;GitHub Desktop&quot;.</li>
<li>В приложении подключаетесь к своей учётной записи.</li>
<li>Далее создаёте проект.</li>
<li>Открывайте файл <em>Cargo.toml</em> созданного проекта и видите имя учётной записи и e-mail в строке <code>authors</code>.</li>
</ol>
<p>Последняя строка <code>[dependencies]</code> - это заголовок секции <em>crates</em> (так называются
пакеты в терминах языка программирования Rust). Этот список содержит описание зависимостей
вашего проекта и предоставляет Cargo необходимую информацию для загрузки
и компиляции. Т.к. в нашем шаблонном проекте не используются внешние зависимости -
эта секция пуста. В проекте &quot;Угадай число&quot; мы заполним информацию о зависимостях.</p>
<p>Если у Вас появились вопросы, пожалуйста, ознакомьтесь с разделом <a href="http://doc.crates.io/faq.html">FAQ</a> документации.</p>
<p>Теперь перейдём к рассмотрению содержимого файла <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Как видите, тут уже есть код программы, который мы писали ранее.
Отличия нашего предыдущего проекта от сгенерированного Cargo следующие:</p>
<ul>
<li>Имеется специальная папка для исходного кода программы <em>src</em>.</li>
<li>Есть файл конфигурации <em>Cargo.toml</em></li>
</ul>
<p>Программисты Java, возможно, обратят внимание на концептуальную схожесть содержания
проекта с Maven. Да, есть что-то общее. Интуиция вас не подводит.
В корневой папке проекта также могут содержаться файлы README, CONTRIBUTING, LICENSE,
файлы конфигурации, а также всё что угодно, не относящееся к исходному коду программы.
Концепция структуры хранения данных Cargo позволяет унифицировать структуру Rust
проектов, что делает их понятными для изучения и развития. Такие проекты потенциально
могут быть сколько угодно сложными и ёмкими. Cargo поможет со всеми ими справиться.</p>
<p>Если в своей работе вам придётся столкнуться с необходимостью конвертации проекта Rust в
Cargo-проект - генерируемые шаблоны помогут вам.</p>
<p>Структура Cargo-проекта:</p>
<pre><code class="language-shell">.
├── Cargo.lock
├── Cargo.toml
├── benches
│   └── large-input.rs
├── examples
│   └── simple.rs
├── src
│   ├── bin
│   │   └── another_executable.rs
│   ├── lib.rs
│   └── main.rs
└── tests
    └── some-integration-tests.rs
</code></pre>
<p>Более подробную информацию о структуре типового Cargo-проекта вы можете узнать на
<a href="http://doc.crates.io/guide.html#project-layout">сайте</a>;</p>
<a class="header" href="#aСборка-и-запуск-cargo-проектов" id="aСборка-и-запуск-cargo-проектов"><h3>Сборка и запуск Cargo проектов</h3></a>
<p>В чём же разница между сборкой и запуском Cargo проекта. Предлагаю разобраться!
Для этого в папке созданного проекта введём следующую cargo-команду - <code>build</code>
(<code>build</code> - это cargo-команда для компиляции текущего проекта. С работой команды <code>new</code>
вы уже знакомы):</p>
<pre><code class="language-shell">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
</code></pre>
<p>Результат - создание бинарного файла в папке <em>target/debug/hello_cargo</em>
(<em>target\debug\hello_cargo.exe</em> в Windows). Проверим работу созданного файла:</p>
<p>Unix:</p>
<pre><code class="language-shell">$ ./target/debug/hello_cargo
Hello, world!
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; .\target\debug\hello_cargo
Hello, world!
&gt; # or .\target\debug\hello_cargo.exe
&gt; # or target\debug\hello_cargo.exe
&gt; # or target\debug\hello_cargo
</code></pre>
<p>Отлично! Всё работает замечательно. :-)</p>
<p>Обратите внимание, что команда <code>cargo build</code> при первом её запуске в текущем
проекте создаёт файл <em>Cargo.lock</em>. Этот файл содержит следующий текст:</p>
<p><span class="filename">Filename: Cargo.lock</span></p>
<pre><code class="language-toml">[root]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;


</code></pre>
<p>Файл <em>Cargo.lock</em> необходим для отслеживания зависимостей вашего проекта.
Так как текущей проект не содержит зависимостей, данный файл не содержит данных
для отслеживания зависимостей. По мере усложнения проекта Cargo будет отслеживать
зависимости (данный файл будет заполняться необходимой для этого информацией).
Более подробно об этом можно узнать из <a href="http://doc.crates.io/guide.html#cargotoml-vs-cargolock">документации</a>
проекта.</p>
<p>Для компиляции и последующего запуска программы на выполнение воспользуйтесь
Cargo-командой <code>run</code>:</p>
<pre><code class="language-shell">$ cargo run
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Обратите внимание, что в командной строке не было напечатано ничего о компиляции.
Cargo умеет отслеживать состояние исходных файлов проекта. Так как изменений не
было - следовательно, перекомпиляция не нужна. Пожалуйста, внесите в исходный код
Rust-файла изменение. Скопируйте строчку кода ввода на печать и вставьте её на
новую строку. Сохраните ваши изменения. Запустите команду Cargo-команду <code>run</code> ещё
раз. Обратите внимание, что программа будет перекомпилирована и запущена.</p>
<pre><code class="language-shell">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Если запустить Cargo-команду <code>run</code> ещё раз - перекомпиляции не случится.</p>
<pre><code class="language-shell">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p><code>shell $ cargo run Running `target/debug/hello_cargo` Hello, world!</code>
Подведём итоги:</p>
<ul>
<li>Для создания сложных проектов вместо того, чтобы использовать Rust-компилятор
<code>rustc</code> непосредственно, наилучшим решением является использование Cargo-команд.</li>
<li>Cargo-структура проекта использует принцип разделения и систематизации, благодаря
которому возможно построение проектов со сложными внешними зависимостями.</li>
</ul>
<p>Кроме того, использование Cargo-команд позволяет вести многоплатформенную разработку.
Более подробно о проекте Cargo и его возможностях можно узнать из документации:</p>
<pre><code class="language-shell">$ cargo --help
</code></pre>
<p>А также из материалов <a href="http://doc.crates.io/">сайта</a>.</p>
<a class="header" href="#aСборка-готовых-оптимизированных-rust-приложений" id="aСборка-готовых-оптимизированных-rust-приложений"><h3>Сборка готовых (оптимизированных) Rust-приложений</h3></a>
<p>Когда проект уже готов к выпуску, можно воспользоваться Cargo-командой <code>build</code> c
флагом <code>--release</code>:</p>
<pre><code class="language-shell">$ cargo build --release
</code></pre>
<p>Эта команда скомпилирует и оптимизирует вашу программу. В папке <em>target/release</em>
будет создан бинарный файл. Все оптимизации позволят программе работать быстрее.
Обратная сторона подобной операции - более длительное время компиляции. Поэтому
существуют две команды компиляции - для разработки и для финальных версий.
Для проверки производительности ваших Rust-программ мы рекомендуем использовать
бинарные файлы, которые были получены путем компиляции и оптимизации (которые
сохраняются в папке <em>target/release</em>).</p>
<a class="header" href="#cargo-as-convention-cargo-конвенции" id="cargo-as-convention-cargo-конвенции"><h3>Cargo as Convention Cargo-конвенции</h3></a>
<p>Конечно, простые примеры не могут раскрыть всех возможностей, которые предоставляет
Cargo по сравнению с прямой работой с компилятором. Для более сложных проектов
концепции Cargo - это проверенный временем стиль разработки. Привыкайте к хорошему
стилю работы даже с простыми проектами!</p>
<p>Этапы начала работы с любым Rust-проектом:</p>
<pre><code class="language-shell">$ git clone someurl.com/someproject
</code></pre>
<pre><code class="language-shell">$ cd someproject
</code></pre>
<pre><code class="language-shell">$ cargo build
</code></pre>
<p>Для того, чтобы почувствовать, что такое работа с &quot;неигрушечным&quot; проектом, проделайте
эти операции на примере проекта Cargo. Ознакомьтесь с содержимым файлов <em>Cargo.toml</em>,
<em>Cargo.lock</em>, посмотрите содержимое папки <em>src</em>.</p>
<p>Проект Cargo находится по адресу: <a href="https://github.com/rust-lang/cargo">github.com/rust-lang/cargo</a>.
Также вы можете попрактиковаться и над другими проектами, исходные коды которых
хранятся на <a href="https://github.com/">github.com</a>. Для их поиска используйте возможности
расширенного поиска <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=language%3ARust&amp;type=Repositories&amp;ref=advsearch&amp;l=Rust&amp;l=">проектов</a>.</p>
<blockquote>
<p>Если вы хотите подробнее ознакомиться с работой проектов Cargo, со всем, что
мы не рассказали в этой вводной статье, пожалуйста, ознакомьтесь с
<a href="http://doc.crates.io/guide.html">официальным руководством</a>.</p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch01-01-installation.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch02-00-guessing-game-tutorial.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch01-01-installation.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch02-00-guessing-game-tutorial.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="store.js"></script>
        <script src="book.js"></script>
    </body>
</html>
