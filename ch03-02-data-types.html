<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Types - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html" class="active"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong aria-hidden="true">20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong aria-hidden="true">20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong aria-hidden="true">20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong aria-hidden="true">20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.6.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch03-02-data-types.html#data-types-Типы-данных" id="data-types-Типы-данных"><h2>Data Types Типы данных</h2></a>
<p>Любая переменная в языке Rust обязательно имеет какой-либо тип. Это даёт возможность
корректной её обработки, а также проведение возможной оптимизации. В этой части
книги вы познакомитесь с встроенными в стандартную библиотеку типами данных,
которые не требуют перед своим использованием каких-либо дополнительных описаний.
И предыдущей секции вы узнали, что типы данных присваиваются перемененным при их
инициализации. В этой секции вы узнаете о типах данных подробнее.</p>
<p>Важной особенностью языка Rust является <em>статическая типизация</em>. Благодаря этому
все типы данных переменных известны при компиляции кода. Конкретный тип данных,
если это не указано заранее, компилятор выбирает сам на основании доступных данных
(на основе конкретного значения и способа его использования). Для устранения
неточности, используется явное указание типа данных:</p>
<p>Также особенностью объявления литерала является возможность аннотирования. Это
позволяет в краткой форме описать тип данных Например: <code>5i32</code>, <code>1u32</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  println!(&quot;guess = {}&quot;,guess);
}
</code></pre></pre>
<p>Пожалуйста, удалите или закомментируйте информацию о типе переменной и, попробовав
скомпилировать код, получите ошибку:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let guess
  //: u32
  = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  println!(&quot;guess = {}&quot;,guess);
}
</code></pre></pre>
<pre><code class="language-text">error[E0282]: unable to infer enough type information about `_`
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ cannot infer type for `_`
  |
  = note: type annotations or generic parameter binding required
</code></pre>
<p>Изучая материалы этой секции, вы познакомитесь с различными типами данных Rust.</p>
<a class="header" href="ch03-02-data-types.html#aСкалярные-типы-данных" id="aСкалярные-типы-данных"><h3>Скалярные типы данных</h3></a>
<p>Скалярный тип данных (scalar data type) содержит одно значение и не имеет внутренних
компонентов. Скалярные типы данных делятся на четыре категории:</p>
<ul>
<li>Числовые.</li>
<li>Символьные.</li>
<li>Даты.</li>
<li>Логические данные.</li>
</ul>
<p>В состав скалярных типов <em>Rust</em> входят:</p>
<ul>
<li>целые числа,</li>
<li>числа с плавающей запятой,</li>
<li>логические,</li>
<li>символьные.</li>
</ul>
<p>Рассмотрим особенности каждого из них по порядку.</p>
<a class="header" href="ch03-02-data-types.html#aЦелые-числа" id="aЦелые-числа"><h4>Целые числа</h4></a>
<p>С одним из целых типом мы уже знакомы. Мы использовали его для уточнения при
конвертации строки в число. Обратите внимание на первый символ с типе <code>u32</code>!
Он указывает на то, что данный тип не может быть отрицательной величиной.
Число, стоящее после буквы указывает на битовую разрядность этого числа.
Если заменить символ <code>u</code> на <code>i</code> <code>u32</code>, то в переменной данного типа можно будет
присваивать отрицательные целый числа. Проверим на нашем примере:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let guess:
  //u32
  i32
  = &quot;-42&quot;.parse().expect(&quot;Not a number!&quot;);
  println!(&quot;guess = {}&quot;,guess);
}
</code></pre></pre>
<p>Обратите внимание, на знак конвертируемого числа <code>-42</code>! Пропробуйте присвоить
это значение беззнаковому типу данных <code>u32</code>!</p>
<p><span class="caption">Table 3-1: Rust. Целочисленные типы данных</span></p>
<table><thead><tr><th> Length </th><th> Signed </th><th> Unsigned </th></tr></thead><tbody>
<tr><td> 8-bit  </td><td> i8     </td><td> u8       </td></tr>
<tr><td> 16-bit </td><td> i16    </td><td> u16      </td></tr>
<tr><td> 32-bit </td><td> i32    </td><td> u32      </td></tr>
<tr><td> 64-bit </td><td> i64    </td><td> u64      </td></tr>
<tr><td> arch   </td><td> isize  </td><td> usize    </td></tr>
</tbody></table>
<p>Пожалуйста, используйте их в нашей программе! Посмотрите на особенности их работы в
коде!</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let guess:
  //u8
  //u16
  //u32
  //u64
  i8
  //i16
  //i32
  //i64
  //isize
  //usize

  = &quot;-42&quot;.parse().expect(&quot;Not a number!&quot;);
  println!(&quot;guess = {}&quot;,guess);
}
</code></pre></pre>
<p>Давайте пристальнее посмотрим на эту сводную таблицу: по горизонтали длины, по
вертикали два варианта числового типа - знакового и беззнакового. Надеюсь, что
теперь ясно какие Rust имеет типы данных. А теперь очень интересный вопрос. Какие
ограничения у этих типов данных. Давайте напишем программу, которая будет выводить
доступные для использования числа в определённом типе данных. Для этого исследования
подойдут уже усвоенные нами знания об особенностях переменных, а также бесконечный цикл.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let mut value:
  u8
  //u16
  //u32
  //u64
  //i8
  //i16
  //i32
  //i64
  //isize
  //usize

  = 0;
  println!(&quot;value = {}&quot;, value);
}
</code></pre></pre>
<p>Запустите программу, измените код так, чтобы программа вывела бы вам все доступные
в указанном типе данных величины. Изучите работу со всеми целочисленными типами!
Благодаря созданным учебным программам Вы узнаете максимально допустимые величины
каждого целочисленного типа данных и, конечно, получите бесценный опыт и уверенность.</p>
<table><thead><tr><th> Type </th><th> Signed min         </th><th> Signed max         </th></tr></thead><tbody>
<tr><td> i8   </td><td> -128               </td><td> 127                </td></tr>
<tr><td> i16  </td><td> -32768             </td><td> 32767              </td></tr>
<tr><td> i32  </td><td>-2147483648         </td><td> 2147483647         </td></tr>
<tr><td> i64  </td><td>-9223372036854775808</td><td> 9223372036854775807</td></tr>
<tr><td> isize</td><td>-9223372036854775808</td><td> 9223372036854775807</td></tr>
</tbody></table>
<table><thead><tr><th> Type </th><th> Unsigned min </th><th> Unsigned max        </th></tr></thead><tbody>
<tr><td> u8   </td><td> 0            </td><td> 255                 </td></tr>
<tr><td> u16  </td><td> 0            </td><td> 65535               </td></tr>
<tr><td> u32  </td><td> 0            </td><td> 4294967295          </td></tr>
<tr><td> u64  </td><td> 0            </td><td> 18446744073709551615</td></tr>
<tr><td> usize</td><td> 0            </td><td> 18446744073709551615</td></tr>
</tbody></table>
<p>Один из возможных вариантов решения. Остановить длинный или бесконечный цикл, зависшее
консольное приложение можно комбинацией клавиш <code>Ctrl-C</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let max = &lt;i8&gt;::max_value();
    let mut value = &lt;i8&gt;::min_value();
    loop {
        value = value + 1;

        println!(&quot;value = {}&quot;, value);

        if value == max {
            break;
        }
    }
}

</code></pre></pre>
<p>Каждый знаковый числовой тип хранит данные от -(2<sup>n - 1</sup>) до 2<sup>n -
1</sup> - 1 включительно, где n - это количество использованных битов данных.
Переменная типа данных <code>i8</code> может хранить значения от -(2<sup>7</sup>) до
2<sup>7</sup> - 1. Что эквивалентно следующему отрезку [-128, 127]. А беззнаковая
переменная такого же битового размера может хранить величины от 0 до 255.</p>
<p>Обратите внимание на типы данных <code>isize</code> и <code>usize</code>. Их битовая ёмкость зависит от
архитектуры операционной системы. Если система 32-битная - переменные могут хранить
32-битные величины, если 64-битные соответственно.</p>
<p>Кроме ёмкости целочисленные переменные могут иметь различные обозначения.
Так одно и тоже число может быть записана в разных системах счисления. Её выбор
зависит от замысла программиста. Есть также возможность указать тип литерала непосредственно
при его написании (в виде суффикса числа). Правда есть ограничения (битовая система
счисления не имеет суффикса). Также для удобства представления есть возможность
использовать визуальные разделитель разрядов <code>_</code>.</p>
<p><span class="caption">Table 3-2: Integer Literals in Rust</span></p>
<table><thead><tr><th> Number literals  </th><th> Example       </th></tr></thead><tbody>
<tr><td> Decimal          </td><td> <code>98_222</code>      </td></tr>
<tr><td> Hex              </td><td> <code>0xff</code>        </td></tr>
<tr><td> Octal            </td><td> <code>0o77</code>        </td></tr>
<tr><td> Binary           </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Byte (<code>u8</code> only) </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<pre><pre class="playpen"><code class="language-rust">fn main() {

  let value = 98_222_000;
  println!(&quot;value = {}&quot;, value);

  let value = 0xff;
  println!(&quot;value = {}&quot;, value);

  let value = 0o77;
  println!(&quot;value = {}&quot;, value);

  let value = 0b1111_0000;
  println!(&quot;value = {}&quot;, value);

  let value = b'A';
  println!(&quot;value = {}&quot;, value);

}
</code></pre></pre>
<p>Если вы не уверены какой тип данных выбрать - используйте тип по умолчанию. Это
<code>i32</code>. Типы данных <code>isize</code> или <code>usize</code> используются при сортировке наборов данных.</p>
<p>Примеры использования различных видов написания целочисленных числовых данных:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let value = 98_222_000;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0xff;
    println!(&quot;value = {}&quot;, value);
    value = 0x_ff;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0o77;
    println!(&quot;value = {}&quot;, value);
    value = 0o_77;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0b1111_0000;
    println!(&quot;value = {}&quot;, value);
    value = 0b1_111_0000;
    println!(&quot;value = {}&quot;, value);

    let value = b'A';
    println!(&quot;value = {}&quot;, value);
}

</code></pre></pre>
<p>Примеры использование разделителя <code>_</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let value = 98_222_000;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0xff;
    println!(&quot;value = {}&quot;, value);
    value = 0x_ff;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0o77;
    println!(&quot;value = {}&quot;, value);
    value = 0o_77;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0b1111_0000;
    println!(&quot;value = {}&quot;, value);
    value = 0b1_111_0000;
    println!(&quot;value = {}&quot;, value);

    let value = b'A';
    println!(&quot;value = {}&quot;, value);
}

</code></pre></pre>
<p>Обратите внимание на результаты работы программы, при использовании инициализации
по умолчанию данными значениями:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    //let value = 9223372036854775807;
    let value:i64 = 9223372036854775807;
    println!(&quot;value = {}&quot;, value);

    //let value = -9223372036854775808;
    let value:i64 = -9223372036854775808;
    println!(&quot;value = {}&quot;, value);

    //let value = 18446744073709551615;
    let value:u64 = 18446744073709551615;
    println!(&quot;value = {}&quot;, value);
}

</code></pre></pre>
<p>Пожалуйста, проверьте вышеописанную информацию, используя теоретическую
информацию в ваших программных кодах.
Уверен, что вы столкнётесь с различными сюрпризами, которые помогут усвоению
пройденного материала и ускорят ваше становления в качестве знатока Rust. Пишите
код, пишите!</p>
<a class="header" href="ch03-02-data-types.html#aЧисла-с-плавающей-запятой" id="aЧисла-с-плавающей-запятой"><h4>Числа с плавающей запятой</h4></a>
<p>Кроме типов данных обозначающие целые числа Rust имеет два типа данных обозначающие
числа с плавающей запятой. Это 32- и 64-битные величины - <code>f32</code> и <code>f64</code>.
По умолчанию, т.е. при автоматическом определении типа используется <code>f64</code>.
Хотя скорость обработки данных не зависит он разрядности конкретного типа, всё же
на 32-разрядных системах для увеличения производительности рекомендуется использовать
<code>f32</code>.</p>
<p>Пример инициализации чисел с плавающей запятой:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}

</code></pre></pre>
<p>Очень важно знать предельные значения типов данных. Стандратная библиотек Rust
проелагает подробную информацию по каждому типу данных.
Узнать максимальное и минимальное значения этих типов данных нам поможет &quot;изящное&quot;
решение:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let value32_min = std::f32::MIN;
    println!(&quot;value f32 min = {}&quot;, value32_min);
    let value32_max = std::f32::MAX;
    println!(&quot;value f32 max = {}&quot;, value32_max);

    let value64_min = std::f64::MIN;
    println!(&quot;value f64 min = {}&quot;, value64_min);
    let value64_max = std::f64::MAX;
    println!(&quot;value f64 max = {}&quot;, value64_max);
}
</code></pre></pre>
<p>Формат чисел с плавающей запятой соответствует стандарту IEEE-754. При этом <code>f32</code> -
это числа с единичной точностью, а <code>f64</code> с двойной точностью.</p>
<p>Пожалуйста, самостоятельно изучите состав констант модуля <code>std::f32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
fn main() {
    println!(&quot;std::f32&quot;);
    // Approximate number of significant digits in base 10.
    println!(&quot;DIGITS = {}&quot;, std::f32::DIGITS);

    // Difference between 1.0 and the next largest representable number.
    println!(&quot;EPSILON = {}&quot;, std::f32::EPSILON);

    // Infinity (∞).
    println!(&quot;INFINITY = {}&quot;, std::f32::INFINITY);

    // Number of significant digits in base 2.
    println!(&quot;MANTISSA_DIGITS = {}&quot;, std::f32::MANTISSA_DIGITS);

    // Largest finite f32 value.
    println!(&quot;MAX = {}&quot;, std::f32::MAX);

    // Maximum possible power of 10 exponent.
    println!(&quot;MAX_10_EXP = {}&quot;, std::f32::MAX_10_EXP);

    // Maximum possible power of 2 exponent.
    println!(&quot;MAX_EXP = {}&quot;, std::f32::MAX_EXP);

    // Smallest finite f32 value.
    println!(&quot;MIN = {}&quot;, std::f32::MIN);

    // Minimum possible normal power of 10 exponent.
    println!(&quot;MIN_10_EXP = {}&quot;, std::f32::MIN_10_EXP);

    // One greater than the minimum possible normal power of 2 exponent.
    println!(&quot;MIN_EXP = {}&quot;, std::f32::MIN_EXP);

    // Smallest positive normal f32 value.
    println!(&quot;MIN_POSITIVE = {}&quot;, std::f32::MIN_POSITIVE);

    // Not a Number (NaN).
    println!(&quot;NAN = {}&quot;, std::f32::NAN);

    // Negative infinity (-∞).
    println!(&quot;NEG_INFINITY = {}&quot;, std::f32::NEG_INFINITY);

    // The radix or base of the internal representation of f32.
    println!(&quot;RADIX = {}&quot;, std::f32::RADIX);
}

</code></pre></pre>
<p>Пожалуйста, самостоятельно изучите состав констант модуля <code>std::f64</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
fn main() {
    println!(&quot;std::f64&quot;);
    // Approximate number of significant digits in base 10.
    println!(&quot;DIGITS = {}&quot;, std::f64::DIGITS);

    // Difference between 1.0 and the next largest representable number.
    println!(&quot;EPSILON = {}&quot;, std::f64::EPSILON);

    // Infinity (∞).
    println!(&quot;INFINITY = {}&quot;, std::f64::INFINITY);

    // Number of significant digits in base 2.
    println!(&quot;MANTISSA_DIGITS = {}&quot;, std::f64::MANTISSA_DIGITS);

    // Largest finite f64 value.
    println!(&quot;MAX = {}&quot;, std::f64::MAX);

    // Maximum possible power of 10 exponent.
    println!(&quot;MAX_10_EXP = {}&quot;, std::f64::MAX_10_EXP);

    // Maximum possible power of 2 exponent.
    println!(&quot;MAX_EXP = {}&quot;, std::f64::MAX_EXP);

    // Smallest finite f64 value.
    println!(&quot;MIN = {}&quot;, std::f64::MIN);

    // Minimum possible normal power of 10 exponent.
    println!(&quot;MIN_10_EXP = {}&quot;, std::f64::MIN_10_EXP);

    // One greater than the minimum possible normal power of 2 exponent.
    println!(&quot;MIN_EXP = {}&quot;, std::f64::MIN_EXP);

    // Smallest positive normal f64 value.
    println!(&quot;MIN_POSITIVE = {}&quot;, std::f64::MIN_POSITIVE);

    // Not a Number (NaN).
    println!(&quot;NAN = {}&quot;, std::f64::NAN);

    // Negative infinity (-∞).
    println!(&quot;NEG_INFINITY = {}&quot;, std::f64::NEG_INFINITY);

    // The radix or base of the internal representation of f64.
    println!(&quot;RADIX = {}&quot;, std::f64::RADIX);
}

</code></pre></pre>
<a class="header" href="ch03-02-data-types.html#aЧиcловые-операции" id="aЧиcловые-операции"><h4>Чиcловые операции</h4></a>
<p>Rust предоставляет основные математические операции с числовыми типами данных:</p>
<ul>
<li>сумма,</li>
<li>разность,</li>
<li>умножение,</li>
<li>деление,</li>
<li>остаток от деления.</li>
</ul>
<p>Пример их использования:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;

    println!(&quot;sum = {}&quot;, sum);
    println!(&quot;difference = {}&quot;, difference);
    println!(&quot;product = {}&quot;, product);
    println!(&quot;quotient = {}&quot;, quotient);
    println!(&quot;remainder = {}&quot;, remainder);
}

</code></pre></pre>
<p>Каждое из этих выражений использует математические операции и вычисляет значение,
которые присваивается переменной. Приложение 2 содержит список всех математических
операции языка Rust.</p>
<a class="header" href="ch03-02-data-types.html#aЛогический-тип-данных" id="aЛогический-тип-данных"><h4>Логический тип данных</h4></a>
<p>В языке Rust логический тип данных <code>bool</code> может принимать два значения - <code>true</code>
и <code>false</code>. Обратите внимание, что Rust чувствительный к регистру. Так что любые
вариации с регистром в константных величинах будут считаться ошибкой.</p>
<p>Пример использования:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

    let t = true;

    println!(&quot;t = {}&quot;, t);
    println!(&quot;!t = {}&quot;, !t);
    println!(&quot;t &amp;&amp; t= {}&quot;, t &amp;&amp; t);
    println!(&quot;t || t= {}&quot;, t || t);

    let f: bool = false; // with explicit type annotation

    println!(&quot;f = {}&quot;, f);
    println!(&quot;!t = {}&quot;, !t);
    println!(&quot;t &amp;&amp; t= {}&quot;, t &amp;&amp; t);
    println!(&quot;t || t= {}&quot;, t || t);
}

</code></pre></pre>
<p>Логические значение применяются в операторах сравнения <code>if</code>, <code>for</code>.</p>
<a class="header" href="ch03-02-data-types.html#aСимвольный-тип-данных" id="aСимвольный-тип-данных"><h4>Символьный тип данных</h4></a>
<p>В Rust поддерживается работа с символьным типом данных <code>char</code>.
Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let c:char = 'z';
  let z = 'ℤ';
  let heart_eyed_cat = '😻';
  println!(&quot;c = {}&quot;, c);
  println!(&quot;z = {}&quot;, z);
  println!(&quot;heart_eyed_cat = {}&quot;, heart_eyed_cat);
}
</code></pre></pre>
<p>Размер для хранения одного символа составляет 4 байта.
Символьный тип поддерживает Юникод. Поддерживаются сложные символьные-юникод структуры,
такие как символы с ударением, китайские/японские/корейские иероглифы, смайлики
и другие возможные символы. Внутреннее представление символов не соответствует концепции
юникода. Подробнее об этом можно ознакомиться в главе 8.</p>
<a class="header" href="ch03-02-data-types.html#aСложные-типы-данных" id="aСложные-типы-данных"><h3>Сложные типы данных</h3></a>
<p><em>Сложные типы данных</em> - это группа множества значений объединённых в один тип данных.
В Rust существует два способа описания такого рода объединения типов. Это кортежи
(упорядоченный набор фиксированной длинны) и массивы.</p>
<a class="header" href="ch03-02-data-types.html#aГруппировка-значений-в-кортежи-tuples" id="aГруппировка-значений-в-кортежи-tuples"><h4>Группировка значений в кортежи (Tuples)</h4></a>
<p>Кортеж - это способ группировки множества различные типов значений в один сложный
тип.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    println!(&quot;tup = {:?}&quot;, tup);
}
</code></pre></pre>
<p>Присвоение множеству переменных содержание кортежа:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of (x,y,z) is: ({},{},{})&quot;, x, y, z);
}

</code></pre></pre>
<p>Есть ещё один способ доступа к содержанию кортежа - по индексу - с помощью <code>.</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let x: (i32, f64, u8) = (500, 6.4, 1);
  let v1 = x.0;
  let v2 = x.1;
  let v3= x.2;

  println!(&quot;The value of (x,y,z) is: ({},{},{})&quot;, v1,v2,v3);
}
</code></pre></pre>
<p>Обратите внимание, каким образом были определены типы данных кортежа.</p>
<a class="header" href="ch03-02-data-types.html#aМассивы" id="aМассивы"><h4>Массивы</h4></a>
<p>Массивы отличаются от кортежей большими ограничениями. В массиве все значения
имеют одинаковый тип данных. Также важной особенностью массивов является их размер.
Он фиксируется при создании и не может быть изменён.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
    let b: [u8; 5] = [1, 2, 3, 4, 5];
    println!(&quot;a is: {:?}&quot;, a);
    println!(&quot;b is: {:?}&quot;, b);
}
</code></pre></pre>
<p>Обратите внимание на тип скобок в выражении инициализации массива - они квадратные.
В стандартной библиотеке есть тип данных, аналогичный массиву, но имеющий возможность
изменения содержания - это вектор.</p>
<p>Массивы подходят для хранения группы данных, состав и значения которых заранее
известны:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
           &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
println!(&quot;a is: {:?}&quot;, months);
#}</code></pre></pre>
<a class="header" href="ch03-02-data-types.html#aОрганизация-доступа-к-элементам-массива" id="aОрганизация-доступа-к-элементам-массива"><h5>Организация доступа к элементам массива</h5></a>
<p>Массив - это непрерывная область памяти, содержащаяся в стеке. Вы можете получить
доступ к какому-либо элементу по его индексу:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];

    println!(&quot;first = {}, second = {}&quot;, first, second);
}

</code></pre></pre>
<a class="header" href="ch03-02-data-types.html#aОшибка-доступа-к-элементу-массива" id="aОшибка-доступа-к-элементу-массива"><h5>Ошибка доступа к элементу массива</h5></a>
<p>При попытке доступа к несуществующему индексу массива - программа аварийно завершиться.
Важной особенностью языка Rust является предотвращения доступа к памяти, если
произошла ошибка какого-либо рода. Для системного языка программирования это большой
плюс, т.к. существует возможность на уровне языка предотвратить несанкционированный
доступ к памяти.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre>
<p>Описание ошибки при запуске этой программы:</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>В главе 9 будет подробно рассказано об возможных реакциях на ошибку.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
