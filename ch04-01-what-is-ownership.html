<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What is Ownership? - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html" class="active"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong aria-hidden="true">20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong aria-hidden="true">20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong aria-hidden="true">20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong aria-hidden="true">20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.6.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch04-01-what-is-ownership.html#aЧто-же-такое-владение" id="aЧто-же-такое-владение"><h2>Что же такое владение?</h2></a>
<p><em>Владение</em> является весьма важной концепцией Rust. Неудивительно, что она весьма сильно
повлияла на язык программирования в целом.</p>
<p>Существуем множество решений по управлению памятью во время работы программ.
Это системы сборки мусора (куча), ручное управление выделенными ресурсами. Rust предлагает
своё решение: управление ресурсами осуществляется по средством набора правил владения,
которые компилятор проверяет во время создания программы (компиляции). Благодаря
этому отсутствует необходимость управления памятью во время работы программы.
Звучит весьма заманчиво, неправда ли?! Об этом так давно мечтали в равной степени,
как программисты Си, так и Java.</p>
<p>Так как эта концепция ещё нова для многих программистов, её осознание и эффективное
использование потребует определённых навыков. Наградой будет владением инструментом
для создания безопасных и эффективных программы. Думаю, что данная цель того стоит.</p>
<p>Понимание концепции владениия даст вам основу для понимания всех остальных особенностей
Rust. В этой главе вы будите изучать владение на примере работы с строковым типом
данных.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="ch04-01-what-is-ownership.html#aСтек-и-куча" id="aСтек-и-куча"><h3>Стек и куча</h3></a>
<p>Во многих языках программирования не принято уделять много внимания организации
работы с памятью. Для системного языка программирование эта тема весьма важна.
Место хранения переменной (это стек или куча) очень важно. Это весьма сильно
влияет на языковые конструкции и рекомендуемых шаблоны.</p>
<p>Хотя и стек и куча - это всё части доступной для программ области памяти, но их
структура и способы взаимодействия с ними различна. Стек сохраняет значения в
порядке получения и удаляет их в противоположном порядке (LIFO - <em>last in, first out</em>).
Стек подобен стопке тарелок. Вы накладываете тарелки сверху и когда нужно берёте
их сверху.</p>
</blockquote>
<blockquote>
<p>Работа со стеком даёт большой выигрыш по времени, т.к. нет необходимости в системе
поиска нужных данных, а также все сохраняемые там данные имеют известный размер.</p>
<p>Для тех данных, размер которых не известен во время компиляции используется другое
место хранения - куча. В куче нет чёткой организации данных. Когда вы сохраняете
данные в куче, вы запрашиваете произвольный размер памяти. Операционная система
ищет необходимый блок и предоставляет ссылку на его начало. Этот процесс называется
<em>выделение памяти в куче</em>. Или просто <em>выделение памяти</em>.</p>
<p>Система выделения памяти работает медленнее стека, т.к. мы должны затратить время
на поиск места в памяти.</p>
<p>Когда код вызывает функцию, все локальные переменные сохраняются в стеке,
когда функция прекращает работу все её переменные удаляются из стека.</p>
<p>Отслеживание какая часть кода использует данные из кучи, минимизирует дублирование
и удаляет ненужное. Это приводит к эффективному расходованию системных ресурсов.
Когда вы разберётесь с концепцией владения вы не будете думать о стеке и куче,
но всё же понимание как эти системы распределения памяти работают поможет более
глубоком пониманию теоретического материала.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="ch04-01-what-is-ownership.html#aПравила-владения" id="aПравила-владения"><h3>Правила владения</h3></a>
<p>Прежде всего, давайте познакомимся с самими правилами. Пожалуйста, помните о них
во время практической работы с примерами программ:</p>
<blockquote>
<ol>
<li>Каждое значение имеет переменную, которая ей владеет, т.е. имеет <em>владельца</em>.</li>
<li>Одновременно, у значения может быть только один владелец.</li>
<li>Когда переменная выходит за область видимости, значение удаляется.</li>
</ol>
</blockquote>
<a class="header" href="ch04-01-what-is-ownership.html#aОбласть-видимости-переменной" id="aОбласть-видимости-переменной"><h3>Область видимости переменной</h3></a>
<p>Для объяснения области видимости мы абстрагируемся о какого-либо контейнера.
Будем считать, что код находится в каком-то контейнере, например, внутри определения
функции <code>main</code>.</p>
<p>Рассмотрим область видимости переменной. Область видимости - это область, в которой
с переменной можно осуществлять какие-либо действия. Сначала объявим переменную:</p>
<pre><code class="language-rust ignore">let s = &quot;hello&quot;;
</code></pre>
<p>Переменная <code>s</code> ссылается на строковый литерал. Значение данной переменной вписано
в код программы. Переменная считается действительной с момента её объявления до
конца текущей области видимости.</p>
<p>Два важных замечания:</p>
<ol>
<li>Когда переменная <code>s</code> появляется в области видимости она считается действительной.</li>
<li>Она остаётся действительно до момента выхода за границы этой области.</li>
</ol>
<p>Отталкиваясь от понимания этих замечаний мы переходим к объяснению более сложной
концепции.</p>
<a class="header" href="ch04-01-what-is-ownership.html#aТип-данных-string" id="aТип-данных-string"><h3>Тип данных <code>String</code></h3></a>
<p>Для объяснения правил владения, рассмотрим более сложный тип данных. До сих пор
мы рассматривали типы данных, которые хранились в стеке. Теперь рассмотрим данные,
которые хранятся в куче и рассмотрим, как Rust узнаёт, когда можно удалить данные.</p>
<p>Мы будем использовать тип данных <code>String</code> и рассмотрим ту часть описания данного
типа, которая связана с владением. Владение работает таким же образом и других
типах данных. Более подробно мы познакомимся с типом данных <code>String</code> в главе 8.</p>
<p>Мы уже видели работу со строковыми литералами в предыдущих главах, где значение
строк было вписано в код программы. Строковые литералы удобны для использования,
но не могут решить всех вопросов при работе с этим типом данных. Важной особенностью
строковых литералов является их неизменяемость. Для работы с текстовыми данными,
когда их значение и размер заранее не известен (например, при вводе данных с клавиатуры),
используется тип данных <code>String</code>. Данные этого типа хранятся в куче. Размер
таких данных неизвестен в момент компиляции. Вы можете создать переменную данного
типа с помощью статической функции <code>from</code>:</p>
<pre><code class="language-rust ignore">let s = String::from(&quot;hello&quot;);
</code></pre>
<p>Двойное двоеточие (<code>::</code>) - это оператор, которые определяет пространство имён типа.
В данному случает пространство имён типа <code>String</code>. Более подробно мы обсудим синтаксис
методов в главе 5. Пространство имён обсудим в главе 7.</p>
<p>Такие строки <em>могут</em> быть изменены:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String

    println!(&quot;{}&quot;, s); // This will print `hello, world!`
}

</code></pre></pre>
<p>В чём же отличия типов данных изменяемых строковых <code>String</code> и неизменяемых литеральных?
Отличия в способе работы с памятью.</p>
<a class="header" href="ch04-01-what-is-ownership.html#aПамять-и-способы-ещё-выделения" id="aПамять-и-способы-ещё-выделения"><h3>Память и способы ещё выделения</h3></a>
<p>Тот факт, что значение литеральных типов известно в момент компиляции делает работу
с ними таким эффективным. К сожалению, мы не можем заранее выделить часть памяти
для хранения данных неизвестного типа и размера.</p>
<p>Для хранения таких данных (таких как данные типа <code>String</code>) наиболее удобно использовать
кучу. Это значит, что:</p>
<ol>
<li>Размер необходимой памяти запрашивается программой в момент её выполнения.</li>
<li>Необходим механизм возвращения неиспользуемой памяти обратно операционной системе.</li>
</ol>
<p>Первый пункт этого списка решается с помощью метода типа <code>String::from</code>. Это довольно-таки
универсальное решение.</p>
<p>Но второй пункт довольно-таки специфичен для каждой системы (языка программирования,
технологии). Там где используется сборщики мусора. Там где нет сборщиков мусора
программист сам должен отслеживать использование ресурсов и явным образом их освобождать.
Исторически, корректное освобождение ресурсов - источник ошибок и одна из проблем
в программировании.  Если данные не удаляются своевременно, это приводит к бесполезному
расходованию ресурсов.  Если данные удаляются, а часть переменных программы ссылается
на них - это приводит к сбоям. Повторное возвращение данных операционной системе
также приводит к ошибкам. Мы можем один раз получить и один раз возвратить ресурсы.</p>
<p>Rust предлагает решение этой проблемы - ресурсы памяти возвращаются автоматически,
когда переменная вышла за область видимости. Пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;hello&quot;); // s is valid from this point forward

    // do stuff with s
}                                  // this scope is now over, and s is no
                                   // longer valid
#}</code></pre></pre>
<p>Это довольно-таки естественные способ освобождение неиспользованной памяти. Когда
переменная выходит за рамки области видимости, Rust вызывает специальную функцию
для освобождения памяти. Эта функция называется <code>drop</code>. Можно сказать, что это последний
оператор в любой области видимости.</p>
<blockquote>
<p>Обратите внимание: В C++, такой шаблон освобождения ресурсов называется
<em>Получение ресурса есть инициализация</em> (<em>Resource Acquisition Is Initialization (RAII)</em>).
Функция <code>drop</code> будет вам понятная, если у Вас уже есть опыт использования данного
шаблона при программировании на C++.</p>
</blockquote>
<p>Это шаблон сильно влияет на стиль, способ создания программ на Rust. Поведение программы
может быть непредсказуемым, когда необходимо нескольким переменным использовать
данные из кучи. Рассмотрим эту ситуацию подробнее:</p>
<a class="header" href="ch04-01-what-is-ownership.html#aСпособы-взаимодействия-переменных-и-данных-перемещение" id="aСпособы-взаимодействия-переменных-и-данных-перемещение"><h4>Способы взаимодействия переменных и данных: перемещение</h4></a>
<p>Несколько переменных может взаимодействовать с одними и теме же данными различными
способами. Listing 4-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">Listing 4-2: Присваивание целочисленного значения переменной
<code>x</code>переменной <code>y</code></span></p>
<p>Вы, конечно, можете догадаться, что же тут происходит. Переменной <code>x</code> присваивается
значение <code>5</code>. Потом создаётся копия этого значения, которая присваивается переменной
<code>y</code>. После выполнения этих строчек кода обе переменные будут иметь значение <code>5</code>.
Эти переменные имеют простой тип данных и известные в момент компиляции значения.
Вся данные хранятся в стеке.</p>
<p>Теперь рассмотрим этот же пример с другим типом данныx (<code>String</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>Хотя код внешне выглядит таким же, алгоритм работы совсем иной.</p>
<p>Для более подробного объяснения давайте рассмотрим структуру <code>String</code> (рисунок 4-3).
<code>String</code> состоит из трёх частей: ссылки а память, которая содержит данные, длину
и ёмкость. Эта группа данных сохраняется в стеке. Справа память кучи, которая
содержит данные.</p>
<p><img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-3: Представление переменной <code>s1</code> в памяти, имеющей
тип данных <code>String</code>, содержащей значение <code>&quot;hello&quot;</code></span></p>
<p>Длина (в байтах) содержит величину данных, которое в данных момент используется.
Ёмкость - это общее количество памяти (в байтах), которое переменная получила от
операционной системы. Разница между длинной данных и ёмкостью, конечно имеет значение,
но для объяснение взаимодействия переменной и памяти эта информация никак не повлияет.
Пока проигнорируем эту разницу.</p>
<p>При присваивании переменной <code>s1</code> переменной <code>s2</code> данные типа копируются в стеке,
т.е. копируются данные о ссылке, длине и ёмкости. Представления данных в памяти
выглядит следующим образом (Рисунок 4-4).</p>
<p><img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок  4-4: Представление в памяти переменной <code>s2</code>
которая содержит копию ссылки, длинны и ёмкости переменной <code>s1</code></span></p>
<p>Это представление отличается от того, если бы копировалось всё содержимое кучи.
Если бы Rust позволял это делать, операция присваивания <code>s2 = s1</code> могла быть очень
затратной (по скорости её выполнения), если бы ёмкость копируемых данных и их сложность
была высокой.</p>
<p><img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-5: Другая возможность при копировании <code>s2 = s1</code>  -
копирование содержимого кучи</span></p>
<p>Ранее, мы говорили, что когда переменная выходит за границы области видимости, Rust
автоматически вызывает метод <code>drop</code> и очищает память кучи для этой переменной. Рисунок
4-4 показывает, что имеется две ссылки на одни данные. Это является проблемой и
источником потенциальной ошибки, т.к. переменные <code>s2</code> и <code>s1</code> обе вышли за границы
области видимости и ссылаются на одни и те же данные. Это ошибка называется
<em>двойная очистка</em>. Такая двойная очистка может быть причиной повреждения данных
в памяти, что в свою очередь может привести к проблемам безопасности.</p>
<p>Для обеспечения безопасности памяти, существует решение. Вместо копирования выделенной
памяти, Rust считает переменную <code>s1</code> недействительной. Кроме того т.к. переменная не
является действительной, то она не должна ничего освобождать. Пожалуйста, проверьте,
что произойдёт, когда вы попытаетесь использовать переменную <code>s1</code> после создания
<code>s2</code>:</p>
<pre><code class="language-rust ignore">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
    println!(&quot;{}, world!&quot;, s2);
}

</code></pre>
<p>В терминальной строке вы увидите подобное сообщение, информирующее о том, что переменную
<code>s1</code> уже нельзя использовать:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:4:27
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
which does not implement the `Copy` trait
</code></pre>
<p>Вы, наверное, уже слышали о разных вариациях копирования. Концепция копирования в Rust
может показать похожей на одну из них. Но у Rust есть существенное отличие - копируемая
переменная становится недействительной после операции копирования в другую переменную.
Эта операция называется перемещением. Так что можно сказать, что переменная <code>s1</code>
была перемещена в переменную <code>s2</code>. То, что действительно произошло показано на рисунке
4-6.</p>
<p><img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-6: Состояние памяти после перемещения переменной <code>s1</code></span></p>
<p>Это решает проблему множественного доступа к памяти в куче. Такой проблемы
просто нет. Только одна переменная действительна имеет права на данные - это переменная
<code>s2</code>.</p>
<p>Также обратите внимание, что Rust никогда не делает полного копирования данных.
Поэтому любое автоматическое копирование может быть недорогим с точки зрения производительности.</p>
<a class="header" href="ch04-01-what-is-ownership.html#aСпособы-взаимодействия-переменныx-и-данных-клонироване" id="aСпособы-взаимодействия-переменныx-и-данных-клонироване"><h4>Способы взаимодействия переменныx и данных: клонироване</h4></a>
<p>Если вы действительно хотите глубокого копирования данных в куче типа данных <code>String</code>,
вы можете использовать метод <code>clone</code>. Мы подробнее расскажем о синтаксисе этого
метода в главе 5.</p>
<p>Пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>Этот метод копирования замечательно работает и это способ, который вы можете использовать,
чтобы добиться поведения описанного на рисунке 4-5 (где данные кучи были скопированы).</p>
<p>Когда в исходном коде программы вы встречаете использование метода <code>clone</code> знайте,
что использование этого метода может быть затратным по производительности.</p>
<a class="header" href="ch04-01-what-is-ownership.html#aСтековые-данные-Копирование" id="aСтековые-данные-Копирование"><h4>Стековые данные: Копирование</h4></a>
<p>Это ещё одна особенность о которой мы ещё не говорили. Этот код использует целые
числа, часть которого была показа ранее в листинге 4-2. Этот код работает и не имеет
ошибок:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Но этот код кажется противоречит тому, что мы только что изучили: мы не должны
вызывать <code>clone</code>, но <code>x</code> остаётся действительной переменнной и не перемещается в <code>y</code></p>
<p>В Rust есть специальная аннотация <code>Copy</code> типаж, благодаря которой любой тип может
быть сохранён в стеке. Если тип имеет типаж <code>Copy</code>, переменные которые владели данными
до текущей переменной остаются доступными. Rust имеет следующие ограничения: тип не может
одновременно иметь типаж <code>Copy</code> и <code>Drop</code>. Любая группа скалярных значений может быть
<code>Copy</code>.</p>
<p>Список типов, которые имею типаж <code>Copy</code>:</p>
<ul>
<li>Все целочисленные типы, такие как <code>u32</code>.</li>
<li>Логический тип данных <code>bool</code>, значения которых <code>true</code> и <code>false</code>.</li>
<li>Все числа с плавающей запятой такие как <code>f64</code>.</li>
<li>Кортежи, но только если они содержат типы, которые также <code>Copy</code>. <code>(i32, i32)</code>
<code>Copy</code>, но <code>(i32, String)</code> нет.</li>
</ul>
<a class="header" href="ch04-01-what-is-ownership.html#aВладение-и-функции" id="aВладение-и-функции"><h3>Владение и функции</h3></a>
<p>Симантически передача значений в функцию схожа с присвоением значения переменной.
Переменная, которая передаётся в функцию будет перемещаться или копироваться. Пример
кода 4-7 демонстрирует как переменные входят и выходят из области видимости:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s comes into scope.

    takes_ownership(s);             // s's value moves into the function...
    //println!(&quot;{}&quot;, s);    // ... and so is no longer valid here.
    let x = 5;                      // x comes into scope.

    makes_copy(x);                  // x would move into the function,
    println!(&quot;{}&quot;, x);              // but i32 is Copy, so it’s okay to still
                                    // use x afterward.

} // Here, x goes out of scope, then s. But since s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope.
    println!(&quot;{}&quot;, some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope.
    println!(&quot;{}&quot;, some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
</code></pre></pre>
<p><span class="caption">Listing 4-7: Демонстрация изменения владения посредством передачи
функции переменной. Демонстрация выхода переменной за пределы области видимости и
освобождения ресурсов</span></p>
<p>Если вы попытаетесь использовать переменную после вызова метода <code>takes_ownership</code>,
компилятор Rust сообщит вам об ошибке. При повторном использовании переменной
<code>x</code> всё будет в порядке.</p>
<a class="header" href="ch04-01-what-is-ownership.html#aВозвращения-данных-из-области-видимости" id="aВозвращения-данных-из-области-видимости"><h3>Возвращения данных из области видимости</h3></a>
<p>Возвращение значений также может переместить владение.
Пример 4-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1: String = gives_ownership();
    println!(&quot;{}&quot;,s1);                       // takes_and_gives_back, which also                                    // value into s1.

    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope.

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
    //println!(&quot;{}&quot;,s2);                                    // takes_and_gives_back, which also
    println!(&quot;{}&quot;,s3);                                    // moves its return value into s3.
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it.

    let some_string = String::from(&quot;hello&quot;); // some_string comes into scope.
    println!(&quot;{}&quot;,some_string);
    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function.
}

// takes_and_gives_back will take a String and return one.
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope.

    a_string  // a_string is returned and moves out to the calling function.
}
</code></pre></pre>
<p>Изменение владения ведётся по описанным ранее законам. Оно перемещается при изменении
владельца данных.</p>
<p>На практике очень неудобно всегда отслеживать владение данными.</p>
<p>При передаче данных в функцию и из функции, для упрощения работы, удобно использовать
кортежи:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String.

    (s, length)
}
</code></pre></pre>
<p>Было бы конечно сложно писать программы на Rust если бы это были бы все опции
доступные программисту при работе с владением памятью. К счастью, существуют
<em>ссылки</em>, которые упрощают эту работу.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
