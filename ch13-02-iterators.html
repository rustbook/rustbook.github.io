<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Iterators - Iterators - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <style>
            .page-wrapper.has-warning > .nav-chapters {
              /* add height for warning content & margin */
              top: 120px;
            }

            p.warning {
                background-color: rgb(242, 222, 222);
                border-bottom-color: rgb(238, 211, 215);
                border-bottom-left-radius: 4px;
                border-bottom-right-radius: 4px;
                border-bottom-style: solid;
                border-bottom-width: 0.666667px;
                border-image-outset: 0 0 0 0;
                border-image-repeat: stretch stretch;
                border-image-slice: 100% 100% 100% 100%;
                border-image-source: none;
                border-image-width: 1 1 1 1;
                border-left-color: rgb(238, 211, 215);
                border-left-style: solid;
                border-left-width: 0.666667px;
                border-right-color: rgb(238, 211, 215);
                border-right-style: solid;
                border-right-width: 0.666667px;
                border-top-color: rgb(238, 211, 215);
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                border-top-style: solid;
                border-top-width: 0.666667px;
                color: rgb(185, 74, 72);
                margin-bottom: 0px;
                margin-left: 0px;
                margin-right: 0px;
                margin-top: 30px;
                padding-bottom: 8px;
                padding-left: 14px;
                padding-right: 35px;
                padding-top: 8px;
            }
            p.warning strong {
                color: rgb(185, 74, 72)
            }
            p.warning a {
                color: rgb(0, 136, 204)
            }

            a .hljs {
                color: #4183c4;
            }

            .rust .content a .hljs,
            .coal .content a .hljs,
            .navy .content a .hljs {
                color: #2b79a2;
            }

            a:hover .hljs {
                text-decoration: underline;
            }

            /* Styles keystrokes such as ctrl-C */
            .keystroke {
                font-variant: small-caps;
            }
        </style>

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html" class="active"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong aria-hidden="true">20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong aria-hidden="true">20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong aria-hidden="true">20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong aria-hidden="true">20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.6.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators</a></li></ol></li></ol>
        </div>

        <div id="page-wrapper" class="page-wrapper has-warning">

            <div class="page">
                <header><p class="warning">You are reading a <strong>draft</strong> of the next edition of TRPL. For more, go <a href="../index.html">here</a>.</p></header>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Iterators - The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>


                <div id="content" class="content">
                    <a class="header" href="#aОбработка-группы-элементов-с-помощью-итераторов" id="aОбработка-группы-элементов-с-помощью-итераторов"><h2>Обработка группы элементов с помощью итераторов</h2></a>
<!-- From reading on, it seems like an iterator is useless without the methods
we use it with --- I think this is an important point to make early, I did find
it difficult to know what an iterator actually was throughout, and how it
depends on these other methods. Can you add something to this effect? -->
<!-- Reiterating the need for a clear definition of an iterator here--it seems
like an item that's used in iteration rather than something that performs the
process of iteration itself, is that right? Like a counter passed from element
to element? Can we define this at the begin of the iterator section? -->
<!-- I've added an explanation along these lines, does this help? /Carol -->
<p>Шаблонное решение &quot;итератор&quot; позволяет вам работать с сгруппированными элементами
по отдельности. В задачу итератора входит последовательное получение доступа к элементам
и определения конца последовательности. При использовании итераторов вы не должны
нарушать (пересоздавать) логику работы этого шаблонного решения.</p>
<p>В Rust итераторы имею особенность - инициализация по запросу (т.е. <em>lazy</em>). Например,
в коде 13-13 создаётся итератор значений вектора <code>v1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
#}</code></pre></pre>
<p><span class="caption">Код 13-13: Создание итератора</span></p>
<p>После создания итератора, мы можем выбрать различные варианты его использования.
В примере 3-6 мы уже использовали итераторы для цикла <code>for</code>. Пример 13-14 подробно
явно показывает порядок работы с итераторов в цикле <code>for</code>. Итератор сохраняется в
переменной <code>v1_iter</code>, а далее цикл последовательно получает значения, которые печатаются
на консоль.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
#}</code></pre></pre>
<p><span class="caption">Код 13-14: использование итератора в цикле <code>for</code></span></p>
<p>В языках программирования, в которых не предоставляется подобное программное решение,
пишутся подобные решения. Производится перебор значений начиная с индекса 0, увеличивая
индекс на единицу и отслеживание текущего индекса и размера группы данных.
Всё это итераторы отслеживает без нашего участия. Итераторы позволяют использовать
логику своей работы при работе с любыми типами данных. Далее рассмотрим как это работает
на примерах.</p>
<a class="header" href="#aТипаж-iterator-и-метод-next" id="aТипаж-iterator-и-метод-next"><h3>Типаж <code>Iterator</code> и метод <code>next</code></h3></a>
<p>Все итераторы реализуют типаж стандартной библиотеки <code>Iterator</code>. Так выглядит
его исходный код:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
#}</code></pre></pre>
<p>Обратите внимание на элементы синтаксиса, которые мы ещё не рассматривали.
<code>type Item</code> и <code>Self::Item</code>, которые определяют <em>ассоциированный тип</em> (<em>associated type</em>)
с этим типажом. Мы подробнее поговорим о них в Главе 19. Сейчас вам нужно знать,
что этот код требует от реализаций этого типажа определить тип <code>Item</code>. Этот тип
используется в методе <code>next</code>. Другими словами, тип <code>Item</code> будет являться типом
элемента, который возвращает итератор.</p>
<p>Метод <code>next</code> необходимо реализовать. Возвращаемое значение находится внутри <code>Some</code>.
Когда перебор элементов завершен, возвращается  <code>None</code>. Мы можем вызвать метод
<code>next</code> непосредственно. Пример 13-15:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Код 13-15: Вызов метода итератора <code>next</code></span></p>
<p>Обратите внимание на необходимость сделать переменную-итератор изменяемой (mut).
Вызовом метода <code>next</code> изменяет состояние итератора. Каждый вызов метода выдаёт следующее
значения последовательности.</p>
<a class="header" href="#aМетоды-типажа-iterator" id="aМетоды-типажа-iterator"><h3>Методы типажа <code>Iterator</code></h3></a>
<!-- Can you explain what it is you mean by "consumes" an iterator here? It
doesn't look like we do in this section, I think that's important to lay that
out clearly -->
<!-- This next paragraph doesn't give much away to me I'm afraid, not being
clear what we mean by *consume* at this point. Is a consuming adaptor like a
catalyst? -->
<!-- I hope this section addresses these comments you had /Carol -->
<p>Типаж <code>Iterator</code> имеет несколько различных методов с реализацией по умолчанию.</p>
<!-- Is there somewhere they can learn about all the methods and what they do,
how to use them? This seems like a good sample example, and if we can broaden
it out that would be really helpful -->
<!-- I've moved this comment here since you made this comment on the last
version of this chapter right after a spot where we mentioned looking at the
standard library API documentation for the iterator trait, like we're now doing
in the above paragraph. That's where the reader should go to learn about
all the methods and what they do and how to use them. Can you elaborate on why
that wasn't clear in the previous version of the chapter? Is there a reason why
the standard library API documentation didn't sound like that place to go?
/Carol -->
<p>Методы, которые вызывают метод <code>next</code> называют пользователя итератора (<em>consuming adaptors</em>).
Пример такого потребителя является метод <code>sum</code>. Этот метод получат владение итератором
и перебирает элементы с помощью метода <code>next</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
#}</code></pre></pre>
<p><span class="caption">Код 13-16: Вызов метода <code>sum</code> для получения суммы всех
элементов вектора</span></p>
<p>Переменную <code>v1_iter</code> после вызова метода <code>sum</code> уже использовать нельзя.</p>
<a class="header" href="#aМетоды-типажа-iterator-для-создания-других-итераторов" id="aМетоды-типажа-iterator-для-создания-других-итераторов"><h3>Методы типажа <code>Iterator</code> для создания других итераторов</h3></a>
<p>Другим типом методов в типаже <code>Iterator</code> являются методы создающие другие итераторы.
Эти методы называют адаптерами (<em>iterator adaptors</em>) и позволяют нам изменять
итераторы в различные типы итераторов. Мы можем использовать цепочки вызовов
таких адаптеров. Т.к. итераторы инициируются по запросу.
Пример использования метода <code>map</code>, который получает в качестве параметра замыкание.
Это замыкание вызывается для каждого элемента. Результатом работы функции будет
новый итератор и измененный вектор.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
#}</code></pre></pre>
<p><span class="caption">Код 13-17: Вызов итератора-адаптера <code>map</code> для создания
нового итератора</span></p>
<p>Предупреждение:</p>
<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and do
nothing unless consumed
 --&gt; src/main.rs:4:1
  |
4 | v1.iter().map(|x| x + 1);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Код программы 13-17 ничего не делает, пока не будет вызвано другим элементом цепочки
вызовов. Об этом сообщается компилятором при вызове этого кода: т.к. адаптеры итераторов
работают только при внешнем использовании.</p>
<p>Для того чтобы исправить код и последовать рекомендациям компилятора, будем использовать
метод <code>collect</code> (который мы кратко представили в Главе 12). Этот метод использует
итератор для группировки результатов работы предыдущего метода в вектор. В примере
кода 13-18 мы группируем результаты работы метода <code>map</code> в вектор, который содержит
все элементы первоначального вектора при этом значение каждого числового элементам
увеличено на 1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
#}</code></pre></pre>
<p><span class="caption">Код 13-18: вызов метода <code>map</code> для создания нового итератора,
далее вызов метода <code>collect</code> для создания и использования нового итератора, чтобы
создать новый вектор с данными</span></p>
<p>Т.к. <code>map</code> получает замыкание мы можем применить любую операцию над содержимым.
Это прекрасный пример того, как использование замыканий позволяет улучшить поведение
итераторов (упростить обработку данных).</p>
<!-- I'm not clear from this last sentence which part is iterating through each
element, iter or map? What is map actually doing?-->
<!--Ah, I'm afraid I completely failed to follow this. What is the second
iterator for? I'm still not clear on what map does, can you expand on this? It
seems crucial to using iterators. Map applies the iterator to each element,
which applies the closure?
<p>Also, to generalize this discussion a bit, would you ever use iter without map?
--&gt;</p>
<!-- I hope this new breakdown/rearranging has cleared up these comments you
had on the last version of this chapter about the difference between
iter and map. I hope the added examples where we've used iter without map have
cleared up the last question. /Carol -->
<a class="header" href="#aИспользование-замыканий-для-получения-доступа-к-переменным-среды-при-работе-итераторов" id="aИспользование-замыканий-для-получения-доступа-к-переменным-среды-при-работе-итераторов"><h3>Использование замыканий для получения доступа к переменным среды при работе итераторов</h3></a>
<p>Продолжим расширение наших знаний об совместном использовании замыканий и итераторов.
Рассмотрим пример использования замыканий для получения доступа к переменным
внешней среды и использования адаптера итераторов <code>filter</code>. Этот метод получает в
качестве параметра замыкание, применяет замыкание к каждому элементу и возвращается
булево значение. Если в результае работы кода замыкание возвращается значение <code>false</code>,
то данный элемент игнорируется при создание нового итератора. Код 13-19 демонстрирует
использование <code>filter</code> и замыкания, которое получает доступ к переменной <code>shoe_size</code>
при обрадотки коллекции данных структур <code>Shoe</code> для того, чтобы выбрать только те,
которые подходят под определенный размер:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: i32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: i32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
#}</code></pre></pre>
<p><span class="caption">Код 13-19: использование метода <code>filter</code>, замыкания и переменной
функции <code>shoe_size</code></span></p>
<!-- Will add wingdings in libreoffice /Carol -->
<p>Функция <code>shoes_in_my_size</code> получает во владение вектор структур данных и числовое
значение. Данная функция возвращает вектор содержащий только структуры подходящие
под определенные критерии (в данном случае описания обуви определенного размера).
В теле функции мы вызываем метод <code>into_iter</code> для создания итератора, который получит
владение вектором. Далее вызываем метод <code>filter</code>, который применит к каждому элементу
вектора замыкание. Данное замыкание возвращает логическое значение результат сравнения
поля структуры с аргументом функции. В результате, метод <code>collect</code> объединит полученные
данные в вектор, который будет возвращен функцией в качестве выходных данных.</p>
<p>Тест наглядно демонстрирует результат работы функции.</p>
<a class="header" href="#aРеализация-типажа-iterator-для-создания-нового-итератора" id="aРеализация-типажа-iterator-для-создания-нового-итератора"><h3>Реализация типажа <code>Iterator</code> для создания нового итератора</h3></a>
<!-- So it seems like we are creating a program with an iterator inside, is
that right? I assumed the whole thing we were making was an iterator at first,
which lead to a few confusions, can you lay it out up front? -->
<!-- I'm not sure what you mean here, can you elaborate on what the distinction
is to you between "a program with an iterator inside" and "whole thing we were
making was an iterator"? I don't understand what you mean by these terms so I'm
not sure how to clear this up. /Carol -->
<p>Вы уже видели в примерах, как можно создать итератор вектора (с помощью вызовов
функций <code>iter</code>, <code>into_iter</code> или <code>iter_mut</code>). Мы также можем создать итераторы из
других типов коллекций стандартной библиотеки (например, <code>map</code>). Помимо этого мы
можем реализовать <code>Iterator</code> для обработки любых данных. Для этого необходимо
реализовать метод <code>next</code>. После этого мы можем использовать все методы типажа
<code>Iterator</code> (используя реализации самого типажа).</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Реализуемый нами итератор будет считать от одного до пяти. Для начала создадим
структуры для хранения значений. Далее напишем реализацию типажа <code>Iterator</code></p>
<p>В коде 13-20 определение структуры <code>Counter</code> и реализации функции <code>new</code> для
создания экземпляра структуры <code>Counter</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 13-20: определения структуры <code>Counter</code> и функции <code>new</code>,
которая создаёт экземпляр структуры <code>Counter</code> с инициализированным значением <code>0</code> поля
<code>count</code></span></p>
<!-- Could you add a filename here? I think that will help the reader keep
track of what they're working on. Can you also just sum up in a line what this
code has accomplished so far? I moved this down from above the code, if this
will do? -->
<!-- Done /Carol -->
<!-- Why define the new method, if it isn't necessary? Or is that what this
next line is telling us? -->
<!-- So does this code just initialize it with 0? Is that jat { count: 0 }
does?-->
<!-- I've rearranged to make this clearer /Carol -->
<p>Далее мы реализуем метод <code>next</code> (код 13-21):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 13-21: реализация типажа <code>Iterator</code> в структуре <code>Counter</code></span></p>
<!-- I will add wingdings in libreoffice /Carol -->
<p>Рассмотрим содержание кода реализации типажа подробнее. Мы установили тип <code>Item</code>
(тип выходных данных метода <code>next</code>) <code>u32</code>. Более подробно о ассоциированных типах
мы поговорим в Главе 19. Обратим теперь внимание на содержание реализации метода.
Мы хотим чтобы наш итератор добавлял единицу к текущему значению. Поэтому мы инициировали
поле <code>count</code> 0. Если значение этого поля меньше 6, функция <code>next</code> возвращает текущее
значение внутри <code>Some</code>. Если же это поле равно 6 или больше итератор вернёт <code>None</code>.</p>
<a class="header" href="#aПример-использования-итератора-counter" id="aПример-использования-итератора-counter"><h4>Пример использования итератора <code>Counter</code></h4></a>
<p>После того как метод <code>next</code> реализован, т.е. соблюдены все ограничения типажа
<code>Iterator</code> - мы получили реализацию итератора. Код 13-22 демонстрирует проверку
работы нашей реализации:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Iterator for Counter {
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         self.count += 1;
#
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Код 13-22: тестирования реализации метода <code>next</code></span></p>
<p>В этом тесте создаётся экземпляр структуры <code>Counter</code> - переменная <code>counter</code>.
Далее вызывается метод <code>next</code> и проверяется его выходные данные. Как и предполагалось,
метод возвращает числа от 1 до 5, а при последующих вызовах возвращает <code>None</code>.</p>
<!-- So if I have this right, the first line creates a new Counter called
counter, and the rest of them merely call counter with next, store it in x, and
then print x? And we have to do that 5 times to get the 1-5 count? Phew, could
you wrap that up if indeed it is correct!) and sum up here? -->
<!-- I decided to change this into a test rather than printing out values, and
I added some summary text about what the test is doing. Is this clearer? /Carol
-->
<a class="header" href="#aИспользование-других-методов-типажа-iterator" id="aИспользование-других-методов-типажа-iterator"><h4>Использование других методов типажа <code>Iterator</code></h4></a>
<p>Т.к. мы реализовали типаж <code>Iterator</code>, мы можем использовать все его доступные
методы.</p>
<!-- So we can't just use these methods anyway? It seems like we did earlier,
but here we have to use next first, before we cam access these methods? -->
<!-- No, we don't have to *use* `next` before we can use the other methods, we
have to *define* `next` before we can use the other methods. I hope the various
rewordings and reworkings have made this clearer by this point. /Carol -->
<!-- below: once you've done what, defined a default implementation? Only then
can you use other adapters, is that what we're saying? And I'm still not clear
on what an adapter does/means, as opposed to a method, or consumer, at this
point. -->
<!-- I hope this comment has been cleared up too /Carol -->
<p>Пример использования методов типажа, доступных её реализации (13-23):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Counter {
#     fn new() -&gt; Counter {
#         Counter { count: 0 }
#     }
# }
#
# impl Iterator for Counter {
#     // Our iterator will produce u32s
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         // increment our count. This is why we started at zero.
#         self.count += 1;
#
#         // check to see if we've finished counting or not.
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-23: Использование множества методов типажа <code>Iterator</code>
</span></p>
<p>Вызов всех методов доступен, т.к. были соблюдены все формальные условия реализации
типажа <code>Iterator</code>.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch13-01-closures.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch13-03-improving-our-io-project.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch13-01-closures.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch13-03-improving-our-io-project.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="store.js"></script>
        <script src="book.js"></script>
    </body>
</html>
