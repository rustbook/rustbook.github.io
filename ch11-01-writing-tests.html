<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing tests - The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html" class="active"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong aria-hidden="true">20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong aria-hidden="true">20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong aria-hidden="true">20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong aria-hidden="true">20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.6.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch11-01-writing-tests.html#aКак-писать-тесты" id="aКак-писать-тесты"><h2>Как писать тесты</h2></a>
<p>Тесты в Rust - это функции специального вида, которые проверяют работу отдельных
частей программы. Тело функции-теста состоит из нескольких частей: установки входных
данных, тестирования исследуемой функции на ожидаемое поведение. Далее, будут рассмотрен
состав возможностей, который предлагается в Rust для этого: атрибуты, макросы, и
специальный атрибут <code>should_panic</code>.</p>
<a class="header" href="ch11-01-writing-tests.html#aСтруктура-функции-теста" id="aСтруктура-функции-теста"><h3>Структура функции-теста</h3></a>
<p>Простейшая функция-тест - это функция аннотируемая атрибутом <code>test</code>. Атрибуты -
это метаданные (мы их уже встречали в примерах кода (Глава 5)). Чтобы функция превратилась
в тест для этого необходимо добавить <code>#[test]</code> перед ключевым словом <code>fn</code>.
Далее, с помощью команды <code>cargo test</code> будут выполнены тесты и в строках вывода
будут информационные сообщения о ходе проведения тестирования.</p>
<p>При создании библиотеки кода в Главе 7 мы обращали внимание на то, что создаётся
специальный модуль и тестовая функция. Этот код создаётся для ускорения написания
тестов. Далее, мы можем добавить необходимое количество тестовых функций в наш проект.</p>
<p>Мы рассмотрим аспекты работы шаблонных тестов, а потом напишем тесты, которые
будут проверять корректность поведения написанного нами кода.</p>
<p>Создадим проект <code>adder</code>:</p>
<pre><code class="language-text">$ cargo new adder
     Created library `adder` project
$ cd adder
</code></pre>
<p>Содержание файла <code>src/lib.rs</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p><span class="caption">Пример кода 11-1: Тестовый модуль и функция генерируемая при
создании проекта библиотеки кода с помощью команды <code>cargo new</code></span></p>
<p>Сейчас проигнорируем первый две строчки кода и сфокусируемся на функции для того,
чтобы увидеть её работу. Обратите внимание на синтаксис описания <code>#[test]</code> перед
ключевым словом <code>fn</code>. Это атрибут сообщает компилятору, что далее будет заголовок
функции-теста. Функционал запускающий тесты на выполнение теперь знает, что это
особая функция - функция-тест. Также в составе модуля-тестов у нас могут бы вспомогательные
функции, не являющиеся тестами. Поэтому специальная аннотация (описание) так важна
для явного объявления функций - тестами.</p>
<p>Пока, функция не имеет содержания, что означает, что нет кода, который мог бы повлиять
на работу теста. Такой тест считается корректным.</p>
<p>Команда <code>cargo test</code> выполнить все тесты в выбранном проекте и сообщит о результатах 11-2:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><span class="caption">Результат работы программы 11-2: Вывод информации о работе
тестов</span></p>
<p>Cargo скомпилировал и выполнил тест. После строк <code>Compiling</code>, <code>Finished</code> и
<code>Running</code> мы видим строку <code>running 1 test</code>. Следующая строка показывает имя функции-теста.
Её имя  <code>it_works</code>. Результат её работы - <code>ok</code>. Далее вы видите обобщенную информации
о работе всех тестов: <code>test result: ok.</code> Это означает, что все тесты пройдены успешно.</p>
<p>Мы не должны отмечать тесты быть игнорированы, поэтому написано <code>0 ignored</code>.
Мы поговорим об игнорировании тестов в следующей секции.<code>0 measured</code> - это информация
об измерения производительности.</p>
<p>Следующая часть информации <code>Doc-tests adder</code> - это информация о тестировании документации.
У нас пока нет тестов документации, но Rust может компилировать любые примеры кодов,
которые находятся в API документации. Такая возможность помогает поддерживать документацию
в актуальном состоянии. Мы поговорим о тестировании документации в Главе 14. Пока
просто не будем обращать на эту информацию нашего внимания.</p>
<p>Давайте поменяем название нашего теста и посмотрим что же измениться в строке вывода.
Назовём нашу функцию <code>it_works</code> другим именем - <code>exploration</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
    }
}
#}</code></pre></pre>
<p>Снова выполним команду <code>cargo test</code>. В строке вывода мы увидим новое наименование
нашей функции-теста - <code>exploration</code> вместо <code>it_works</code>:</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Отлично! Добавим ещё один тест. Сделаем так, чтобы этот наш новый тест не срабатывал
специально. Используем для этого уже известный на макрос <em>panics</em>. Хочу обратить
ваше внимание на то, что каждый тест выполняет в новом потоке. Поэтому когда главный
поток выполнения тестов видит, что какой-либо тест не срабатывает - этот тест отмечается
как непройденный. Мы поговорим об особенностях использования макроса <em>panic</em> в Главе 9.
После написания нового тесты код будет выглядеть так (11-3):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">Описание 11-3: Добавление второго теста. Второй тест вызывает
макрос <code>panic!</code></span></p>
<p>Запустим команду <code>cargo test</code>. Вывод результатов 11-4, которое сообщает, что тест
<code>exploration</code> пройден, а <code>another</code> нет:</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured

error: test failed
</code></pre>
<p><span class="caption">Описание 11-4: Описание результаты выполнения тестов</span></p>
<p>Вместо <code>ok</code>, строка <code>test tests::another</code> сообщает <code>FAILED</code>. У нас есть две новых
секции между результатами и итогами. Первая секция показывает детальную причину
ошибки теста. В данном случае тест <code>another</code> не сработал, т.к.  <code>panicked at 'Make this test fail'</code>,
в строке 9 файла <em>src/lib.rs</em>. В следующей секции находятся имена всех непройденных тестов.
Это удобно, когда тестов очень много. Мы можем использовать имя непройденного
теста для отладки. Это обсудим в следующей секции.</p>
<p>Далее следуют итоговые данные. У нас один тест пройден, а 1 непройден.</p>
<p>Теперь мы знаем как выглядят описания при различных ситуациях работы системы тестирования
в Rust. Далее мы расширим наши знания о тестировании и познакомимся с макросами для
тестирования.</p>
<a class="header" href="ch11-01-writing-tests.html#aПроверка-результатов-с-помощью-макроса-assert" id="aПроверка-результатов-с-помощью-макроса-assert"><h3>Проверка результатов с помощью макроса <code>assert!</code></h3></a>
<p>Макрос <code>assert!</code> доступен в стандартной библиотеке. Он удобен, когда вы хотите проверить
какое-либо условие. Внутри входных данных данного макроса вычисляет логическое
значение. Если результат <code>true</code>, <code>assert!</code> ничего не делает и тест считается пройденным.
Если же значение входного параметра макроса <code>assert!</code> <code>false</code> вызывается макрос
<code>panic!</code> и данный тест считается непройденным.</p>
<p>Вспомним пример кода из Главы 5 (5-9), где у нас была структура <code>Rectangle</code>
и метод <code>can_hold</code>. Повторим здесь код примера. Добавим код примера в файл <em>src/lib.rs</em>
и напишем тесты используя макрос <code>assert!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 11-5: Структура <code>Rectangle</code> и его метод <code>can_hold</code></span></p>
<p>Метод <code>can_hold</code> возвращает булево (логическое) значение. Такой метод удобен для
тестирование. Сейчас напишим тест (11-6), который будет проверять результат работы
метода <code>can_hold</code> экземпляра структуры <code>Rectangle</code>. С помощью теста проверим может
ли прямоугольник шириной 8 и длинной 7 содержать прямоугольник другого размера
(длинной 5 и шириной 1):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
#}</code></pre></pre>
<p><span class="caption">Пример кода 11-6: Код теста для метода структуры Rectangle
<code>can_hold</code>, который проверяет корректность его работы</span></p>
<p>Если вы пишите тесты, которые мы описываем в один и тот же проект и файл, вы, наверное,
обратили внимание на работу с модулями. Описание модуля - это иерархическая синтаксическая
конструкция, которые может быть только в одном экземпляре в тексте программы.
Не может быть несколько объявлений модуля <em>tests</em> в файле тестируемой библиотеки.</p>
<p>Также обратите внимание на сроку кода <code>use super::*;</code>. Модуль <code>tests</code> подчиняется
тем же правилам видимости, что и все остальные модули (всё то, что мы обсуждали
в Главе 7). Т.к. этот модуль внутренний, ему нужно дать доступ на верхний уровень,
чтобы можно было бы создать экземпляр структуры и вызвать его метод (или получить
доступ к чему-либо ещё на этом уровне).</p>
<p>Обратите на реализацию нашего нового теста. Его название <code>larger_can_hold_smaller</code>.
В теле теста мы создаём два экземпляра структуры <code>Rectangle</code>. Далее, мы вызываем
метод из одно из экземпляров (в данном случае из переменной <code>larger</code>) и передаём в
метод ссылку  на вторую переменную <code>larger.can_hold(&amp;smaller)</code>. Это выражение мы
помещаем, как аргумент в макрос <code>assert!</code>. Т.к. метод возвращает логическое значение,
а макрос <code>assert!</code> принимает в качестве аргумента логическое значение, синтаксически
всё верно. Далее проверяем работу теста.</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Всё в порядке. Тест пройдёт. Теперь проверим, сообщит ли макрос об ошибке, если
мы попытаемся поместить большой прямоугольник в маленький:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
#}</code></pre></pre>
<p>Т.к. правильный входной параметр данного макроса должен возвращать отрицательное значение,
с помощью логического &quot;не&quot; (<em>!</em>) мы корректно организовали проверку:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Отлично! Тесты работают. Теперь проверим, как отреагируют тесты, если мы добавим
ошибку в код метода <code>can_hold</code> - изменим знак сравнения в одной из логических выражений
на противоположное:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p>Строки вывода:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Наши тесты нашли ошибки! В тесте  <code>larger.length</code> равно 8 и <code>smaller.length</code> равно 5.
Выражения сравнения в методе <code>can_hold</code> дают результат <code>false</code>, т.к. 8 больше 5.</p>
<a class="header" href="ch11-01-writing-tests.html#aПроверка-на-равенство-с-помощью-макросов-assert_eq-и-assert_ne" id="aПроверка-на-равенство-с-помощью-макросов-assert_eq-и-assert_ne"><h3>Проверка на равенство с помощью макросов <code>assert_eq!</code> и <code>assert_ne!</code></h3></a>
<p>Весьма часто для проверки работы методов и функций используется сравнение выходного
результата и предполагаемого значения. Для этого мы можем использовать макрос <code>assert!</code>
и оператор <code>==</code>. Важно также знать, что кроме этого макроса стандартная библиотека
предлагает использовать макросы <code>assert_eq!</code> и <code>assert_ne!</code>. Использование этих
макросов повышает читабельность кода. Кроме собственно проверки на равенство,
эти макросы также печатают значения входных параметров, если тест завершился ошибкой.
Эти макросы также более информативны, чем предыдущий, т.к. мы увидим ошибочные
входные данные.</p>
<p>В примере кода 11-7, мы создадим функции <code>add_two</code>, которая прибавляет к входному
параметру 2 и возвращает значение. Then let’s test this function using the
<code>assert_eq!</code> macro:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 11-7: Тестирование функции <code>add_two</code> используя макрос
<code>assert_eq!</code> macro</span></p>
<p>Проверим! Запустим тесты снова.</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Всё в порядке. Функция работает как и предполагалось.</p>
<p>Теперь проверим, как будет выявлена ошибка. Изменим реализацию функции <code>add_two</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
#}</code></pre></pre>
<p>Попробуем выполнить данный тест ещё раз:</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
    thread 'tests::it_adds_two' panicked at 'assertion failed: `(left ==
    right)` (left: `4`, right: `5`)', src/lib.rs:11
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Наш тест нашел ошибку. Мест <code>it_adds_two</code> не сработал и сообщил важную информацию
для начала поиска ошибки в коде программы.</p>
<p>Обратите внимание, что в некоторых языках (таких как Java) в библиотеках кода
для тестирования принято именовать входные параметры проверочных функций &quot;предполагаемое&quot;
(<code>expected</code>) и &quot;фактическое&quot; (<code>actual</code>). В Rust приняты следующие обозначения
<code>left</code> и <code>right</code>, соответственно. Кроме того макросам тестирования совершенно не важно,
где находится предполагаемое (слева или справа), а где фактическое. Информационные
сообщения будут достаточно информативны:
<code>assertion failed: `(left == right)` (left: `5`, right: `4`)</code>.</p>
<p>Макрос <code>assert_ne!</code> сработает успешно, если входные параметры не равны друг другу.
Этот макрос будет полезен в тех случаях, когда вы не знаете, какое точно может быть
значение, то знаете точно, каким оно быть не может. К примеру, если у вас есть
функция, которая изменяет входные данные определённым образом. Лучший способ проверить
правильность работы такой функции - сравнить входное и выходное значения. Они не
должны быть равными.</p>
<p>С своей работе макросы <code>assert_eq!</code> и <code>assert_ne!</code> неявным образом используют
операторы <code>==</code> и <code>!=</code>. Когда тест не сработает, макросы напечатают значения аргументов
с помощь отладочного форматирования (что в свою очередь значит, что значения аргументов
должны реализовать типажи <code>PartialEq</code> и <code>Debug</code>). Все примитивные типы стандартной
библиотеки Rust реализовали эти типажи. Для структур и перечислений, которые вы
сами реализуете вы должны реализовать типаж <code>PartialEq</code> для сравнения значений.
Для печати отладочной информации в виде сообщений в строку вывода консоли необходимо
реализовать типаж <code>Debug</code>. Эти типажи можно реализовать добавив аннотацию
<code>#[derive(PartialEq, Debug)]</code>на определение структуры или перечисления.</p>
<a class="header" href="ch11-01-writing-tests.html#aСоздание-сообщений-об-ошибках" id="aСоздание-сообщений-об-ошибках"><h3>Создание сообщений об ошибках</h3></a>
<p>Продолжим изучать работу с макросами для тестирования. Конечно, было бы удобно,
если была бы возможность добавить дополнительную информацию при выводе ошибки.
И такая возможность есть. Это опциональный текстовый аргумент, которые обрабатывается
макросом <code>format!</code>. Такие сообщения удобны для более детального раскрытия информации
о состоянии теста, ожидаемых результатах, возможных причинах ошибки и способах её
устранения.</p>
<p>Например, создадим функцию, которая приветствует человека по имени. Протестируем
эту функцию. Мы хотим чтобы вводимое имя выводилось на консоль:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
#}</code></pre></pre>
<p>Теперь внесём ошибку в функцию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
#}</code></pre></pre>
<p>Running this test produces:</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'assertion failed:
    result.contains(&quot;Carol&quot;)', src/lib.rs:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>Сообщение содержит лишь информацию о том что сравнение не было успешным. Сообщение
было бы более информативным, если бы выводило также выходные данные. Изменим
тестовую функцию для того, чтобы выводились форматированное сообщение:</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>После того, как выполним тест ещё раз мы получим подробное ожидаемое сообщение:</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'Greeting did not contain
    name, value was `Hello`', src/lib.rs:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Это сообщение поможет нам в отладке (получим то, что есть, вместо того что должно быть).</p>
<a class="header" href="ch11-01-writing-tests.html#aПроверка-с-помощью-макроса-should_panic" id="aПроверка-с-помощью-макроса-should_panic"><h3>Проверка с помощью макроса <code>should_panic</code></h3></a>
<p>Кроме проверок выходных данных также важно, проверить условия при которых могу быть
ошибки. Например, рассмотрим инициализацию структуры <code>Guess</code>, которую мы создали в
Главе 9 (9-8). При создании экземпляра структуры проверяется входной параметр (он
должен быть между 1 и 100). Мы можем написать тест, который проверит реакцию кода
инициализации на неправильные входные данные.</p>
<p>Реализуем это с помощью атрибута функции теста <code>#[should_panic]</code>. Этот атрибут
сообщает системе тестирования, что этот метод должен генерировать ошибку. Если ошибка
не генерируется - тест считается непройденым.</p>
<p>Код программы 11-8 показывает, как надо написать такой тест:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 11-8: Тестирование генерации <code>panic!</code></span></p>
<p>Атрибут <code>#[should_panic]</code> следует после <code>#[test]</code> и до объявления текстовой функции.
Строка вывода может выглядеть следующим образом:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Отлично! Теперь внесём ошибку:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Guess {
#     value: u32,
# }
#
impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
#}</code></pre></pre>
<p>Вид обновлённой строки вывода:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Обратите внимание, что сообщение не очень информативное.
Мы можем улучшить взаимодействие с атрибутом <code>should_panic</code> добавив параметр - ожидаемую
подстрку выводимого при генерации ошибки сообщения:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 11-9: Тестирования случая вызова макроса
<code>panic!</code> содержащего предполагаемую ошибку</span></p>
<p>Этот тест сработает, т.к. соблюдены все условия.</p>
<p>Изменим код (внесём ошибку и посмотрим на результат):</p>
<pre><code class="language-rust ignore">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>Ошибка:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
    thread 'tests::greater_than_100' panicked at 'Guess value must be greater
    than or equal to 1, got 200.', src/lib.rs:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Эта ошибка говорит нам о том, что параметр атрибута не содержиться в генерируемом
макросом <code>panic!</code> сообщении. Также приводится тестовый параметр атрибута <code>should_panic</code>,
что, возможно, поможет найти ошибку в коде.</p>
<p>Теперь, когда вы научились писать тесты, в следующей секции мы приступим к детальной
настройке запуска тестов с помощью команды <code>cargo test</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
