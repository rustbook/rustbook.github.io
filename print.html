<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> Points to Data on the Heap and Has a Known Size</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="ch19-02-advanced-lifetimes.html"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="ch20-02-slow-requests.html"><strong aria-hidden="true">20.2.</strong> How Slow Requests Affect Throughput</a></li><li><a href="ch20-03-designing-the-interface.html"><strong aria-hidden="true">20.3.</strong> Designing the Thread Pool Interface</a></li><li><a href="ch20-04-storing-threads.html"><strong aria-hidden="true">20.4.</strong> Creating the Thread Pool and Storing Threads</a></li><li><a href="ch20-05-sending-requests-via-channels.html"><strong aria-hidden="true">20.5.</strong> Sending Requests to Threads Via Channels</a></li><li><a href="ch20-06-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.6.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#aВведение" id="aВведение"><h1>Введение</h1></a>
<p>Добро пожаловать! Это книга о языке программирования Rust.
Rust - это язык программирования, с помощью которого можно создать безопасные,
быстрые и многопоточные приложения. Безопасность, скорость и многопоточность —
это три кита, вашего Rust-приложения. Семантический дизайн языка позволяет создавать
программы, объединяющие воедино высокую производительность, контроль над используемыми
ресурсами и абстракции высокого уровня. Rust объединяет в себе черты низкоуровневых
и высокоуровневых языков программирования. Системные программисты по достоинству
оценят безопасность языковых конструкций, а прикладные программисты получат возможность
создавать производительные решения. Код программ читается свободно, поэтому писать
на нём удобно.</p>
<p>Компилятор производит работу по статическому анализу кода, оптимизации использования
ресурсов. Это позволяет повысить производительность работы программ и заранее
оптимизировать объём используемыех системных ресурсов. Благодаря этим особенностям
Rust — это удобный инструмент для создания решений в следующих прикладных областях:
приложения с предопределёнными жёсткими квотами ресурсов - кодеки, драйверы устройств,
драйверы баз данных и даже встроенные системы. Rust весьма удобен для создания
веб-приложений. Менеджер пакетов <a href="https://crates.io/">crates.io</a> позволяет создавать высоконагруженные
решения без неизбежных расходов многослойных, высокоуровневых альтернатив. Просто
отпустите Вашу фантазию в полёт и создавайте приложения!</p>
<p>Эта книга будет полезна программистам, которые уже имеют теоретическую подготовку и
практический опыт в программировании. Очень даже возможно, что после внимательного
прочтения этой книги, написания и отладки кода, понимания основных шаблонов проектирования,
обретения навыков комфортной работы с языковыми конструкциями Вы полюбите писать
на Rust. Небольшие учебные примеры научат использовать потенциал Rust. Также Вы
научитесь пользоваться инструментальными средствами — дополнительными программами
и технологиями, благодаря которым продуктивность работы будет увеличиваться.</p>
<a class="header" href="print.html#aДоработка-книги" id="aДоработка-книги"><h2>Доработка книги</h2></a>
<p>Если вы найдете ошибку, неточность, пожалуйста внесите испраление с помощью возможностей
<a href="https://github.com/rust-lang/book">GitHub</a>. <a href="https://github.com/rust-lang/book/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> — этом файл, в котром описаны основные правила
внесения изменений.</p>
<a class="header" href="print.html#aУстановка" id="aУстановка"><h2>Установка</h2></a>
<p>Для использвания языка программирования Rust необходимо установить все необходимые
программные компоненты. Вам будет необходимо скачать их, а также выполнить
дополтельные установки.</p>
<p>Мы покажим, как с помощью командной строки. Начало любой команды будет обозначаться
символом-индикатором <code>$</code>. Строки без такого символа будут обозначать результат
работы команды.</p>
<a class="header" href="print.html#aУстановка-на-linux-или-mac" id="aУстановка-на-linux-или-mac"><h3>Установка на Linux или Mac</h3></a>
<p>Если вы используете Linux или Mac, пожалуйста, выполните следующую команду:</p>
<pre><code class="language-shell">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Благодаря этой команде будет запущена инсталляция Rust. Возможно, понадобиться
ввести пароль пользователя. Если все компоненты будут благополучно установлены,
Вы увидите следующее сообщение:</p>
<pre><code class="language-shell">Rust is installed now. Great!
</code></pre>
<p>Вы также можете просто скачать код инсталлятора без его выполнения</p>
<pre><code class="language-shell">$ curl https://sh.rustup.rs
</code></pre>
<p>т.е. выполнить команду без запуска инсталляции и выполнить её в любое удобное время.</p>
<p>Инсталлятор автоматически добавить папку с компонентами Rust в системный путь PATH
и их использование будет доступно из командной строки после следующего входа в
систему. Если необходимо сразу начать работу, пожалуйста, выполните следующую команду:</p>
<pre><code class="language-shell">$ source $HOME/.cargo/env
</code></pre>
<p>Или добавьте следующую строку в файл <code>~/.bash_profile</code>:</p>
<pre><code class="language-shell">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<a class="header" href="print.html#aУстановка-на-windows" id="aУстановка-на-windows"><h3>Установка на Windows</h3></a>
<p>Перейдите по ссылке <a href="https://rustup.rs/">https://rustup.rs</a><!-- ignore --> и
следуйте иструкциям исталлятора.</p>
<p>Авторы учебника предполагают, что Вы используете программу <code>cmd</code> для выполнения
описываемых команд. Если используется другая программа, возможно, имеется возможность
использовать команды для Linux и Mac. Если нет, пожалуйста, обратитесь к документации
по использованию программы, который Вы пользуетесь.</p>
<a class="header" href="print.html#aУстановка-rust-вручную" id="aУстановка-rust-вручную"><h3>Установка Rust вручную</h3></a>
<p>Если Вы по каким-то причинам не используете rustup.rs, пожалуйста, ознакомьтесь с
документацией на с странице <a href="https://www.rust-lang.org/install.html">the Rust installation page</a>.</p>
<a class="header" href="print.html#aОбновление" id="aОбновление"><h3>Обновление</h3></a>
<p>После установки Rust обновление выполняется с помощью следующей команды:</p>
<pre><code class="language-shell">$ rustup update
</code></pre>
<a class="header" href="print.html#aУдаление-компонентов-rust-из-Вашей-системы" id="aУдаление-компонентов-rust-из-Вашей-системы"><h3>Удаление компонентов Rust из Вашей системы</h3></a>
<p>Удалить Rust также просто, как его установить. Для этого необходим выполнить
следующую команду:</p>
<pre><code class="language-shell">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#aУстранение-возможных-ошибок" id="aУстранение-возможных-ошибок"><h3>Устранение возможных ошибок</h3></a>
<p>Проверка работы Rust-компилятора:</p>
<pre><code class="language-shell">$ rustc --version
</code></pre>
<p>Если Вы увидите версию компилятора, хэш-строку, дату обновления:</p>
<pre><code class="language-shell">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Если Вы видите всё это - то Rust установлен успешно. Поздравляем!</p>
<p>Если этого не произошло, проверьте содержание системной переменной <code>PATH</code>.</p>
<p>Если проблема всё ещё не может быть устранена, вот сайты, на страницах которых Вы
сможете найти ответ или задать вопрос <a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a>.<!-- ignore -->,
Доступ к данному ресурсу осуществляется с помощь <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Перейдите по
ссылке и Вы получите возможность задать Ваш вопрос в чате. Также обратить на форум
<a href="https://users.rust-lang.org/">the Users forum</a> или на <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<a class="header" href="print.html#aСправочная-информация" id="aСправочная-информация"><h3>Справочная информация</h3></a>
<p>Один из устанавливаемых компонентов Rust - копия документации. Для её использования
нет необходимости доступа в Интернет. Команда <code>rustup doc</code> откроет локальную версию
сайта с документацией в Вашем браузере.</p>
<p>Если Вам необходимо найти описание функционала стандартной библиотеки или
вы не знаете как использовать тот или иной объект - документация станет вашим
верным помощником!</p>
<a class="header" href="print.html#hello-world" id="hello-world"><h2>Hello, World!</h2></a>
<p>Итак, когда Rust уже установлен можно приступать к написанию вашей первой программы.
<a href="https://ru.wikipedia.org/wiki/Hello,_world!">По традиции</a>, (а точнее с 1978 года, когда вышла в свет первое издания <a href="https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0)">книги о Си</a>)
напишем небольшую программу, которая напечатает &quot;Привет, Мир!&quot; в строке вывода.</p>
<blockquote>
<p>Обратите внимание, что читатели должны быть знакомы с использованием командной
строки. Язык Rust не требует каких-то специальных настроек редакторов исходного
кода, настройкам инструментальных средств. IDE экономят время и если ещё дают
возможность тонкой настройки параметров запуска утилит - это замечательно. Как
бы там ни было, программист должен знать и уметь пользоваться командной строкой
и мы этому научим.</p>
</blockquote>
<a class="header" href="print.html#aСоздание-папки-проекта" id="aСоздание-папки-проекта"><h3>Создание папки проекта</h3></a>
<p>Первым делом создадим папку для хранения исходных кодов Rust. Это, конечно, не
обязательное условие для программировании на Rust, но для удобства нашей работы
это будут лучшим решением.</p>
<blockquote>
<p>Т.к. работа в командной строке Linux и Mac идентичны, предлагаю, для краткости,
писать Unix, когда мы будем описывать работу в терминале Linux и Mac.</p>
</blockquote>
<p>Итак, приступим. Создадим папку <em>projects</em> и далее будем создавать проекты Rust
в этой директории. Для этого откроем программу-терминал и введём следующие команды:</p>
<p>Unix:</p>
<pre><code class="language-shell">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projects
&gt; cd %USERPROFILE%\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projects
&gt; cd $env:USERPROFILE\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<a class="header" href="print.html#aНаписание-и-запуск-первой-программы" id="aНаписание-и-запуск-первой-программы"><h3>Написание и запуск первой программы</h3></a>
<p>Далее, создадим текстовый файл и назовём его <em>main.rs</em>.</p>
<blockquote>
<p>Все файлы исходного кода Rust имеют расширение <em>.rs</em> (ещё одна конвенция
упрощающая программирование).
Рекомендуем использовать символ подчёркивания, для разделения слова в многословных
названиях. Во-первых, такие названия легче читать, а во-вторых, это упрощает
работу утилит. Пример: <em>i_like_hello_world.rs</em>.</p>
</blockquote>
<p>Теперь откроем файл<em>main.rs</em> для редактирования и введём следующие сроки кода:</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, Rust world! Привет, Мир!&quot;);
}
</code></pre></pre>
<p>Сохраним файл и вернёмся в окно терминала. Введём следующие (две) команды:</p>
<p>Unix:</p>
<pre><code class="language-shell">$ rustc main.rs # нажмите клавишу Enter
$ ./main # нажмите клавишу Enter
Hello, Rust world! Привет, Мир!
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; rustc main.rs # нажмите клавишу Enter
&gt; main
Hello, Rust world! Привет, Мир!
</code></pre>
<p>Обратите внимание на отличия в запуске приложений в строке терминала Unix и Windows.
Если всё будет в порядке (вы не сделаете опечаток, не будет проблем в кодировках,
шрифтах или ещё с чем-нибудь ещё (&quot;не удаётся найти указанный файл&quot;, &quot;stream
did not contain valid UTF-8&quot;, ..)) - будет напечатана строка <code>Hello, Rust world! Привет, Мир!</code>.
Поздравляю! Вы написали первую программу на Rust! Добро пожаловать в увлекательное
путешествие в мир Rust! :-)</p>
<blockquote>
<p>Если вам уже понравилось писать на Rust, создайте файл <em>hello_world.rs</em> введите
тот же код и проверьте его работу. Далее создайте <em>i_like_hello_world.rs</em> и
проделайте тоже самое. Если программы будут работать корректно - будет печататься
тот же текст - вы закрепите свои первые навыки и почувствуете уверенность.
Желаю успеха!</p>
</blockquote>
<a class="header" href="print.html#aКак-это-работает" id="aКак-это-работает"><h3>Как это работает</h3></a>
<p>Теперь, давайте разберёмся, как же работает ваша новая &quot;Hello Rust world!&quot;-программа.
Первое, разберем исходный код:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Этот текст определяет <em>Rust-функцию</em>. Функция <code>main</code> - особенная. Это т.н. точка
входа в программу (если читатель уже знаком с C, C++, Java, то тут тоже самое).
<code>main</code> - начало всех начал вашей программы. Т.е. это текс значит следующее:
&quot;Объявление функции с именем <code>main</code>, у которой нет ни параметров и она ничего не
возвращает во внешнюю среду.&quot; Если же у неё были бы параметры, они были бы заключены
в круглые скобки <code>(</code> <code>)</code>.</p>
<p>Также обратите внимание, что содержание кода функции обрамляется фигурными скобками.
<code>{</code> <code>}</code> (также как и в Си, С++, Java, Go). Эти скобки обязательны для описания
Rust-функций. Для повышения читаемости кода рекомендуем размещать открывающуюся
фигурную скобку <code>{</code> на той же строке, что и наименовании функции и описание её
параметров и отделять её одним пробелом. Вот так: <code>fn main() {</code>.</p>
<p>Содержание функции <code>main</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, Rust world! Привет, Мир!&quot;);
#}</code></pre></pre>
<p>Эта строчка кода описывает все действия программы: печать текста в терминальной
строке. Есть определённые стилистические уточнения. Первое, в стиле написания кода
на Rust используется четыре пробела вместо символа табуляции.</p>
<p>Второе, это <code>println!</code> (называется Rust макрос). Таким образом в Rust реализуется
метапрограммирование. Обратите, пожалуйста, внимание, что в конце слова <code>println</code>
стоит знак <code>!</code>. Именно этот знак говорит о том, что это макрос, а не функция.
Это важно! Пожалуйста обратите на это внимание!</p>
<p>Далее, в круглых скобках находится текст <code>&quot;Hello, Rust world! Привет, Мир!&quot;</code>.
Он имеет тип данных <em>строка</em>. Этот текст передаётся макросу <code>println!</code> как входные
данные. Далее, макрос выполняет печать в строке терминала данный текст. Всё
достаточно просто и понятно, не так ли?!</p>
<p>Строка кода заканчивается символом <code>;</code>. Это символ информирует о том, что выражение
окончено, далее можно напечатать следующее.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Hello, Rust world! Привет, Мир!&quot;);
    println!(&quot;Hello! Привет!&quot;);
#}</code></pre></pre>
<blockquote>
<p>Пожалуйста, добавьте новую сточку кода в вашу программу и проделайте необходимые
операции, для того чтобы увидеть новый текст в терминальной строке!</p>
</blockquote>
<p>Unix:</p>
<pre><code class="language-shell">$ rustc main.rs
$ ./main
Hello, Rust world! Привет, Мир!
Hello! Привет!
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; rustc main.rs
&gt; main
Hello, Rust world! Привет, Мир!
Hello! Привет!
</code></pre>
<a class="header" href="print.html#aКомпиляция-и-выполнения---это-два-различных-этапа-работы" id="aКомпиляция-и-выполнения---это-два-различных-этапа-работы"><h3>Компиляция и выполнения - это два различных этапа работы</h3></a>
<p>В разделе &quot;Написание и запуск первой программы&quot; было показано, как выполнить
созданную программу. Сейчас мы постараемся разъяснить как это работает.</p>
<p>Прежде чем выполнить программму (т.е.вызвать в строке териминала созданные файл
программы <code>main</code>), необходимо скомпилировать её с помощью программы-компилятора
<code>rustc</code>.</p>
<p>Unix:</p>
<pre><code class="language-shell">$ rustc main.rs
</code></pre>
<p>Аналогично на Windows.</p>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; rustc main.rs
</code></pre>
<p>Таким же образом компилируются программы на C, C++, Java, Go. Результатом компиляции
Rust-программы является бинарный файл. Его можно увидеть в списке файлов:</p>
<p>Unix:</p>
<pre><code class="language-shell">$ ls
main  main.rs
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; dir /B
main.exe
main.rs
</code></pre>
<blockquote>
<p>опция /B позволяет отображать только файлы</p>
</blockquote>
<p>В списке присутствуют два файла: файл с исходным кодом программы <em>.rs</em> и бинарный
файл (<em>main.exe</em> в Windows, <em>main</em> на других опрационных системах).</p>
<pre><code class="language-shell">$ ./main  # or .\main.exe на Windows
</code></pre>
<p>Если бы в исходном коде <em>main.rs</em> в входных параметрах макроса был введё текст
“Hello, world!”, то в строке терминала вы бы увидели <code>Hello, world!</code>.</p>
<blockquote>
<p>Пожалуйста, отредактируйте файл исходного кода и проверьте работу нового бинарного
файла!</p>
</blockquote>
<p>Если у Вас есть опыт программирования на динамически компилируемых языках, таких как
Ruby, Python или JavaScript то вас, наверное, удивит необходимсть разделения
компиляции и выполнения программ. В составе утилит Rust есть <a href="https://ru.wikipedia.org/wiki/AOT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F">Ahead-of-Time</a> (AOT)
компилятор. Он позволяет создавать автономный бинарный файл, которые может быть
потом использован там, где нет Rust утилит. Это весьма удобно, как разработчиков
программного обеспечения, так и для пользователей. Динамические компилирумые
программы лишены такой возможности. Как бы там ни было, использование и динамические
и статически компилируемых языков программирования имеют свои плюсы и минусы.</p>
<p>Компиляция простых программ с помощью <code>rustc</code> - это замечательно, но если ваше
проект всё больше и большое, вам понадобятся средства управления всеми компонентами,
а также удобные возможности всего цикла командной разработки. Далее, мы представим
вам программу <code>cargo</code>, которая поможет создать удобную среду разработки.</p>
<a class="header" href="print.html#hello-cargo-Привет-cargo" id="hello-cargo-Привет-cargo"><h2>Hello, Cargo! Привет, Cargo!</h2></a>
<p>Cargo - это система управления пакетами для разработки программ на Rust. Удобство
её использования оценили программисты Rust. Cargo позволяет упростить процесс
разработки. Например, Сargo поможет скомпилировать программу из исходного кода,
скачать требуемые библиотеки для вашего проекта. В терминах языка программирования
Rust внешние библиотеки называются <em>зависимостями</em> (<em>dependencies</em>).</p>
<p>Такая простая программа, которую мы написали (main) не имеет зависимостей. Поэтому
Cargo нам может понадобиться только лишь для компиляции. Если же Вы напишете
(когда-нибудь напишете) более сложную программу на Rust, то весь функционал Cargo,
который помогает добавить зависимости в инфраструктуру вашего проекта будет весьма
кстати.</p>
<p>Поскольку огромное (подчёркиваю огромное) количество Rust-проектов использует Cargo
мы предположим, что и вам его функционал придётся по вкусу и будет удобен. Всё что
вам нужно для его использования идёт в комплекте с компилятором и другими утилитами.
Для того, чтобы проверить правильно ли установлен Cargo, введите с строке терминала
следующую команду:</p>
<pre><code class="language-shell">$ cargo --version
cargo 0.21.0
</code></pre>
<p>Если будет напечатана версия программы - Cargo скорее всего работает. А если
программа <code>cargo</code> не найдена - пожалуйста, постарайтесь устранить проблемы установки
(возможно, Вам понадобиться установить Cargo с помощью разлиных способов, кототры приведены на
сайте <a href="http://doc.crates.io/">doc.crates.io</a>.</p>
<blockquote>
<p>Для того чтобы узнать подробнее о возможностях утилиты <code>cargo</code>, пожалуйста, введите
следующую команду:</p>
</blockquote>
<pre><code class="language-shell">$ cargo --help
</code></pre>
<a class="header" href="print.html#aСоздание-cargo-проекта" id="aСоздание-cargo-проекта"><h3>Создание Cargo проекта</h3></a>
<p>Создадим проект используя Cargo! Думаю, что он будет отличаться от того проекта,
что был нами создан ранее (проект <code>main</code>):</p>
<p>Unix:</p>
<pre><code class="language-shell">$ cd ~/projects
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projects
</code></pre>
<p>Далее введём следующую команду:</p>
<pre><code class="language-shell">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<p>Мы устанавливаем аргумент <code>--bin</code> для carog-команды <code>new</code> для того, чтобы по шаблону
была создана структура приложения командной строки - консольный проект (бинарное
приложение). <code>hello_cargo</code> - это название нашего нового Rust проекта.</p>
<p>Если мы просмотрим список созданных файлов, то мы увидим что внутри папки проекта
были созданы файлы и папка: <em>Cargo.toml</em>,<em>.gitignore</em>, <em>src</em>. Внутри папки <em>src</em>
находится файл <em>main.rs</em>. По умолчанию Cargo оснастил папку нашего проекта файлом
<em>.gitignore</em> - это служебный файл git хранилища. Вы можете создать проект и без
инициализации git хранилища (или какого-либо иного вида системы контроля версий файлов),
если воспользуйтесь флагом <code>--vcs</code> при создании нового проекта:</p>
<pre><code class="language-shell">$ cargo new hello_cargo2 --bin --vcs none
$ cd hello_cargo2
</code></pre>
<p>Внутри текстового файла <em>Cargo.toml</em> следующее содержание:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Это файл формата <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (Tom’s Obvious, Minimal
Language). Формат TOML очень похож на INI, но он имеет свои специфические особенности.</p>
<p>На первой строке расположен заголовок секции<code>[package]</code>. Далее следует описание пакета.
По мере усложнения проекта, в данный файл будут добавлять другие секции.</p>
<p>Следующие строки - это строки описания пакета: имя, версия, авторы.
Если в строке у Вас написано имя компьютера, значит Вы ещё не до конца настроили
систему для работы с Cargo (Cargo не может считать информацию о вас а также недоступны
другие опции работы с github). Информацию об авторстве Cargo берёт из параметров
вашего git вашей учетной записи. Подробнее об этом можно ознакомиться перейдя по
<a href="https://github.com/rust-lang/cargo/issues/1213">ссылке</a>.
Если вы хотите устранить это недостаток, то для пользователей Windows предлагаю
следующее решение:</p>
<ol>
<li>Устанавливаете &quot;GitHub Desktop&quot;.</li>
<li>В приложении подключаетесь к своей учётной записи.</li>
<li>Далее создаёте проект.</li>
<li>Открывайте файл <em>Cargo.toml</em> созданного проекта и видите имя учётной записи и e-mail в строке <code>authors</code>.</li>
</ol>
<p>Последняя строка <code>[dependencies]</code> - это заголовок секции <em>crates</em> (так называются
пакеты в терминах языка программирования Rust). Этот список содержит описание зависимостей
вашего проекта и предоставляет Cargo функционалу необходимую информацию для загрузки
и компиляции. Т.к. в нашем шаблонном поекте не испльзуются внешние зависимости -
эта секция пуста. В проекте &quot;Угадай число&quot; мы заполним информацию о зависимостях.</p>
<p>Если у Вас появились вопросы, пожалуйста, познакомьтесь с разделом <a href="http://doc.crates.io/faq.html">FAQ</a> документации.</p>
<p>Теперь перейдём к рассмотрению содержания файла <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Как видите, тут уже есть код программы, который мы писали ранее.
Отличия нашего предыдущего проекта от сгенерируемого Cargo следующий:</p>
<ul>
<li>Имеется специальная папка для исходного кода программы <em>src</em>.</li>
<li>Есть файл конфигурации <em>Cargo.toml</em></li>
</ul>
<p>Программист Java, возможно, обратят внимание на концептуальную схожесть содержания
проекта с Maven. Да, есть что-то общее. Ваша интуиция не подводит.
В корневой папке проекта могут также содержаться файлы README, CONTRIBUTING, LICENSE,
файлы конфигурации, а также всё что угодно не относящаяся к исходному коду программы.
Концепция структуры хранения данных Cargo позволяет унифицировать структуру Rust
проектов, что делает их понятными для изучения и развития. Такие проекты потенциально
могут быть сколько угодно сложными и ёмкими. Cargo поможет со всеми ими справиться.</p>
<p>Если в своей работе вам придётся с необходимостью конвертации проекта Rust в
Cargo-проект - генерируемые шаблоны помогут вам.</p>
<p>Структура Cargo-проекта:</p>
<pre><code class="language-shell">.
├── Cargo.lock
├── Cargo.toml
├── benches
│   └── large-input.rs
├── examples
│   └── simple.rs
├── src
│   ├── bin
│   │   └── another_executable.rs
│   ├── lib.rs
│   └── main.rs
└── tests
    └── some-integration-tests.rs
</code></pre>
<p>Более подробную информацию о структуре типового Cargo-проекта вы можете узнать на
<a href="http://doc.crates.io/guide.html#project-layout">сайте</a>;</p>
<a class="header" href="print.html#aСборка-и-запуск-cargo-проектов" id="aСборка-и-запуск-cargo-проектов"><h3>Сборка и запуск Cargo проектов</h3></a>
<p>В чём же разница между сборкой и запуском Cargo проекта. Предлагаю разобраться!
Для этого в папке созданного проекта введём следующую cargo-команду - <code>build</code>
(<code>build</code> - это cargo-команда компиляции текущего проекта. С работой команды <code>new</code>
вы уже знакомы):</p>
<pre><code class="language-shell">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
</code></pre>
<p>Результат - создание бинарного файла в папке <em>target/debug/hello_cargo</em>
(<em>target\debug\hello_cargo.exe</em> в Windows). Проверим работу созданного файла:</p>
<p>Unix:</p>
<pre><code class="language-shell">$ ./target/debug/hello_cargo
Hello, world!
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; .\target\debug\hello_cargo
Hello, world!
&gt; # or .\target\debug\hello_cargo.exe
&gt; # or target\debug\hello_cargo.exe
&gt; # or target\debug\hello_cargo
</code></pre>
<p>Отлично! Всё работает замечательно. :-)</p>
<p>Обратите внимание, что команда <code>cargo build</code> при первом её запуске в текущем
проекте создаёт файл <em>Cargo.lock</em>. Этот файл содержит следующий текст:</p>
<p><span class="filename">Filename: Cargo.lock</span></p>
<pre><code class="language-toml">[root]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;


</code></pre>
<p>Файл <em>Cargo.lock</em> необходим для отслеживания зависимостей вашего проекта.
Так как текущей проект не содержит зависимостей, данный файл не содержит данных
для отслеживания зависимостей. По мере усложнения проекта Cargo будет отслеживать
зависимости (данный файл будет заполнять необходимой для этого информацией).
Более подробно об этом можно узнать из <a href="http://doc.crates.io/guide.html#cargotoml-vs-cargolock">документации</a>
проекта.</p>
<p>Для компиляции и последующего запуска программы на выполнение воспользуйтесь
Cargo-командой <code>run</code>:</p>
<pre><code class="language-shell">$ cargo run
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Обратите внимание, что в командной сроке не было напечатано ничего о компиляции.
Cargo умеет отслеживать состояние исходных файлов проекта. Так как изменений не
было - следовательно, перекомпиляция не нужно. Пожалуйста, внесите в исходный код
Rust-файла изменение. Скопируйте строчку кода ввода на печать и вставьте её на
новую строку. Сохраните ваши изменения. Запустите команду Cargo-команду <code>run</code> ещё
раз. Обратите внимание, что программа будет перекомпилирована и запущена.</p>
<pre><code class="language-shell">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Если запустить Cargo-команду <code>run</code> ещё раз - перекомпиляции не случиться.</p>
<pre><code class="language-shell">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p><code>shell $ cargo run Running `target/debug/hello_cargo` Hello, world!</code>
Подведём итоги:</p>
<ul>
<li>Для создания сложных проектов вместо того, чтобы использовать Rust-компилятор
<code>rustc</code> непосредственно, наилучшим решением является использование Cargo-команд.</li>
<li>Cargo-структура проекта используют принцип разделения и систематизации благодаря,
которому возможно построение проектов со сложными внешними зависимостями.</li>
</ul>
<p>Кроме того использование Cargo-команд позволяет вести многоплатформенную разработку.
Более подробно о проекте Cargo его возможностях можно узнать из документации:</p>
<pre><code class="language-shell">$ cargo --help
</code></pre>
<p>А также из материалов <a href="http://doc.crates.io/">сайта</a>.</p>
<a class="header" href="print.html#aСборка-готовых-оптимизированных-rust-приложений" id="aСборка-готовых-оптимизированных-rust-приложений"><h3>Сборка готовых (оптимизированных) Rust-приложений</h3></a>
<p>Когда проект уже готов к выпуску, можно воспользоваться Cargo-командой <code>build</code> c
флагом <code>--release</code>:</p>
<pre><code class="language-shell">$ cargo build --release
</code></pre>
<p>Эта команда скомпилирует и оптимизирует вашу программу. В папке <em>target/release</em>
будет создан бинарный файл. Все оптимизации позволят программе работать быстрее.
Обратная сторона подобной операции - более длительное время компиляции. Поэтому
существуют две команды компиляции - для разработки, для финальных версий.
Для проверки производительности ваших Rust-программ мы рекомендуем использовать
бинарные файлы, которые были получены путем компиляции и оптимизации (которые
сохраняются в пакте <em>target/release</em>).</p>
<a class="header" href="print.html#cargo-as-convention-cargo-конвенции" id="cargo-as-convention-cargo-конвенции"><h3>Cargo as Convention Cargo-конвенции</h3></a>
<p>Конечно, простые примеры не могут раскрыть все возможностей, которые предоставляет
Cargo по сравнение с прямой работой с компилятором. Для более сложных проектов
концепции Cargo - это проверенный временем стиль разработки. Привыкайте к хорошему
стилю работы даже с простыми проектами!</p>
<p>Этапы начала работы с любым Rust-проектом:</p>
<pre><code class="language-shell">$ git clone someurl.com/someproject
</code></pre>
<pre><code class="language-shell">$ cd someproject
</code></pre>
<pre><code class="language-shell">$ cargo build
</code></pre>
<p>Для того, чтобы почувствовать, что такое работа с &quot;неигрушечным&quot; проектом, проделайте
эти операции на примере проекта Cargo. Познакомьтесь с содержанием файлов <em>Cargo.toml</em>,
<em>Cargo.lock</em>, посмотрите создержание папки <em>src</em>.</p>
<p>Проект Cargo находится по адресу: <a href="https://github.com/rust-lang/cargo">github.com/rust-lang/cargo</a>.
Также вы можете попрактиковаться и над другими проектами, исходные коды которых
храняться на <a href="https://github.com/">github.com</a>. Для их поиска используйте возможности
расширенного поиска <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=language%3ARust&amp;type=Repositories&amp;ref=advsearch&amp;l=Rust&amp;l=">проектов</a>.</p>
<blockquote>
<p>Если вы хотите подробнее ознакомится с работой проектов Cargo, со всем, что
мы не рассказали в этой вводной статье, пожалуйста, ознакомьтесь с
<a href="http://doc.crates.io/guide.html">официальным руководством</a>.</p>
</blockquote>
<a class="header" href="print.html#aИгра-Угадай-число" id="aИгра-Угадай-число"><h1>Игра &quot;Угадай число&quot;</h1></a>
<p>Предлагаю начать программирование прямо сейчас! Мы создадим программу на Rust.
Будем учиться программированию по средством создания Rust-проекта. Эта глава поможет
Вам получить практический опыт работы, познакомит с концепциями языка программирования.
Вы научитесь использовать ключевые слова, такие как <code>let</code> и <code>match</code>, познакомитесь
с методами, ассоциированными функциями, научитесь использовать внешние модули и
многое другое. Мы надеемся, что изучив материалы этой главы вы освоите фундаментальные
знания теории и практике использования возможностей языка Rust.</p>
<p>Мы реализуем простую задачу: угадывание числа. Алгоритм игры следующий: программа
генерирует целое число от 0 до 100. Игрок должен угадать это число. После каждого
неправильного ответа даётся подсказка - загаданное число меньше или больше введенного
игроком. Если число угадано - победитель принимает поздравления. :-) Программа завершает
работу.</p>
<a class="header" href="print.html#aНастройка-нового-проекта" id="aНастройка-нового-проекта"><h2>Настройка нового проекта</h2></a>
<p>Для создания нового проекта, в строке терминала перейдите в папку <em>projects</em> (в
ту, которую Вы создали ранее). С помощью уже знакомой Вам утилиты <code>cargo</code> создадим
новый проект:</p>
<pre><code class="language-shell">$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>or</p>
<pre><code class="language-shell">$ cargo new guessing_game --bin &amp;&amp; cd guessing_game
</code></pre>
<p>Данная команда <code>cargo new</code> принимает аргумент - имя нового проекта
<code>guessing_game</code>, а далее флаг <code>--bin</code>, который уточняет какой тип приложения мы
хотим создать. В данном случае - это консольное приложение.</p>
<p>Рассмотрим содержание файла <em>Cargo.toml</em>, созданного в папке нового проекта:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Содержание файла <em>src/main.rs</em> такое же (), как и файла в проекте <em>hello_world</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Копилируем и запускаем программу с помощью команды <code>cargo run</code>:</p>
<pre><code class="language-shell">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Испльзуйте команду <code>run</code>, когда нужно быстро скомпилировать и запусть программу на
выполнение. Что-то подобное будет происходить и той программе, которую мы будем
создавать.</p>
<p>Отройте файл <em>src/main.rs</em> для редактирования. Далее мы будем менять содержание
этого шаблонного файла исходного кода программы.</p>
<a class="header" href="print.html#aОбработка-вводимых-данных" id="aОбработка-вводимых-данных"><h2>Обработка вводимых данных</h2></a>
<p>Программа начинается с опроса пользователя - необходимо ввести число. Далее программа
анализирует ввёденную пользователем информацию. Для начала напишем код, позволяющий
ввести данные с клавиатуры. Пожалуйста, замените содержание файла исходного кода
<em>src/main.rs</em> на следующий текст:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Listing 2-1: Программа просит ввести строку, а потом печатает
её</span></p>
<p>Этот программный код содержит много новой для Вас информации. Разберём код шаг за
шагом. Для того чтобы считать введённые данные с клавиатуры, а потом вывести их
на экран, нам нужна библиотека ввода/вывода <code>io</code>. Эта библиотека входит в состав
стандартной библиотеки Rust <code>std</code>.</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>По умолчанию, Rust загружает несколько типов данных в память, чтобы их можно было
бы использовать без каких-либо дополнительных описаний в коде (<a href="https://doc.rust-lang.org/std/prelude/index.html">the <em>prelude</em></a>)<!-- ignore -->.
Если типы данных, которые вы хотите использовать в программе не входят в состав
этих типов данных вам надо описать их использования явным образом. Это можно сделать
с помощью выражения <code>use</code>. Библиотека ввода/вывода <code>std::io</code> предоставляет множество
полезных функциональных возможностей, в том числе для обработки вводимых данных
пользователя.</p>
<p>Функция <code>main</code> - точка начала выполнения программы:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>Синтаксис определения функции следующий: <code>fn</code> - ключевое слово начала описания функции,
круглые скобки <code>()</code> - контейнер входных параметров функции, фигурная скобка <code>{</code> -
обозначение начала тела функции.</p>
<p><code>println!</code> - это макрос, которые печатает текст и перемещает курсор на новую строку:</p>
<pre><code class="language-rust ignore">println!(&quot;Guess the number!&quot;);

println!(&quot;Please input your guess.&quot;);
</code></pre>
<p>Этот код просто печатает предложение ввести строку для начала игры и далее печатает
введённое значение.</p>
<a class="header" href="print.html#aСоздание-переменной-для-хранения-значений" id="aСоздание-переменной-для-хранения-значений"><h3>Создание переменной для хранения значений</h3></a>
<p>Далее, мы создаём место хранения введенных игроком данных:</p>
<pre><code class="language-rust ignore">let mut guess = String::new();
</code></pre>
<p>Сейчас программа начинает становиться интересной. Обратите, пожалуйста, внимание,
как много нового в этой стоке! Прежде всего здесь есть выражение <code>let</code>, которое
используется для создания <em>переменной</em>. Вот, например:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>В этой сроке создаётся переменная с именем <code>foo</code>, которая связывается со значением
<code>bar</code>. Особенностью языка Rust является то, что переменные по умолчанию неизменяемые.
Этот пример показывает, как использовать ключевое слово <code>mut</code> перед именем переменной
для того, чтобы сделать переменную изменяемой:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // immutable
let mut bar = 5; // mutable
#}</code></pre></pre>
<blockquote>
<p>Обратите внимание, что символ <code>//</code> - это ключевое слова обозначающее комментарий,
который размещается на одной строке. Всё, что размещено в строке комментария -
игнорируется компилятором.</p>
</blockquote>
<p>Таким образом выражение <code>let mut guess</code> - это объявление изменяемой переменной с
именем <code>guess</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut guess = String::new();
#}</code></pre></pre>
<p>Обратите внимание, что это выражение состоит из двух частей разделенных знаком <code>=</code>.
С левой частью мы разобрались - это объявление переменной. Теперь разберёмся с
правой. Там располож вызов функции <code>new()</code>. Результат вызова этой функции - экземпляр
структуры имеющей тип <code>String</code>. Этот тип данных входит в стандартную библиотеку.
Создавая экземпляр <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a><!-- ignore -->, вы создаёте контейнер,
который может хранить строковые данные в кодировке UTF-8. Размер хранящихся данных
может изменяться динамически.</p>
<p>Также обратите внимание на синтаксическую конструкцию <code>::</code>. Выражение <code>::new</code>
сообщает нам следующую информацию: функуция <code>new</code> - это функция, которая связана с
типом <code>String</code>, а не с экземпляром данного типа. Знатоки языка <code>Java</code> сейчас улыбнуться,
увидя тут что-то знакомое. Да, да. Вы не ошиблись - это статический метода типа <code>String</code>.</p>
<p>Результатом вызова Функции <code>new</code> является новая, пустая <code>String</code>. С данной <code>new</code>,
я думаю, вы ещё неоднократно столкнётесь изучаю код стандартной библиотеки, т.к.
это общее имя функции, которая создаёт экземпляр определённого типа.</p>
<p>Подытожим наш анализ выражения <code>let mut guess = String::new();</code>. Данный код создаёт
изменяемую переменную <code>guess</code>, которая связывается с новым пустым экземпляром типа
<code>String</code>. Всё просто и ясно. Отлично!</p>
<p>Теперь перейдем к следующей сроки нашей прогоаммы. Рассмотрим длинную строку кода:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
#}</code></pre></pre>
<p>Тут мы видем вызов методов <code>read_line</code> и <code>expect</code> стандартной библиотеки <code>std::io</code>.
Благодаря тому, что мы заблаговременно сообщили о том, что будем использовать методы
данной библиотеки, мы сокращаем наш последующий код. Весьма удобно, не правда ли?!
Иначе ... а проверим, что будет иначе! Удалим (нет! просто закомментируем строку
кода <code>use std::io;</code>, ведь мы уже знаем как это делается в Rust!)  и посмотрим
на ошибки компилятора. Потом добавлять префикс <code>std::io</code> там где он необходим
(компилятор нам сообщим, где проблема - какая строка кода имеет ошибку). Нашли?
Отлично! проверяйте работу кода с помощью <code>cargo run</code>!</p>
<p>Вот вариант рабочего кода:</p>
<pre><pre class="playpen"><code class="language-rust">//use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();
  // ↓↓ мы добавили префикс std:: ↓↓
    std::io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre></pre>
<p>Также этот код можно переписать следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">//use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();
  // ↓↓ мы добавили префикс std:: ↓↓
    std::
    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre></pre>
<p>Функция <code>stdin</code> возвращает экземпляр типа <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->,
который является обработчиком данных, вводимых с клавиатуры терминала.</p>
<p>Следующая часть кода <code>.read_line(&amp;mut guess)</code> вызывает метод экземпляра этого
обработчика <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore -->. Данный метод производит чтение
введеных данных. Обратите внимание на синтаксис описания входных данных этого метода:
<code>&amp;mut guess</code>!</p>
<p>Метод <code>read_line</code> добавляет к содержанию переменной <code>guess</code> всё, что введено с
клавиатуры. Поэтому очень важно, чтобы переменная, к которой добавляются значения
была изменяемой.</p>
<p>Префикс переменной <code>&amp;</code> обозначает, что в функцию мы передаём <em>ссылку</em>. Это даёт
возможность непосредственного изменения данных, которые находятся в памяти по данному
адресу. Rust проявляет свои преимущества как раз в безопасной работе с такими типами
данных. В главе № 4 будет рассказано подробнее об этом типе данных. Важной особенностью,
о которой мы узнали из работы с данной строкой кода, является то, что переменные
данного типа по умолчанию - неизменяемые. Именно поэтому мы должны описать вводимые
данные имеено так <em><code>&amp;mut</code></em><code>guess</code>. <code>&amp;guess</code> - данного описания входных данных будет
недостаточно, чтобы сообщить компилятору о том, что мы передаём методу <code>read_line</code>
ссылку на изменяемые данные. Пожалуйста, проверьте это утверждение на практике!
Сначала изменим код так, чтобы некоторые его части можно было бы закоментировать,
а потом закомментируем строку содержащую ключевое слов <code>mut</code>.</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    std::io::stdin().read_line(
      &amp;
      //mut
      guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre></pre>
<p>При компиляции данного кода - получим ошибку, сообщающую нам о том, что входной параметр
данной функции должен быть изменяемым. Пожалуйста исправьте ошибку (раскомментировав
строку кода с ключевым словом <code>mut</code> и перекомпилировав программу)!</p>
<p>Далее перейдём к следующему методы этой длинной цепочки вызовов методов:</p>
<pre><code class="language-rust ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<p>На практике мы уже научились размещать код на нескольких строках (это может быть
необходимо по разным причинам: для удобства чтения длинных цепочек кода, для
включения/отключения некоторых звеньев). Поэтому даная запись:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>для удобства чтения, разделена на две строки</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess)
.expect(&quot;Failed to read line&quot;);
</code></pre>
<p>Оставим рассуждения о стиле. Вернёмся к сути! Далее мы продолжим изучать нашу
(уже такую близкую и понятную строку кода).</p>
<a class="header" href="print.html#aОбработка-потенциальных-ошибок-с-помощью-типа-result" id="aОбработка-потенциальных-ошибок-с-помощью-типа-result"><h3>Обработка потенциальных ошибок с помощью типа <code>Result</code></h3></a>
<p>Как мы уже знаем, функция <code>read_line</code> добавляет строковые данные к содержанию переменной.
Помимо этого эта фукнция возвращает значение <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->.
В стандартной библиотеке существует множество типов имеющих название <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->,
а также такими именами называются вложенные модули (например, <code>io::Result</code>).</p>
<p>Типа данных <code>Result</code> чаще всего являются <em>перечисления</em><a href="ch06-00-enums.html">enums</a><!-- ignore -->
(<em><a href="ch06-00-enums.html">enums</a></em>). Это такой тип данных, который имеет фиксированный набор значений.
В главе № 6 мы подробнее познакомится с этим типом данных.</p>
<p><code>Result</code>-значениями таких перечислений являются <code>Ok</code> и <code>Err</code>, которые в свою очередь
содержат данные. <code>Ok</code> - обозначает успех и содержит результат работы (в данном случае,
результат работы функции), а <code>Err</code>- обозначает неудачу и содержит в себе описание
ошибки.</p>
<p>Основной целью <code>Result</code>-типов является понятное для последующего анализа информации
об ошибке. Значениями <code>Result</code>-типов, так как и любых других типов, являются
определённые в них методы. Экземпляр типа <code>io::Result</code> имеет метод <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a><!-- ignore -->,
который вы можете вызвать. Если экземпляр типа <code>io::Result</code> является значение <code>Err</code>,
метод <code>expect</code> завершит работы программы и отобразит информацию об ошибке (с дополнительной
информацией, которую вы передали функции):</p>
<pre><code class="language-rust ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<p>Если же экземпляром типа <code>io::Result</code> является значение <code>Ok</code>, метод <code>expect</code>
возвратит результат работы. Пожалуйста, самостоятельно создайте переменую, присвойте
ей результат работы функции <code>expect</code> и напечатайте её содержание в терминальной
строке! В данном случае должно быть напечатано количество байт, которое было
введено с клавиатуры.</p>
<pre><code class="language-rust ignore">  let number_of_bytes = io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
  println!(&quot;number of bytes was entered: {}&quot;, number_of_bytes);
</code></pre>
<p>Если мы сохраним код программы, закомментировав вызов метода <code>expect</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    std::io::stdin().read_line(&amp;mut guess)
        //.expect(&quot;Failed to read line&quot;)
        ;

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre></pre>
<p>то в терминальной сроке будет напечатано предупреждение проблемах вашего кода:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Программа не обрабатывает возможные ошибки. Правильным решением соблюсти требования
компилятора будет написать обработчик ошибки. Вызов фукции <code>expect</code> - наиболее
простое решение. Боле подробно об обработки ошибок мы познакомится в главе № 9.</p>
<a class="header" href="print.html#aВывод-данных-с-помощью-println" id="aВывод-данных-с-помощью-println"><h3>Вывод данных с помощью <code>println!</code></h3></a>
<p>Осталась еще одна строка которую нам необходимо обсудить:</p>
<pre><code class="language-rust ignore">println!(&quot;You guessed: {}&quot;, guess);
</code></pre>
<p>Эта команда печатет строку, которую пользователь ввел ранее. Пара фигурных
скобок <code>{}</code> — это шаблон, который будет заменен аргументами, следующими за
строкой описывающей формат вывода. Чтобы запомнить этот синтаксис представьте,
что <code>{}</code> — это маленькие клешни краба, удерживающие значение на месте. Вы
можете вывести на экран сразу несколько переменных используя этот формат. Для
этого в строку, описывающую формат, необходимо вставить несколько шаблонов. В
этом случае на место первой пары фигурных скобок будет подставлен первый
аргумент после строки формата, на место второй пары — второй аргумент и так
далее. Вывод нескольких значений в одной строке будет выглядеть так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Этот код напечатает <code>x = 5 and y = 10</code>.</p>
<a class="header" href="print.html#aПроверка-работы-вашей-текущей-версии-программы-Угадай-число" id="aПроверка-работы-вашей-текущей-версии-программы-Угадай-число"><h3>Проверка работы вашей текущей версии программы &quot;Угадай число&quot;</h3></a>
<p>Пожалуйста, убедитесь, что ваша программа &quot;Угадай число&quot; работает корректно. Надеемся,
что Вы хорошо понимаете написанный код.</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn main() {
    println!(&quot;\&quot;Угадай число\&quot;&quot;);

    println!(&quot;Пожалуйста, введите предположение!&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Ой! Что-то случилось! К сожалению, Не удалось прочитать строку. :-(&quot;);

    println!(&quot;Вы ввели следующие данные: {}&quot;, guess);
}
</code></pre></pre>
<p>Пример компиляции и выполнения кода вашей программы с троке терминала:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>Итак, первая часть (ввод и отображения введённых вами данных) игры готова.</p>
<a class="header" href="print.html#aСоздание-числа-для-отгадывания" id="aСоздание-числа-для-отгадывания"><h2>Создание числа для отгадывания</h2></a>
<p>Прежде чем отгадать число нам необходимо его загадать. Программно это делается следующим
образом. Нам нужно сгенерировать число и сохранить его в какой-либо переменой.
Для того, чтобы игра была интересной для каждой новой игры это число должно быть
непредсказуемым. Для упрощения задачи, предположим что это число будет больше 0 и
меньше или равно 100. Пока стандартная библиотека не оснащена функциональностью
для генерации случайных чисел. Но для этих целей мы можем воспользоваться контейнером
(библиотекой) созданным разработчиками языка Rust <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>.</p>
<a class="header" href="print.html#aИспльзование-контейнеров-для-расширения-функциональных-возможностей-приложений" id="aИспльзование-контейнеров-для-расширения-функциональных-возможностей-приложений"><h3>Испльзование контейнеров для расширения функциональных возможностей приложений</h3></a>
<p>Внимание! Новая и важная информация - контейнеры <em>crate</em> (их ещё называют пакетами)
— это набор переносимого программного определённого созданного по определённым
правилам и служащий определённой цели. Эти контейнеры бывают разных видов: бинарные
и библиотечные. Одна из главных целей и задача проекта Cargo - помочь разработчикам
использовать сторонние пакеты. <code>rand</code> — это один из таких библиотечных пакетов.
Для доступа к его функциональным возможностям, прежде всего, надо модифицировать
содержание секции <code>[dependencies]</code> файла конфигурации <em>Cargo.toml</em>.</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<blockquote>
<p>Для того чтобы  узнать последнюю версию пакера, пожалуйста воспользуйтесь строкой
поиска на сайте <a href="https://crates.io/search">crates.io</a></p>
</blockquote>
<p>Обрате внимание, что вся информация в файле конфигурации сгруппирована по секциям.
Секция <code>[dependencies]</code> необходима для описания необходимого внешнего пакета.
В данном примере мы указали уникальный идентификатор и версию пакета. Обратите
внимание, что мы указали семантический номер версии <code>0.3.14</code>. Менеджер Cargo
использует <a href="http://semver.org">semver</a><!-- ignore -->(<em>SemVer</em>) - методологию написания и анализа
номера версии. В данном случае <code>0.3.14</code> - это сокращенная вид полного идентификатора
<code>^0.3.14</code>. Этот текст значит следующее: &quot;любая версия, которая имеет открытый API
и совместима с версией 0.3.14&quot;.</p>
<p>Будем считать, что Вы внесли вышеописанные изменения в файл <em>Cargo.toml</em> и
сохранили данный файл. Теперь можно собрать проект заново:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p><span class="caption">Listing 2-2: Результат работы команды <code>cargo build</code> после
того, как мы добавили информации о зависимости нашего проекта от пакета <code>rand</code></span></p>
<p>Результат работы на вашем компьютере может отличаться от данного, т.к. проекты находятся
в постоянном развитии (последовательность скачивания и компиляции пакетов также
может быть иной).</p>
<p>Теперь ваш проект содержит необходимые внешние контейнеры (пакеты), скаченные из
<em>регистратора пакетов</em> <a href="https://crates.io">Crates.io</a>. Crates.io - это сайт, где публикуются
результаты работ сообщества программистов Rust. Все они доступны для использования.</p>
<p>После обновления данные регистратора, Cargo проверяет зависимости описанные в секции
<code>[dependencies]</code> каждого необходимого для вашего проекта пакета. В данном случае,
пакет <code>rand</code> требует для своей компиляции пакет <code>libc</code>, т.к. он от него зависит.
После того, как все зависимости скачены Rust компилирует их и далее компилирует
вместе со сторонними зависимостями.</p>
<p>Если запустить команду <code>cargo build</code> ещё раз, то компиляции не будет - в ней нет
необходимости (если же Вы внесли какие-либо изменения в файл конфигурации <em>Cargo.toml</em>
— перекомпиляция произойдёт). Также Cargo отслеживает все изменения в вашем исходном
коде. Так что если вы сделаете изменения исходного кода - произойдёт перекомпиляция
только вашего проекта. Внешние пакеты перекомпилироваться не будут:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<a class="header" href="print.html#aЗащита-проекта-от-изменений-внешних-контейнеров--файл-cargolock" id="aЗащита-проекта-от-изменений-внешних-контейнеров--файл-cargolock"><h4>Защита проекта от изменений внешних контейнеров- файл <em>Cargo.lock</em></h4></a>
<p>Проект Cargo предлагает механизм защиты проекта от негативных воздействий со стороны
сторонних проектов. Он предлагает сравнительно простое решение. Это своеобрзный
реестр внешних проектов, который позволяет точно определить какие именно внешние
пакеты участвовали в удачной сборке и предлагает их использование при перекомпиляции,
при переносе проекта. <em>Cargo.lock</em> - как раз является хранилищем этих данных.</p>
<p>При повторной сборке проекта, Cargo, основывается на данных файла Cargo.lock.
Проект изменит данные о зависимостях лишь тогда, когда будет явно вызвана
команда обновления проекта.</p>
<a class="header" href="print.html#aОбновление-пакетов-и-получение-новой-версии" id="aОбновление-пакетов-и-получение-новой-версии"><h4>Обновление пакетов и получение новой версии</h4></a>
<p>Если Вам необходимо обновить внешние связи вашего проекта, Cargo предлагает для
этой цели команду <code>update</code>:</p>
<ol>
<li>При этом игнорируются данные файла <em>Cargo.lock</em>. Производится поик последних версий пакетов, описанных в файле <em>Cargo.toml</em></li>
<li>Если загрузка и компиляция зависимостей прошла успешно, происходит обновление данных файла <em>Cargo.lock</em>.</li>
</ol>
<p>По умолчанию (согласно семантической теории версий), Cargo производит поиск новых
версий пакета <code>rand</code>, которые большое <code>0.3.0</code> и меньше <code>0.4.0</code>. Если существует
несколько новых версий <code>rand</code> (<code>0.3.15</code> и <code>0.4.0</code>), при выполнений команды <code>udate</code>
вы увидите подобное сообщение:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>В этому случае, данные файла <em>Cargo.lock</em> изменятся с строках, описывающие версию
пакета.</p>
<p>Если же вы хотите перейти на версию <code>0.4.0</code> <code>rand</code> или даже большую <code>0.4.x</code>, то в
этом случае вам необходимо вручную поменять значение используемой версии пакета:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Все эти условности - следствия семантической теории версий пакетов. Пожалуйста,
найдите время познакомиться с ней!</p>
<p>Когда Вы в очередной раз будете использовать команду <code>cargo build</code>, будет произведен
анализ доступных версий исходя и новых особенностей зависимостей вашего проекта.</p>
<p>Более подробно о внутренней аналитической работе, связанной с анализом и обновлением
версий пакетом можно прочитать на страницах <a href="http://doc.crates.io">документации</a> и <a href="http://doc.crates.io/crates-io.html">дополнительных статьях</a>.</p>
<p>Благодаря активному использованию пакетов, создание ваших приложений становится проще,
а проекты компактнее. Важно лишь знать о существовании нужного пакета.</p>
<a class="header" href="print.html#aСоздание-псевдослучайных-чисел" id="aСоздание-псевдослучайных-чисел"><h3>Создание псевдослучайных чисел</h3></a>
<p>Приступим к <em>использованию</em> функционала пакета <code>rand</code>. Когда необходимые пакеты
на своих местах, можно менять исходный код программы <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Listing 2-3: В исходный код внесён функционал, создающий псевдослучайное число</span></p>
<p>Мы добавили строку <code>extern crate rand;</code>, которая сообщает Rust-компилятору, что
далее будет использован функционал данного пакета. Префикс <code>rand::</code> - это ссылка
на данный пакет.</p>
<p>Далее мы добавляем строку кода <code>use rand::Rng</code>, где <code>Rng</code> - это т.н. типаж (элемент
(синтаксическая конструкция) пакета <code>rand</code>, который определяет методы, которые
реализуют генераторы псевдослучайных чисел). Этот типаж обязан быть в области
видимости для выполняемого кода, для того, чтобы эти методы могли быть вызваны
(при необходимости). Более подробно о типажах будет рассказано в Главе 10.</p>
<p>Кроме декларирования намерений, мы написали код, который использует вышеописанный
функционал (если этого не сделать, то компилятор сообщит нам о нашей досадной
забывчивости). Функция <code>rand::thread_rng</code> возвращает экземпляр генератора псевдослучайных
чисел, ссылку на который мы используем в цепочке кода. Мы вызываем его метод
<code>gen_range</code> для получения псевдослучайного числа. Этот метод определён в типаже
<code>Rng</code>. Этот метод получает два числовых аргумента, которые являются концами числового
отрезка. Второе число не входит в числовой отрезок, поэтому псевдослучайное число
больше или равно 1 и строго меньше 101.</p>
<p>Мы, конечно, понимаем, что Вам неизвестно какой пакет и какая его функциональность
нужна для решения задачи. Возможно, знакомство с подробной документацией вселит в
Вас больше уверенности. Для удобства программистов Cargo  предоставляет удобную
возможность получения документации с помощь команды <code>cargo doc --open</code>. При этом
кроме того, что создаётся локальная версия документации, она становится доступна в
виде локального сайта. Если вам необходим доступ к информации о каких-либо других
возможностях пакета <code>rand</code> -  просто введите команду <code>cargo doc --open</code> и щелкните
по меню слева (где будут находиться ссылки на используемые вашим проектом и
его внешними зависимостями пакеты). Конечно, пока не очень понятно, что обозначают
конструкции кода, но путешествие по страницам данной документации даст общее представление
о возможностях утилит, которые в вашей дальнейшей работе с Rust будут весьма полезны.</p>
<p>Строка кода:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;The secret number is: {}&quot;, secret_number);
#}</code></pre></pre>
<p>печатает созданное случайное число. Вывод на печать текущих переменных - это одно
из средств отладки программ. Но чтобы в создаваемую игру было интересно играть -
данную строчку кода надо будет закомментировать (иначе нечего будет угадывать :-) ).</p>
<p>Когда код написан, изучен и сохранён - можно запустить нашу программу на выполнение
и посмотреть её в действии. Пожалуйста, запустите программу несколько раз и убедитесь
в том, что каждый раз печатаются разные случайные числа:</p>
<p>Попробуйте запустить программу несколько раз:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Обратите внимание, что выбор числа на заданном отрезке будет случайный. Программа
замечательно работает. Есть чему порадоваться. :-)</p>
<a class="header" href="print.html#aРеализация-попыток-угадывания-загаданного-числа" id="aРеализация-попыток-угадывания-загаданного-числа"><h2>Реализация попыток угадывания загаданного числа</h2></a>
<p>Теперь у нас есть код для введения данных игроком и загадывания числа (генерация
псевдослучайного числа на заданном отрезке). Теперь осталось добавить реализацию
анализа введёных данных (сравнить то, что ввёл игрок с тем, что сгенерировал
пакет <code>rand</code>):
(Listing 2-4):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listing 2-4: Вывод на печать результатов сравнения чисел</span></p>
<p>Пожалуйста, закомментируйте новые строчки кода! Сделали? А теперь строка за строкой
будем убирать комментарий и разбираться как это работает.
Итак, первая строчка кода, которая была добавлена, как вы наверное догадались,
находится в заголовочной части текста программы:</p>
<pre><code class="language-rust ignore">use std::cmp::Ordering;
</code></pre>
<p><code>Ordering</code> - это перечисление, имеющее значения: <code>Greater</code>, <code>Less</code> и <code>Equal</code>.
Всё логично, т.к. при любом сравнении исчисляемых объектов может быть только три
этих результата: больше, меньше или равно.</p>
<p>Далее, в теле функции <code>main</code> мы добавили следующую синтаксическую конструкцию:</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<p>Метод <code>cmp</code> сравнивает два значения и может быть вызван любой значение, которое
имеет такую функциональную возможность (возможность быть равной с чем-либо).
Этот метод получает ссылку в качестве входного параметра. Метод возвращает значения
перечисления <code>Ordering</code>. Это значение передаётся выражению <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->,
благодаря которому выбирается действие, которое выполнится в зависимости от переданного
значения.</p>
<p>Работа с этой оригинальной синтаксической конструкцией будет подробно описана в
главах 6 и 18. Сейчас вы должны понять, что это весьма удобная конструкция решает
поставленную перед нами задачу - по шаблону выполняется действие. Входные данные
сравниваются со значением шаблона и выполняется соответствующий код программы.</p>
<p>Если теоретически такой код должен работать, проверим это на практике:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>Мы получаем ошибку несоответствия типа входных данных метода <code>cmp</code>. Rust не может
сравнить величины разных типов (в данном случае строки и числа). <code>guess</code> неявно,
при инициализации получил строковое значение. <code>secret_number</code> получил числовое значение.</p>
<p>Так как нам надо сравнить два числа, то строковое значение надо конвертировать в
числовое. Следующий код демонстрирует такое преобразование:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>Обратите, пожалуйста, внимание на две новые строки:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Please type a number!&quot;);
</code></pre>
<p>Обратите также внимание, на название числовой переменной, которую мы создали - <code>guess</code>!
Мы создали переменную с тем же названием - для удобства и демонстрации функциональной
возможности Rust - скрытие переменной. Да, таким образом можно скрывать переменные
разных типов, чтобы не создавать новые. Такая вот интересная оптимизация на уровне
языка программирования. В главе 3 вы узнаете об этом более подробно.</p>
<p>Мы связали переменную с именем <code>guess</code> с цепочкой вызовов функций. Остановимся подробнее
на звеньях этой цепочки. Первым звеном является переменная <code>guess</code>, которая содержит
текстовое представление числа, введённого с клавиатуры. Метод, <code>trim</code>, который был
вызван далее удалил пробелы с начала и с конца введённой строки. Также этот метод
удаляет все непечатаемые символы - такие, как знак табуляции, перенос на новую строку,
возврат каретки.</p>
<p>Метод <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a><!-- ignore --> конвертирует текст в число. Т.к.  данный метод
позволяет получать разные числовые типы, мы должны явно указать, какой тип мы хотим
получить. Задание типа переменной <code>let guess: u32</code> - отличное решение для этой задачи.
Тип <code>u32</code> максимально близок к числам заданного отрезка. Вы познакомитесь со всеми
числовыми типами в главе 3. Переменную <code>secret_number</code> Rust приведёт к типу данных
<code>u32</code> за нас.</p>
<p>Обратите внимание, что следующее звено в цепочке вызовов функций уже нам знакомо!
Это функция <code>expect</code>. Это результат <code>Result</code> работы предыдущей функции. Если пользователь
ввел нечисловое значение - будет сообщено об ошибке.</p>
<p>Давайте проверим работу нашей программы!</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Отлично! Обратите внимание, что мы ввели пробелы перед и после числа. Пожалуйста,
проверьте все возможные варианты поведения программы!</p>
<p>Созданная нами программа может вести себя по-разному в зависимости от введённых данных.
Какого функционала ей не хватает?! Пожалуйста, подумайте! Конечно, же многократных
попыток угадать число!</p>
<a class="header" href="print.html#aМногократные-попытки-угадать-число" id="aМногократные-попытки-угадать-число"><h2>Многократные попытки угадать число</h2></a>
<p><code>loop</code> даёт возможность организовать бесконечный цикл:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>Ого! Мы можем бесконечно искать и находить решение - программа не закончится.
Только лишь сочетание клавиш <span class="keystroke">ctrl-C</span>, да неправильный
ввод данных помогут нам остановить работу программы:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
</code></pre>
<p>Введённое слово <code>quit</code>, конечно же остановило программу, но на его месте могло
быть любое иное слово и даже знак препинания. Для корректной работы программ нужны
иные средства прекратить работу бесконечного цикла и они, конечно же, есть.</p>
<a class="header" href="print.html#aПрекращение-цикла-после-введения-правильного-ответа" id="aПрекращение-цикла-после-введения-правильного-ответа"><h3>Прекращение цикла после введения правильного ответа</h3></a>
<p>Добавим необходимое улучшение нашей программы - реализуем возможность завершения
программы, если игра выйграна. Для этого надо добавить в наш код ключевое слово
языка программирования Rust - <code>break</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Если игрок введёт число равное загаданному - будет выведено поздравление и выполнен
код (<code>break;</code>) прекращающий бесконечный цикл.</p>
<a class="header" href="print.html#aОбработка-ошибок-ввода" id="aОбработка-ошибок-ввода"><h3>Обработка ошибок ввода</h3></a>
<p>Вместо аварийного завершения программы при введении вместо числового значения,
какого-либо иного, наилучшим решением было бы игнорировать это и дать возможность
пользователю продолжить игру. Для этого необходимо изменить код нашей программы в
том месте, где осуществляется конвертация строки в число:</p>
<pre><code class="language-rust ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Заменяя вызов метода <code>expect</code> на выражение <code>match</code> мы заменяем аварийное завершение
программы при ошибке конвертации на обработку этого события.</p>
<p>Пожалуйста, напишите код выводящий на печать результат работы функции <code>parse</code>:</p>
<pre><code class="language-rust ignore">
let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p><code>Ok</code> и <code>Err</code> - это значеня перечисления <code>Result</code>. Функция <code>parse</code> возвращает одно
из этих значений.
<code>Ok</code> будет содержать в себе конвертированное числовое значение.</p>
<p><code>Err</code> будет содержать в себе информацию об ошибке. Обратите внимание на входной
параметр <code>_</code>.  Он говорит о том, что будут обрабатываться любые ошибки одинаковым
образом. Выполнение кода <code>continue</code> позволяет программе прервать ход выполнения кода
и перейти на выполнение следующей итерации цикла. В данном случает этот код позволяет
игнорировать любые ошибки при конвертации, при этом останавливая ход выполнения программы
в этом месте и переходя на выполнения цикла с начала.</p>
<p>Теперь программа должна работать корректно. Пожалуйста проверьте это:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Отлично! Благодаря этому улучшению кода наша программа замечательно работает. :-)
Программа оттестирована и теперь можно или удалить код программы, который печатает
секретное число или просто закомментировать его. Решайте сами. :-)</p>
<p>Вот финальный вид кода нашей программы:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 2-5: Полный код программы &quot;Угадай число&quot;</span></p>
<a class="header" href="print.html#aИтоги" id="aИтоги"><h2>Итоги</h2></a>
<p>Поздравляю Вас! Вы успешно прошли все этапы создания игры. Поздравляю!</p>
<p>Это было обзорное представления возможностей и концепций языка Rust: ключевые слова
<code>let</code>, <code>match</code>, методы, ассоциированные функции, внешние пакеты. Последующие главы
расскажут вам об всем этом более подробно. Глава 3 рассказывает
об общеязыковых концепциях Rust - переменные, типы данных, функции. Разбираются
примеры их использования. Глава 4 повествует о владении. Это одна из отличительных
черт Rust. Глава 5 рассказывает о структурах и их методах. Глава 6 рассказывает о
перечислениях.</p>
<a class="header" href="print.html#aОбщеязыковые-концепции-языков-программирования-которые-также-есть-в-rust" id="aОбщеязыковые-концепции-языков-программирования-которые-также-есть-в-rust"><h1>Общеязыковые концепции языков программирования, которые также есть в Rust</h1></a>
<p>Эта глава описывает концепции языков программирования, которые реализованы во
многих языках программирования. Также будет описано, как эти концепции воплощены
в Rust. Вы познакомитесь с стилем программирования, которым рекомендуют придерживаться
разработчики языка.</p>
<p>Вы познакомитесь с такими понятиями, как переменные, простые типы, функции, комментарии
и управляющие конструкции. Всё это теоретическая основа более сложных концепций.
Очень важно знать об их существовании, понимать их и уметь использовать.</p>
<blockquote>
<a class="header" href="print.html#aКлючевые-слова" id="aКлючевые-слова"><h3>Ключевые слова</h3></a>
<p>Язык Rust имеет набор слов - &quot;ключевых&quot; и зарезервированных слов, каждое из которые
имеет специальное значение. Эти слова можно использовать только по назначению.
Неправильное или неуместное их применение приводит к ошибкам. Все эти слова приведены
в приложении А.</p>
</blockquote>
<a class="header" href="print.html#aПеременные-и-понятие-изменяемости" id="aПеременные-и-понятие-изменяемости"><h2>Переменные и понятие изменяемости</h2></a>
<p>Как Вы знаете, по умолчанию все Rust-переменные неизменяемые. Это одна из особенностей
(рекомендаций) языка Rust, которая позволяет писать безопасные программы. Также это важно для
решения задач параллельного программирования. При необходимости переменные могут
быть изменяемыми. Давайте рассмотрим преимущества того и другого подхода.</p>
<p>Поведение неизменяемых переменных напоминает поведение константы.
Приведём пример использования этого типа переменной. Давайте создадим новый проект.
Назовём его <em>variables</em>: <code>cargo new --bin variables</code>.</p>
<p>Потом перейдите в созданную папку проекта <em>variables</em> и отредактируйте исходный
код следующим образом:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>Сохраните код программы и выполните команду <code>cargo run</code>. В терминальной строке вы
увидите красноречивое сообщение об ошибке:</p>
<pre><code class="language-text">error[E0384]: re-assignment of immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ re-assignment of immutable variable
</code></pre>
<p>Компилятор продемонстрировал вам свои полезные возможности. Ошибка была найдена.
Пожалуйста, будьте терпеливы! Компилятор - ваш помощник, который помогает делать
программы защищёнными от ошибок насколько это возможно. Из описания ошибки можно
понять что же не так - <code>попытка присвоить неизменяемой переменной новое значение</code>.</p>
<p>Очень важно получить сообщение об ошибке такого рода на этапе компиляции.
В других языках программирования такую ошибку бывает трудно отыскать.</p>
<p>Компилятор Rust гарантирует, что ошибки такого рода будут выявлены. Ещё одно преимущество
такого кода - такой код проще в изучении.</p>
<p>Неизменяемость - это, конечно, замечательная опция, но, иногда, требуется иное поведение
переменной. Сделать переменную изменяемой, при желании, очень просто. Достаточно
добавить ключевое слово <code>mut</code> при декларировании переменной. Также, явное указание
этой особенности переменной повышает читаемость исходного кода.</p>
<p>Рассмотрим использование изменяемой переменой на практике. Пожалуйста, измените
код программы <em>src/main.rs</em> следующим образом (обратите внимание, что мы просто
добавили при декларировании переменной <code>x</code> ключевое слово <code>mut</code>):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Обратите, пожалуйста, внимание что теперь программа скомпилируется и код программы
будет выполнен строчка за строчкой:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Ключевое слово <code>mut</code> позволяет переменой <code>x</code> быть инициализированной значением <code>5</code>,
а потом изменить своё содержание на другое значение <code>6</code>. В некоторых случая такое
поведение переменной может быть безопасным.</p>
<p>Зачастую, исходный код программы - это компромисс между безопасностью и удобством.
К примеру, для повышения производительности кода, при работе с большими массивами
данных использование изменяемых переменных будет предпочтительным. При этом накладные
расходы на изменение переменной будут значительно меньше нежели создание нового места
хранения. При работе с небольшими наборами данных накладные расходы для создания
новой переменной незначительны. Это ведёт к простоте кода программы.</p>
<a class="header" href="print.html#aРазличия-между-переменными-и-константами" id="aРазличия-между-переменными-и-константами"><h3>Различия между переменными и константами</h3></a>
<p>Вы, я думаю, обратили внимание, что поведение &quot;неизменяемых переменных&quot; весьма
схоже с поведением <em>коснтант</em>. Да, действительно, сходства есть, но есть также
и отличия:</p>
<ol>
<li>При объявлении констант нельзя использовать <code>mut</code> (логично по определению).</li>
<li>При объявлении константы используется ключевое слово <code>const</code>, а при объявлении переменой <code>let</code>.</li>
<li>При объявлении константы указание типа данных <em>обязательно</em> (для оптимизации).</li>
</ol>
<p>Важной особенностью <em>констант</em> является область видимости, в которой можно их декларировать.
Без ограничений.</p>
<p>Кроме того <em>константы</em> могут быть инициализированы только лишь константным выражением,
которое не может быть результатом вызова функции или какого-либо иного выражения,
значение которого не известно во время компиляции исходного кода.</p>
<p>Вот пример объявления костанты <code>MAX_POINTS</code>. Для объявления констант рекомендуется
использовать заглавные буквы.</p>
<pre><pre class="playpen"><code class="language-rust">const MAX_POINTS: u32 = 100_000;

fn main() {
    println!(&quot;MAX_POINTS is: {}&quot;, MAX_POINTS);
}
</code></pre></pre>
<p>Чтобы лучше понять что же такое константы, пожалуйста скомпилируйте следующий код:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;MAX_POINTS is: {}&quot;, MAX_POINTS);
    const MAX_POINTS: u32 = 100_000;
    print();
}

fn print(){
  println!(&quot;MAX_POINTS is: {}&quot;, MAX_POINTS);
}
const MAX_POINTS: u32 = 200_000;
</code></pre></pre>
<p>Константы доступны в своей области видимости. Также они могут скрываться одноименными
константами во вложенной области видимости. Константы доступны в любом месте области видимости.</p>
<p>Константы также удобны для хранения неизменяемых данных программы, а также таких
значения которых могут изменять со временем.</p>
<a class="header" href="print.html#aМногократное-использование-одноимённых-переменных" id="aМногократное-использование-одноимённых-переменных"><h3>Многократное использование одноимённых переменных</h3></a>
<p>Как вы знаете, в Rust можно использовать одно и тоже имя переменной многократно.
При этом используется значение ближайшей доступной переменной.</p>
<p>Вот как это выглядит в коде программы:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Пожалуйста, закомментируйте все строчки тела функци <code>main</code>, кроме последней. А потом,
одну за одной раскомментируйте и запускайте программу на выполнение. Благодаря
проделанной работе вы поймёте как изменяется содержание переменной <code>x</code>.</p>
<p>Такое поведение неизменяемых переменных отличается от использования изменяемых.
Этот шаблон эмуляции изменяемой переменной позволяет более точно выразить идею
автора кода, что повысит как его надёжность так и читабельность:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let spaces = &quot;   &quot;;
let spaces = spaces.len();
#}</code></pre></pre>
<p>Такая кострукция не вызывает ошибки компилятора, т.к. в каждой строке кода объявляется
новая переменная, которая может быть (потенциально) любого типа. Первая переменная
строкового типа, а вторая числового.</p>
<p>Пожалуйста проверьте это утверждение на практике:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = &quot;_&quot;;
    println!(&quot;The value of x is: {}&quot;, x);
    let x = x.len();
    println!(&quot;The value of x is: {}&quot;, x);
    let x = &quot;Привет!&quot;;
    println!(&quot;The value of x is: {}&quot;, x);
    let x: u32 = x.len() as u32;
    println!(&quot;The value of x is: {}&quot;, x);
    let x = &quot;Привет!&quot;;
    println!(&quot;The value of x is: {}&quot;, x);
    let x: f32 = 3.45;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Такая техника описания переменных даёт возможность использовать одно имя переменной
для работы с разными типами данных. Изменяемая переменная не может обладать таким
свойством, т.е компиляция:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let mut x = &quot;_&quot;;
  println!(&quot;The value of x is: {}&quot;, x);
  spaces = x.len();
  println!(&quot;The value of x is: {}&quot;, x);

}
</code></pre></pre>
<p>или</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let mut spaces = &quot;   &quot;;
  spaces = spaces.len();
  println!(&quot;The value of x is: {}&quot;, spaces);

}

приведёт к ошибке:

```text
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre></pre>
<p>Пожалуйста, проверьте как работает этот код! Поэкспериментируйте над использованием
уже знакомых вам типов данных (строками, целыми и дробными числами)!
Обратите внимание, что компилятор сам подставляет типы данных при инициализации
переменных.</p>
<p>Теперь, когда вы имеете представление о работе с переменными в Rust в общем виде,
мы можем углубиться в детали. Изучим какие у них могут быть типы данных.</p>
<a class="header" href="print.html#data-types-Типы-данных" id="data-types-Типы-данных"><h2>Data Types Типы данных</h2></a>
<p>Любая переменная в языке Rust обязательно имеет какой-либо тип. Это даёт возможность
корректной её обработки, а также проведение возможной оптимизации. В этой части
книги вы познакомитесь с встроенными в стандартную библиотеку типами данных,
которые не требуют перед своим использованием каких-либо дополнительных описаний.
И предыдущей секции вы узнали, что типы данных присваиваются перемененным при их
инициализации. В этой секции вы узнаете о типах данных подробнее.</p>
<p>Важной особенностью языка Rust является <em>статическая типизация</em>. Благодаря этому
все типы данных переменных известны при компиляции кода. Конкретный тип данных,
если это не указано заранее, компилятор выбирает сам на основании доступных данных
(на основе конкретного значения и способа его использования). Для устранения
неточности, используется явное указание типа данных:</p>
<p>Также особенностью объявления литерала является возможность аннотирования. Это
позволяет в краткой форме описать тип данных Например: <code>5i32</code>, <code>1u32</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  println!(&quot;guess = {}&quot;,guess);
}
</code></pre></pre>
<p>Пожалуйста, удалите или закомментируйте информацию о типе переменной и, попробовав
скомпилировать код, получите ошибку:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let guess
  //: u32
  = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  println!(&quot;guess = {}&quot;,guess);
}
</code></pre></pre>
<pre><code class="language-text">error[E0282]: unable to infer enough type information about `_`
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ cannot infer type for `_`
  |
  = note: type annotations or generic parameter binding required
</code></pre>
<p>Изучая материалы этой секции, вы познакомитесь с различными типами данных Rust.</p>
<a class="header" href="print.html#aСкалярные-типы-данных" id="aСкалярные-типы-данных"><h3>Скалярные типы данных</h3></a>
<p>Скалярный тип данных (scalar data type) содержит одно значение и не имеет внутренних
компонентов. Скалярные типы данных делятся на четыре категории:</p>
<ul>
<li>Числовые.</li>
<li>Символьные.</li>
<li>Даты.</li>
<li>Логические данные.</li>
</ul>
<p>В состав скалярных типов <em>Rust</em> входят:</p>
<ul>
<li>целые числа,</li>
<li>числа с плавающей запятой,</li>
<li>логические,</li>
<li>символьные.</li>
</ul>
<p>Рассмотрим особенности каждого из них по порядку.</p>
<a class="header" href="print.html#aЦелые-числа" id="aЦелые-числа"><h4>Целые числа</h4></a>
<p>С одним из целых типом мы уже знакомы. Мы использовали его для уточнения при
конвертации строки в число. Обратите внимание на первый символ с типе <code>u32</code>!
Он указывает на то, что данный тип не может быть отрицательной величиной.
Число, стоящее после буквы указывает на битовую разрядность этого числа.
Если заменить символ <code>u</code> на <code>i</code> <code>u32</code>, то в переменной данного типа можно будет
присваивать отрицательные целый числа. Проверим на нашем примере:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let guess:
  //u32
  i32
  = &quot;-42&quot;.parse().expect(&quot;Not a number!&quot;);
  println!(&quot;guess = {}&quot;,guess);
}
</code></pre></pre>
<p>Обратите внимание, на знак конвертируемого числа <code>-42</code>! Пропробуйте присвоить
это значение беззнаковому типу данных <code>u32</code>!</p>
<p><span class="caption">Table 3-1: Rust. Целочисленные типы данных</span></p>
<table><thead><tr><th> Length </th><th> Signed </th><th> Unsigned </th></tr></thead><tbody>
<tr><td> 8-bit  </td><td> i8     </td><td> u8       </td></tr>
<tr><td> 16-bit </td><td> i16    </td><td> u16      </td></tr>
<tr><td> 32-bit </td><td> i32    </td><td> u32      </td></tr>
<tr><td> 64-bit </td><td> i64    </td><td> u64      </td></tr>
<tr><td> arch   </td><td> isize  </td><td> usize    </td></tr>
</tbody></table>
<p>Пожалуйста, используйте их в нашей программе! Посмотрите на особенности их работы в
коде!</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let guess:
  //u8
  //u16
  //u32
  //u64
  i8
  //i16
  //i32
  //i64
  //isize
  //usize

  = &quot;-42&quot;.parse().expect(&quot;Not a number!&quot;);
  println!(&quot;guess = {}&quot;,guess);
}
</code></pre></pre>
<p>Давайте пристальнее посмотрим на эту сводную таблицу: по горизонтали длины, по
вертикали два варианта числового типа - знакового и беззнакового. Надеюсь, что
теперь ясно какие Rust имеет типы данных. А теперь очень интересный вопрос. Какие
ограничения у этих типов данных. Давайте напишем программу, которая будет выводить
доступные для использования числа в определённом типе данных. Для этого исследования
подойдут уже усвоенные нами знания об особенностях переменных, а также бесконечный цикл.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let mut value:
  u8
  //u16
  //u32
  //u64
  //i8
  //i16
  //i32
  //i64
  //isize
  //usize

  = 0;
  println!(&quot;value = {}&quot;, value);
}
</code></pre></pre>
<p>Запустите программу, измените код так, чтобы программа вывела бы вам все доступные
в указанном типе данных величины. Изучите работу со всеми целочисленными типами!
Благодаря созданным учебным программам Вы узнаете максимально допустимые величины
каждого целочисленного типа данных и, конечно, получите бесценный опыт и уверенность.</p>
<table><thead><tr><th> Type </th><th> Signed min         </th><th> Signed max         </th></tr></thead><tbody>
<tr><td> i8   </td><td> -128               </td><td> 127                </td></tr>
<tr><td> i16  </td><td> -32768             </td><td> 32767              </td></tr>
<tr><td> i32  </td><td>-2147483648         </td><td> 2147483647         </td></tr>
<tr><td> i64  </td><td>-9223372036854775808</td><td> 9223372036854775807</td></tr>
<tr><td> isize</td><td>-9223372036854775808</td><td> 9223372036854775807</td></tr>
</tbody></table>
<table><thead><tr><th> Type </th><th> Unsigned min </th><th> Unsigned max        </th></tr></thead><tbody>
<tr><td> u8   </td><td> 0            </td><td> 255                 </td></tr>
<tr><td> u16  </td><td> 0            </td><td> 65535               </td></tr>
<tr><td> u32  </td><td> 0            </td><td> 4294967295          </td></tr>
<tr><td> u64  </td><td> 0            </td><td> 18446744073709551615</td></tr>
<tr><td> usize</td><td> 0            </td><td> 18446744073709551615</td></tr>
</tbody></table>
<p>Один из возможных вариантов решения. Остановить длинный или бесконечный цикл, зависшее
консольное приложение можно комбинацией клавиш <code>Ctrl-C</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let max = &lt;i8&gt;::max_value();
    let mut value = &lt;i8&gt;::min_value();
    loop {
        value = value + 1;

        println!(&quot;value = {}&quot;, value);

        if value == max {
            break;
        }
    }
}

</code></pre></pre>
<p>Каждый знаковый числовой тип хранит данные от -(2<sup>n - 1</sup>) до 2<sup>n -
1</sup> - 1 включительно, где n - это количество использованных битов данных.
Переменная типа данных <code>i8</code> может хранить значения от -(2<sup>7</sup>) до
2<sup>7</sup> - 1. Что эквивалентно следующему отрезку [-128, 127]. А беззнаковая
переменная такого же битового размера может хранить величины от 0 до 255.</p>
<p>Обратите внимание на типы данных <code>isize</code> и <code>usize</code>. Их битовая ёмкость зависит от
архитектуры операционной системы. Если система 32-битная - переменные могут хранить
32-битные величины, если 64-битные соответственно.</p>
<p>Кроме ёмкости целочисленные переменные могут иметь различные обозначения.
Так одно и тоже число может быть записана в разных системах счисления. Её выбор
зависит от замысла программиста. Есть также возможность указать тип литерала непосредственно
при его написании (в виде суффикса числа). Правда есть ограничения (битовая система
счисления не имеет суффикса). Также для удобства представления есть возможность
использовать визуальные разделитель разрядов <code>_</code>.</p>
<p><span class="caption">Table 3-2: Integer Literals in Rust</span></p>
<table><thead><tr><th> Number literals  </th><th> Example       </th></tr></thead><tbody>
<tr><td> Decimal          </td><td> <code>98_222</code>      </td></tr>
<tr><td> Hex              </td><td> <code>0xff</code>        </td></tr>
<tr><td> Octal            </td><td> <code>0o77</code>        </td></tr>
<tr><td> Binary           </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Byte (<code>u8</code> only) </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<pre><pre class="playpen"><code class="language-rust">fn main() {

  let value = 98_222_000;
  println!(&quot;value = {}&quot;, value);

  let value = 0xff;
  println!(&quot;value = {}&quot;, value);

  let value = 0o77;
  println!(&quot;value = {}&quot;, value);

  let value = 0b1111_0000;
  println!(&quot;value = {}&quot;, value);

  let value = b'A';
  println!(&quot;value = {}&quot;, value);

}
</code></pre></pre>
<p>Если вы не уверены какой тип данных выбрать - используйте тип по умолчанию. Это
<code>i32</code>. Типы данных <code>isize</code> или <code>usize</code> используются при сортировке наборов данных.</p>
<p>Примеры использования различных видов написания целочисленных числовых данных:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let value = 98_222_000;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0xff;
    println!(&quot;value = {}&quot;, value);
    value = 0x_ff;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0o77;
    println!(&quot;value = {}&quot;, value);
    value = 0o_77;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0b1111_0000;
    println!(&quot;value = {}&quot;, value);
    value = 0b1_111_0000;
    println!(&quot;value = {}&quot;, value);

    let value = b'A';
    println!(&quot;value = {}&quot;, value);
}

</code></pre></pre>
<p>Примеры использование разделителя <code>_</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let value = 98_222_000;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0xff;
    println!(&quot;value = {}&quot;, value);
    value = 0x_ff;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0o77;
    println!(&quot;value = {}&quot;, value);
    value = 0o_77;
    println!(&quot;value = {}&quot;, value);

    let mut value = 0b1111_0000;
    println!(&quot;value = {}&quot;, value);
    value = 0b1_111_0000;
    println!(&quot;value = {}&quot;, value);

    let value = b'A';
    println!(&quot;value = {}&quot;, value);
}

</code></pre></pre>
<p>Обратите внимание на результаты работы программы, при использовании инициализации
по умолчанию данными значениями:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    //let value = 9223372036854775807;
    let value:i64 = 9223372036854775807;
    println!(&quot;value = {}&quot;, value);

    //let value = -9223372036854775808;
    let value:i64 = -9223372036854775808;
    println!(&quot;value = {}&quot;, value);

    //let value = 18446744073709551615;
    let value:u64 = 18446744073709551615;
    println!(&quot;value = {}&quot;, value);
}

</code></pre></pre>
<p>Пожалуйста, проверьте вышеописанную информацию, используя теоретическую
информацию в ваших программных кодах.
Уверен, что вы столкнётесь с различными сюрпризами, которые помогут усвоению
пройденного материала и ускорят ваше становления в качестве знатока Rust. Пишите
код, пишите!</p>
<a class="header" href="print.html#aЧисла-с-плавающей-запятой" id="aЧисла-с-плавающей-запятой"><h4>Числа с плавающей запятой</h4></a>
<p>Кроме типов данных обозначающие целые числа Rust имеет два типа данных обозначающие
числа с плавающей запятой. Это 32- и 64-битные величины - <code>f32</code> и <code>f64</code>.
По умолчанию, т.е. при автоматическом определении типа используется <code>f64</code>.
Хотя скорость обработки данных не зависит он разрядности конкретного типа, всё же
на 32-разрядных системах для увеличения производительности рекомендуется использовать
<code>f32</code>.</p>
<p>Пример инициализации чисел с плавающей запятой:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}

</code></pre></pre>
<p>Очень важно знать предельные значения типов данных. Стандратная библиотек Rust
проелагает подробную информацию по каждому типу данных.
Узнать максимальное и минимальное значения этих типов данных нам поможет &quot;изящное&quot;
решение:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let value32_min = std::f32::MIN;
    println!(&quot;value f32 min = {}&quot;, value32_min);
    let value32_max = std::f32::MAX;
    println!(&quot;value f32 max = {}&quot;, value32_max);

    let value64_min = std::f64::MIN;
    println!(&quot;value f64 min = {}&quot;, value64_min);
    let value64_max = std::f64::MAX;
    println!(&quot;value f64 max = {}&quot;, value64_max);
}
</code></pre></pre>
<p>Формат чисел с плавающей запятой соответствует стандарту IEEE-754. При этом <code>f32</code> -
это числа с единичной точностью, а <code>f64</code> с двойной точностью.</p>
<p>Пожалуйста, самостоятельно изучите состав констант модуля <code>std::f32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
fn main() {
    println!(&quot;std::f32&quot;);
    // Approximate number of significant digits in base 10.
    println!(&quot;DIGITS = {}&quot;, std::f32::DIGITS);

    // Difference between 1.0 and the next largest representable number.
    println!(&quot;EPSILON = {}&quot;, std::f32::EPSILON);

    // Infinity (∞).
    println!(&quot;INFINITY = {}&quot;, std::f32::INFINITY);

    // Number of significant digits in base 2.
    println!(&quot;MANTISSA_DIGITS = {}&quot;, std::f32::MANTISSA_DIGITS);

    // Largest finite f32 value.
    println!(&quot;MAX = {}&quot;, std::f32::MAX);

    // Maximum possible power of 10 exponent.
    println!(&quot;MAX_10_EXP = {}&quot;, std::f32::MAX_10_EXP);

    // Maximum possible power of 2 exponent.
    println!(&quot;MAX_EXP = {}&quot;, std::f32::MAX_EXP);

    // Smallest finite f32 value.
    println!(&quot;MIN = {}&quot;, std::f32::MIN);

    // Minimum possible normal power of 10 exponent.
    println!(&quot;MIN_10_EXP = {}&quot;, std::f32::MIN_10_EXP);

    // One greater than the minimum possible normal power of 2 exponent.
    println!(&quot;MIN_EXP = {}&quot;, std::f32::MIN_EXP);

    // Smallest positive normal f32 value.
    println!(&quot;MIN_POSITIVE = {}&quot;, std::f32::MIN_POSITIVE);

    // Not a Number (NaN).
    println!(&quot;NAN = {}&quot;, std::f32::NAN);

    // Negative infinity (-∞).
    println!(&quot;NEG_INFINITY = {}&quot;, std::f32::NEG_INFINITY);

    // The radix or base of the internal representation of f32.
    println!(&quot;RADIX = {}&quot;, std::f32::RADIX);
}

</code></pre></pre>
<p>Пожалуйста, самостоятельно изучите состав констант модуля <code>std::f64</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
fn main() {
    println!(&quot;std::f64&quot;);
    // Approximate number of significant digits in base 10.
    println!(&quot;DIGITS = {}&quot;, std::f64::DIGITS);

    // Difference between 1.0 and the next largest representable number.
    println!(&quot;EPSILON = {}&quot;, std::f64::EPSILON);

    // Infinity (∞).
    println!(&quot;INFINITY = {}&quot;, std::f64::INFINITY);

    // Number of significant digits in base 2.
    println!(&quot;MANTISSA_DIGITS = {}&quot;, std::f64::MANTISSA_DIGITS);

    // Largest finite f64 value.
    println!(&quot;MAX = {}&quot;, std::f64::MAX);

    // Maximum possible power of 10 exponent.
    println!(&quot;MAX_10_EXP = {}&quot;, std::f64::MAX_10_EXP);

    // Maximum possible power of 2 exponent.
    println!(&quot;MAX_EXP = {}&quot;, std::f64::MAX_EXP);

    // Smallest finite f64 value.
    println!(&quot;MIN = {}&quot;, std::f64::MIN);

    // Minimum possible normal power of 10 exponent.
    println!(&quot;MIN_10_EXP = {}&quot;, std::f64::MIN_10_EXP);

    // One greater than the minimum possible normal power of 2 exponent.
    println!(&quot;MIN_EXP = {}&quot;, std::f64::MIN_EXP);

    // Smallest positive normal f64 value.
    println!(&quot;MIN_POSITIVE = {}&quot;, std::f64::MIN_POSITIVE);

    // Not a Number (NaN).
    println!(&quot;NAN = {}&quot;, std::f64::NAN);

    // Negative infinity (-∞).
    println!(&quot;NEG_INFINITY = {}&quot;, std::f64::NEG_INFINITY);

    // The radix or base of the internal representation of f64.
    println!(&quot;RADIX = {}&quot;, std::f64::RADIX);
}

</code></pre></pre>
<a class="header" href="print.html#aЧиcловые-операции" id="aЧиcловые-операции"><h4>Чиcловые операции</h4></a>
<p>Rust предоставляет основные математические операции с числовыми типами данных:</p>
<ul>
<li>сумма,</li>
<li>разность,</li>
<li>умножение,</li>
<li>деление,</li>
<li>остаток от деления.</li>
</ul>
<p>Пример их использования:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;

    println!(&quot;sum = {}&quot;, sum);
    println!(&quot;difference = {}&quot;, difference);
    println!(&quot;product = {}&quot;, product);
    println!(&quot;quotient = {}&quot;, quotient);
    println!(&quot;remainder = {}&quot;, remainder);
}

</code></pre></pre>
<p>Каждое из этих выражений использует математические операции и вычисляет значение,
которые присваивается переменной. Приложение 2 содержит список всех математических
операции языка Rust.</p>
<a class="header" href="print.html#aЛогический-тип-данных" id="aЛогический-тип-данных"><h4>Логический тип данных</h4></a>
<p>В языке Rust логический тип данных <code>bool</code> может принимать два значения - <code>true</code>
и <code>false</code>. Обратите внимание, что Rust чувствительный к регистру. Так что любые
вариации с регистром в константных величинах будут считаться ошибкой.</p>
<p>Пример использования:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

    let t = true;

    println!(&quot;t = {}&quot;, t);
    println!(&quot;!t = {}&quot;, !t);
    println!(&quot;t &amp;&amp; t= {}&quot;, t &amp;&amp; t);
    println!(&quot;t || t= {}&quot;, t || t);

    let f: bool = false; // with explicit type annotation

    println!(&quot;f = {}&quot;, f);
    println!(&quot;!t = {}&quot;, !t);
    println!(&quot;t &amp;&amp; t= {}&quot;, t &amp;&amp; t);
    println!(&quot;t || t= {}&quot;, t || t);
}

</code></pre></pre>
<p>Логические значение применяются в операторах сравнения <code>if</code>, <code>for</code>.</p>
<a class="header" href="print.html#aСимвольный-тип-данных" id="aСимвольный-тип-данных"><h4>Символьный тип данных</h4></a>
<p>В Rust поддерживается работа с символьным типом данных <code>char</code>.
Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let c:char = 'z';
  let z = 'ℤ';
  let heart_eyed_cat = '😻';
  println!(&quot;c = {}&quot;, c);
  println!(&quot;z = {}&quot;, z);
  println!(&quot;heart_eyed_cat = {}&quot;, heart_eyed_cat);
}
</code></pre></pre>
<p>Размер для хранения одного символа составляет 4 байта.
Символьный тип поддерживает Юникод. Поддерживаются сложные символьные-юникод структуры,
такие как символы с ударением, китайские/японские/корейские иероглифы, смайлики
и другие возможные символы. Внутреннее представление символов не соответствует концепции
юникода. Подробнее об этом можно ознакомиться в главе 8.</p>
<a class="header" href="print.html#aСложные-типы-данных" id="aСложные-типы-данных"><h3>Сложные типы данных</h3></a>
<p><em>Сложные типы данных</em> - это группа множества значений объединённых в один тип данных.
В Rust существует два способа описания такого рода объединения типов. Это кортежи
(упорядоченный набор фиксированной длинны) и массивы.</p>
<a class="header" href="print.html#aГруппировка-значений-в-кортежи-tuples" id="aГруппировка-значений-в-кортежи-tuples"><h4>Группировка значений в кортежи (Tuples)</h4></a>
<p>Кортеж - это способ группировки множества различные типов значений в один сложный
тип.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    println!(&quot;tup = {:?}&quot;, tup);
}
</code></pre></pre>
<p>Присвоение множеству переменных содержание кортежа:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of (x,y,z) is: ({},{},{})&quot;, x, y, z);
}

</code></pre></pre>
<p>Есть ещё один способ доступа к содержанию кортежа - по индексу - с помощью <code>.</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let x: (i32, f64, u8) = (500, 6.4, 1);
  let v1 = x.0;
  let v2 = x.1;
  let v3= x.2;

  println!(&quot;The value of (x,y,z) is: ({},{},{})&quot;, v1,v2,v3);
}
</code></pre></pre>
<p>Обратите внимание, каким образом были определены типы данных кортежа.</p>
<a class="header" href="print.html#aМассивы" id="aМассивы"><h4>Массивы</h4></a>
<p>Массивы отличаются от кортежей большими ограничениями. В массиве все значения
имеют одинаковый тип данных. Также важной особенностью массивов является их размер.
Он фиксируется при создании и не может быть изменён.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
    let b: [u8; 5] = [1, 2, 3, 4, 5];
    println!(&quot;a is: {:?}&quot;, a);
    println!(&quot;b is: {:?}&quot;, b);
}
</code></pre></pre>
<p>Обратите внимание на тип скобок в выражении инициализации массива - они квадратные.
В стандартной библиотеке есть тип данных, аналогичный массиву, но имеющий возможность
изменения содержания - это вектор.</p>
<p>Массивы подходят для хранения группы данных, состав и значения которых заранее
известны:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
           &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
println!(&quot;a is: {:?}&quot;, months);
#}</code></pre></pre>
<a class="header" href="print.html#aОрганизация-доступа-к-элементам-массива" id="aОрганизация-доступа-к-элементам-массива"><h5>Организация доступа к элементам массива</h5></a>
<p>Массив - это непрерывная область памяти, содержащаяся в стеке. Вы можете получить
доступ к какому-либо элементу по его индексу:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];

    println!(&quot;first = {}, second = {}&quot;, first, second);
}

</code></pre></pre>
<a class="header" href="print.html#aОшибка-доступа-к-элементу-массива" id="aОшибка-доступа-к-элементу-массива"><h5>Ошибка доступа к элементу массива</h5></a>
<p>При попытке доступа к несуществующему индексу массива - программа аварийно завершиться.
Важной особенностью языка Rust является предотвращения доступа к памяти, если
произошла ошибка какого-либо рода. Для системного языка программирования это большой
плюс, т.к. существует возможность на уровне языка предотвратить несанкционированный
доступ к памяти.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre>
<p>Описание ошибки при запуске этой программы:</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>В главе 9 будет подробно рассказано об возможных реакциях на ошибку.</p>
<a class="header" href="print.html#aКак-работают-функции" id="aКак-работают-функции"><h2>Как работают функции</h2></a>
<p>Функция - это ключевые части Rust кода. Вы, конечно, знакомы с самой важной функцией.
Это функция <code>main</code>, которая является точкой входа в программу. Также вы уже познакомились
с ключевым словом <code>fn</code> - обозначающее начало объявления функции.</p>
<p>В Rust используется т.н. &quot;змеиный&quot; стиль написания функций и переменных: это когда
все слова пишутся в нижнем регистре и слова в многословных обозначениях разделяются
нижним подчёркиванием. Пример объявления функции:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Обозначение функции состоит из группы скобок после имени функции. В фигурных скобках
заключено тело функции.</p>
<p>Мы можем вызвать функцию по её имени. Обратите внимание, что мы можем объявить функцию
как после, так и до её вызова.</p>
<p>Давайте рассмотрим работы с функциями на практическом примере. Пожалуйста, создайте,
проект <em>functions</em>.  Пожалуйста выполните код программы. Сейчас мы рассмотрим
содержания строки вывода.</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>Как вы видите, код программы выполняется последовательно. Сначала выполняется печать
текста, а потом вызывается функция, которая также выводит на печать текст.</p>
<a class="header" href="print.html#aПараметры-функции" id="aПараметры-функции"><h3>Параметры функции</h3></a>
<p>При объявлении функции могут быть определены входные параметры. Конкретные значения,
которые посылаются в функцию, называются аргументами.</p>
<p>Пример определения функции с параметром:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Работа программы в терминальной строке:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>Обратите внимание на описание параметра <code>x</code> при объявлении функции <code>another_function</code>.
Тип параметра <code>i32</code>. Когда аргумент функции <code>5</code> передаётся на вход, это значение используется
в её теле.</p>
<p>При объявлении нескольких входных параметров, они разделяются запятыми:</p>
<p><span class="filename">Файл: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>Думаю, что тут всё ясно и понятно и подробные разъяснения излишни.</p>
<p>Работа кода <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<a class="header" href="print.html#aВнутреннее-содержание-функций" id="aВнутреннее-содержание-функций"><h3>Внутреннее содержание функций</h3></a>
<p>Важной особенностью Rust является тот факт, что в язык разделяет понятия операторы
и выражения. Последующий материал поможет во всём этом разобраться.</p>
<a class="header" href="print.html#aВыражения-и-высказывания" id="aВыражения-и-высказывания"><h3>Выражения и высказывания</h3></a>
<p>Операторы (<em>Statements</em>) - это инструкци, которые выполняют действия, но не возвращают
значение. Выражения возвращают значение.</p>
<p>Рассмотрим использование этого теоритического материала на примере.</p>
<p>Создадим переменную и присвоим ей значение. <code>let y = 6;</code> - это оператор (a statement).</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Listing 3-3: Объявление функции <code>main</code>, содержащей один оператор.</span></p>
<p>Исходя из вышесказанного, оператор не может быть присвоен переменной:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>Это код с ошибкой:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p>Это важное отличие от других языков программирования.</p>
<p>В нашем примере <code>let y = 6</code>, <code>6</code> - это выражение, которое возвращает конкретное
значение. Вызов функции, макроса, блок кода - это всё выражения.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>Блок кода (варажение):</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>возвращающий <code>4</code>. Возвращаемое значение присваивается переменной <code>y</code>. Обратите внимание,
что выражения не заканчиваются символом <code>;</code>. Если вы добавите к выражению символ
<code>;</code> - это оно превратиться в оператора.</p>
<a class="header" href="print.html#aФункции-возвращающие-значения" id="aФункции-возвращающие-значения"><h3>Функции возвращающие значения</h3></a>
<p>Функции могут возвращать значения. Определение возвращаемых значений следует после
символа <code>-&gt;</code>. Возвращаемым значением функции является последнее выражение. Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Обратите внимание на тело функции <code>five</code>! Функция имеет определение типа возвращаемого
значения. Внутри только выражение <code>5</code>. Этого достаточно для корректной работы функции:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>Обратите внимание, что возвращаемое значение функции присваевается переменной при
её инициализации:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>Рассмотрим ещё один пример::</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Будет выведена строка <code>The value of x is: 6</code>. Какое значение будет присвоено
переменной, если в конце выражения будет символ <code>;</code>? Давайте проверим:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Будуте ошибка при компиляции с весьма доходчивым описанием, как же эту ошибку можно
исправить:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -&gt; i32 {
  |  ____________________________^
8 | |     x + 1;
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
help: consider removing this semicolon:
 --&gt; src/main.rs:8:10
  |
8 |     x + 1;
  |          ^
</code></pre>
<p>Для того, чтобы исправить ошибку просто удалите символ <code>;</code>.</p>
<a class="header" href="print.html#aКомментарии" id="aКомментарии"><h2>Комментарии</h2></a>
<p>Все хорошие программисты, создавая программный код, стремятся сделать его простым
и понятным. Бывают всё же случаи, когда дополнительное описание просто необходимо.
В этих случаях программисты пишут заметки (или как их ещё называют, комментарии).
Комментарии игнорируются компилятором, но для тех кто код читает - это очень важная
часть документации.</p>
<p>Пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Hello, world.
#}</code></pre></pre>
<p>Самый простой вид комментария - это комментарий строки <code>//</code>. Он ставится там, где
вся последующая строка текста должна быть игнорирована компилятором:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
#}</code></pre></pre>
<p>Ещё пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today.
}
</code></pre></pre>
<p>Ещё пример (комментарий-аннотация):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // I’m feeling lucky today.
    let lucky_number = 7;
}
</code></pre></pre>
<a class="header" href="print.html#aУправление-выполнением-кода" id="aУправление-выполнением-кода"><h2>Управление выполнением кода</h2></a>
<p>Решение выполнять ту или иную часть кода зависит от логических условий. Конструкция
<code>if</code> и циклы является в Rust такими управляющими выражениями.</p>
<a class="header" href="print.html#if-выражения" id="if-выражения"><h3><code>if</code>-выражения</h3></a>
<p>if`-выражение позволяет создавать ветви кода работающие при соблюдение определенных
логических условий.</p>
<p>Создадим новый проект <em>branches</em> и добавить следующий код:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Все <code>if</code>-выражения начинаются с ключевого слова <code>if</code>. Далее следует логическое выражение.
При необходимости, после тела блока <code>if</code> может следовать <code>else</code>-выражение.</p>
<p>Результат работы программы:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Если изменить значение переменной на большее, например на <code>7</code> программа выполнит
другую ветвь кода:</p>
<pre><code class="language-rust ignore">let number = 7;
</code></pre>
<p>Результат работы программы:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
condition was false
</code></pre>
<p>Тип <code>if</code>-выражение должен быть логическим:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p>Иначе будет ошибка при компиляции:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<p>В Rust нельзя автоматически конвертировать в <code>bool</code> тип данных. Исправим ошибку
в коде:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>Будет выведено следующая строка <code>number was something other than zero</code>.</p>
<a class="header" href="print.html#aИспользование-выражений-else-if" id="aИспользование-выражений-else-if"><h4>Использование выражений <code>else if</code></h4></a>
<p><code>if</code>-выражения могут быть достаточно сложными. Например:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>Результат работы программы:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>Для кода с большим количеством <code>else if</code>-выражений большое подойдёт конструкция <code>match</code>.
О ней мы расскажем в главе 6.</p>
<a class="header" href="print.html#aИспользование-if-в-let-операторах" id="aИспользование-if-в-let-операторах"><h4>Использование <code>if</code> в <code>let</code>-операторах</h4></a>
<p>По определению выражений, мы можем их использовать в операторах.
Пример, Listing 3-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p><span class="caption">Listing 3-4: Присвоение результата <code>if</code>-выражения переменной
при её инициализации</span></p>
<p>Результат работы программы:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Обратите внимание, что у данной инициирующей конструкции есть ограничения. Все возвращаемые
значения <code>if</code>-выражения должны иметь один тип данных.
Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<p>Результат работы программы:</p>
<pre><code class="language-text">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integral variable, found reference
  |
  = note: expected type `{integer}`
             found type `&amp;'static str`
</code></pre>
<p>Такое поведение кода делает вашу работу предсказуемой и хранить от потенциальных
ошибок.</p>
<a class="header" href="print.html#aПовторение-выполнения-кода-с-помощью-циклов" id="aПовторение-выполнения-кода-с-помощью-циклов"><h3>Повторение выполнения кода с помощью циклов</h3></a>
<p>Для многократного выполнения кода существуют <em>циклы</em>. В Rust существует несколько
видов циклов. Создадим проект <em>loops</em>.</p>
<p>Виды циклов: <code>loop</code>, <code>while</code> и <code>for</code>. Рассмотрим каждый в отдельности.</p>
<a class="header" href="print.html#loop" id="loop"><h4><code>loop</code></h4></a>
<p>Ключевое слово тело <code>loop</code> - это бесконечный цикл.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>Остановить выполнения кода можно лишь аварийно завершив работу программы сочетанием
клавиш <span class="keystroke">ctrl-C</span>.</p>
<p>Пример:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>Существует ключевое слово <code>break</code>, благодаря которому можно остановить работу бесконечного
цикла.</p>
<a class="header" href="print.html#while" id="while"><h4><code>while</code></h4></a>
<p>Цикл с условием <code>while</code> выполняет тело пока выполняется логическое условие параметра.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number = number - 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<a class="header" href="print.html#for" id="for"><h4><code>for</code></h4></a>
<p>Использование <code>while</code>-цикла для перебора элементов массива:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index = index + 1;
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-5: Перебор элементов массива с помощью цикла <code>while</code> loop</span></p>
<p>Этот код выполняет тело цикла пока переменная <code>index</code> меньше 5:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>Такой код выполняется весьма медленно и никак не защищён от ошибки во время работы
программы. Для этих целей больше подходит другая конструкция - <code>for</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-6: Перебор элементов коллекции с помощью цикла
<code>for</code></span></p>
<p>Данный код более защищён от ошибок.</p>
<p>Безопасный цикл <code>for</code> наиболее часто используется в Rust.</p>
<p>Реализация обратного осчёта в Rust:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<a class="header" href="print.html#summary" id="summary"><h2>Summary</h2></a>
<p>Вы познакомились с конструкциями управления ходом выполнения программы, а также с
рекомендациями разработчиков Rust.
Для закрепления изученного материала мы предлагаем написать следующие программы:</p>
<ul>
<li>Конвертер температур из Фаренгейта в Цельсий.</li>
<li>Генератор чисел Фибоначчи.</li>
<li>Генератор строк сказки &quot;12 дней Рождества&quot;.</li>
</ul>
<p>В следующей главе мы расскажем о владении - концепции языка программирования Rust.</p>
<a class="header" href="print.html#aВладение" id="aВладение"><h1>Владение</h1></a>
<p>Владение является очень важной особенностью языка Rust, благодаря которой осуществляется
безопасная работа с памятью без необходимости наличия автоматической системы отслеживания,
выделения и удаления ресурсов памяти. Для эффективного программирования на Rust
понимание этой темы очень важно! В этой главе мы расскажем о владении, а также затронем
связанные с ним возможности, такие как заимствование, срезы, а также как Rust
распределяет данные в памяти.</p>
<a class="header" href="print.html#aЧто-же-такое-владение" id="aЧто-же-такое-владение"><h2>Что же такое владение?</h2></a>
<p><em>Владение</em> является весьма важной концепцией Rust. Неудивительно, что она весьма сильно
повлияла на язык программирования в целом.</p>
<p>Существуем множество решений по управлению памятью во время работы программ.
Это системы сборки мусора (куча), ручное управление выделенными ресурсами. Rust предлагает
своё решение: управление ресурсами осуществляется по средством набора правил владения,
которые компилятор проверяет во время создания программы (компиляции). Благодаря
этому отсутствует необходимость управления памятью во время работы программы.
Звучит весьма заманчиво, неправда ли?! Об этом так давно мечтали в равной степени,
как программисты Си, так и Java.</p>
<p>Так как эта концепция ещё нова для многих программистов, её осознание и эффективное
использование потребует определённых навыков. Наградой будет владением инструментом
для создания безопасных и эффективных программы. Думаю, что данная цель того стоит.</p>
<p>Понимание концепции владениия даст вам основу для понимания всех остальных особенностей
Rust. В этой главе вы будите изучать владение на примере работы с строковым типом
данных.</p>
<!-- PROD: START BOX -->
<blockquote>
<a class="header" href="print.html#aСтек-и-куча" id="aСтек-и-куча"><h3>Стек и куча</h3></a>
<p>Во многих языках программирования не принято уделять много внимания организации
работы с памятью. Для системного языка программирование эта тема весьма важна.
Место хранения переменной (это стек или куча) очень важно. Это весьма сильно
влияет на языковые конструкции и рекомендуемых шаблоны.</p>
<p>Хотя и стек и куча - это всё части доступной для программ области памяти, но их
структура и способы взаимодействия с ними различна. Стек сохраняет значения в
порядке получения и удаляет их в противоположном порядке (LIFO - <em>last in, first out</em>).
Стек подобен стопке тарелок. Вы накладываете тарелки сверху и когда нужно берёте
их сверху.</p>
</blockquote>
<blockquote>
<p>Работа со стеком даёт большой выигрыш по времени, т.к. нет необходимости в системе
поиска нужных данных, а также все сохраняемые там данные имеют известный размер.</p>
<p>Для тех данных, размер которых не известен во время компиляции используется другое
место хранения - куча. В куче нет чёткой организации данных. Когда вы сохраняете
данные в куче, вы запрашиваете произвольный размер памяти. Операционная система
ищет необходимый блок и предоставляет ссылку на его начало. Этот процесс называется
<em>выделение памяти в куче</em>. Или просто <em>выделение памяти</em>.</p>
<p>Система выделения памяти работает медленнее стека, т.к. мы должны затратить время
на поиск места в памяти.</p>
<p>Когда код вызывает функцию, все локальные переменные сохраняются в стеке,
когда функция прекращает работу все её переменные удаляются из стека.</p>
<p>Отслеживание какая часть кода использует данные из кучи, минимизирует дублирование
и удаляет ненужное. Это приводит к эффективному расходованию системных ресурсов.
Когда вы разберётесь с концепцией владения вы не будете думать о стеке и куче,
но всё же понимание как эти системы распределения памяти работают поможет более
глубоком пониманию теоретического материала.</p>
</blockquote>
<!-- PROD: END BOX -->
<a class="header" href="print.html#aПравила-владения" id="aПравила-владения"><h3>Правила владения</h3></a>
<p>Прежде всего, давайте познакомимся с самими правилами. Пожалуйста, помните о них
во время практической работы с примерами программ:</p>
<blockquote>
<ol>
<li>Каждое значение имеет переменную, которая ей владеет, т.е. имеет <em>владельца</em>.</li>
<li>Одновременно, у значения может быть только один владелец.</li>
<li>Когда переменная выходит за область видимости, значение удаляется.</li>
</ol>
</blockquote>
<a class="header" href="print.html#aОбласть-видимости-переменной" id="aОбласть-видимости-переменной"><h3>Область видимости переменной</h3></a>
<p>Для объяснения области видимости мы абстрагируемся о какого-либо контейнера.
Будем считать, что код находится в каком-то контейнере, например, внутри определения
функции <code>main</code>.</p>
<p>Рассмотрим область видимости переменной. Область видимости - это область, в которой
с переменной можно осуществлять какие-либо действия. Сначала объявим переменную:</p>
<pre><code class="language-rust ignore">let s = &quot;hello&quot;;
</code></pre>
<p>Переменная <code>s</code> ссылается на строковый литерал. Значение данной переменной вписано
в код программы. Переменная считается действительной с момента её объявления до
конца текущей области видимости.</p>
<p>Два важных замечания:</p>
<ol>
<li>Когда переменная <code>s</code> появляется в области видимости она считается действительной.</li>
<li>Она остаётся действительно до момента выхода за границы этой области.</li>
</ol>
<p>Отталкиваясь от понимания этих замечаний мы переходим к объяснению более сложной
концепции.</p>
<a class="header" href="print.html#aТип-данных-string" id="aТип-данных-string"><h3>Тип данных <code>String</code></h3></a>
<p>Для объяснения правил владения, рассмотрим более сложный тип данных. До сих пор
мы рассматривали типы данных, которые хранились в стеке. Теперь рассмотрим данные,
которые хранятся в куче и рассмотрим, как Rust узнаёт, когда можно удалить данные.</p>
<p>Мы будем использовать тип данных <code>String</code> и рассмотрим ту часть описания данного
типа, которая связана с владением. Владение работает таким же образом и других
типах данных. Более подробно мы познакомимся с типом данных <code>String</code> в главе 8.</p>
<p>Мы уже видели работу со строковыми литералами в предыдущих главах, где значение
строк было вписано в код программы. Строковые литералы удобны для использования,
но не могут решить всех вопросов при работе с этим типом данных. Важной особенностью
строковых литералов является их неизменяемость. Для работы с текстовыми данными,
когда их значение и размер заранее не известен (например, при вводе данных с клавиатуры),
используется тип данных <code>String</code>. Данные этого типа хранятся в куче. Размер
таких данных неизвестен в момент компиляции. Вы можете создать переменную данного
типа с помощью статической функции <code>from</code>:</p>
<pre><code class="language-rust ignore">let s = String::from(&quot;hello&quot;);
</code></pre>
<p>Двойное двоеточие (<code>::</code>) - это оператор, которые определяет пространство имён типа.
В данному случает пространство имён типа <code>String</code>. Более подробно мы обсудим синтаксис
методов в главе 5. Пространство имён обсудим в главе 7.</p>
<p>Такие строки <em>могут</em> быть изменены:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String

    println!(&quot;{}&quot;, s); // This will print `hello, world!`
}

</code></pre></pre>
<p>В чём же отличия типов данных изменяемых строковых <code>String</code> и неизменяемых литеральных?
Отличия в способе работы с памятью.</p>
<a class="header" href="print.html#aПамять-и-способы-ещё-выделения" id="aПамять-и-способы-ещё-выделения"><h3>Память и способы ещё выделения</h3></a>
<p>Тот факт, что значение литеральных типов известно в момент компиляции делает работу
с ними таким эффективным. К сожалению, мы не можем заранее выделить часть памяти
для хранения данных неизвестного типа и размера.</p>
<p>Для хранения таких данных (таких как данные типа <code>String</code>) наиболее удобно использовать
кучу. Это значит, что:</p>
<ol>
<li>Размер необходимой памяти запрашивается программой в момент её выполнения.</li>
<li>Необходим механизм возвращения неиспользуемой памяти обратно операционной системе.</li>
</ol>
<p>Первый пункт этого списка решается с помощью метода типа <code>String::from</code>. Это довольно-таки
универсальное решение.</p>
<p>Но второй пункт довольно-таки специфичен для каждой системы (языка программирования,
технологии). Там где используется сборщики мусора. Там где нет сборщиков мусора
программист сам должен отслеживать использование ресурсов и явным образом их освобождать.
Исторически, корректное освобождение ресурсов - источник ошибок и одна из проблем
в программировании.  Если данные не удаляются своевременно, это приводит к бесполезному
расходованию ресурсов.  Если данные удаляются, а часть переменных программы ссылается
на них - это приводит к сбоям. Повторное возвращение данных операционной системе
также приводит к ошибкам. Мы можем один раз получить и один раз возвратить ресурсы.</p>
<p>Rust предлагает решение этой проблемы - ресурсы памяти возвращаются автоматически,
когда переменная вышла за область видимости. Пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;hello&quot;); // s is valid from this point forward

    // do stuff with s
}                                  // this scope is now over, and s is no
                                   // longer valid
#}</code></pre></pre>
<p>Это довольно-таки естественные способ освобождение неиспользованной памяти. Когда
переменная выходит за рамки области видимости, Rust вызывает специальную функцию
для освобождения памяти. Эта функция называется <code>drop</code>. Можно сказать, что это последний
оператор в любой области видимости.</p>
<blockquote>
<p>Обратите внимание: В C++, такой шаблон освобождения ресурсов называется
<em>Получение ресурса есть инициализация</em> (<em>Resource Acquisition Is Initialization (RAII)</em>).
Функция <code>drop</code> будет вам понятная, если у Вас уже есть опыт использования данного
шаблона при программировании на C++.</p>
</blockquote>
<p>Это шаблон сильно влияет на стиль, способ создания программ на Rust. Поведение программы
может быть непредсказуемым, когда необходимо нескольким переменным использовать
данные из кучи. Рассмотрим эту ситуацию подробнее:</p>
<a class="header" href="print.html#aСпособы-взаимодействия-переменных-и-данных-перемещение" id="aСпособы-взаимодействия-переменных-и-данных-перемещение"><h4>Способы взаимодействия переменных и данных: перемещение</h4></a>
<p>Несколько переменных может взаимодействовать с одними и теме же данными различными
способами. Listing 4-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">Listing 4-2: Присваивание целочисленного значения переменной
<code>x</code>переменной <code>y</code></span></p>
<p>Вы, конечно, можете догадаться, что же тут происходит. Переменной <code>x</code> присваивается
значение <code>5</code>. Потом создаётся копия этого значения, которая присваивается переменной
<code>y</code>. После выполнения этих строчек кода обе переменные будут иметь значение <code>5</code>.
Эти переменные имеют простой тип данных и известные в момент компиляции значения.
Вся данные хранятся в стеке.</p>
<p>Теперь рассмотрим этот же пример с другим типом данныx (<code>String</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>Хотя код внешне выглядит таким же, алгоритм работы совсем иной.</p>
<p>Для более подробного объяснения давайте рассмотрим структуру <code>String</code> (рисунок 4-3).
<code>String</code> состоит из трёх частей: ссылки а память, которая содержит данные, длину
и ёмкость. Эта группа данных сохраняется в стеке. Справа память кучи, которая
содержит данные.</p>
<p><img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-3: Представление переменной <code>s1</code> в памяти, имеющей
тип данных <code>String</code>, содержащей значение <code>&quot;hello&quot;</code></span></p>
<p>Длина (в байтах) содержит величину данных, которое в данных момент используется.
Ёмкость - это общее количество памяти (в байтах), которое переменная получила от
операционной системы. Разница между длинной данных и ёмкостью, конечно имеет значение,
но для объяснение взаимодействия переменной и памяти эта информация никак не повлияет.
Пока проигнорируем эту разницу.</p>
<p>При присваивании переменной <code>s1</code> переменной <code>s2</code> данные типа копируются в стеке,
т.е. копируются данные о ссылке, длине и ёмкости. Представления данных в памяти
выглядит следующим образом (Рисунок 4-4).</p>
<p><img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок  4-4: Представление в памяти переменной <code>s2</code>
которая содержит копию ссылки, длинны и ёмкости переменной <code>s1</code></span></p>
<p>Это представление отличается от того, если бы копировалось всё содержимое кучи.
Если бы Rust позволял это делать, операция присваивания <code>s2 = s1</code> могла быть очень
затратной (по скорости её выполнения), если бы ёмкость копируемых данных и их сложность
была высокой.</p>
<p><img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Рисунок 4-5: Другая возможность при копировании <code>s2 = s1</code>  -
копирование содержимого кучи</span></p>
<p>Ранее, мы говорили, что когда переменная выходит за границы области видимости, Rust
автоматически вызывает метод <code>drop</code> и очищает память кучи для этой переменной. Рисунок
4-4 показывает, что имеется две ссылки на одни данные. Это является проблемой и
источником потенциальной ошибки, т.к. переменные <code>s2</code> и <code>s1</code> обе вышли за границы
области видимости и ссылаются на одни и те же данные. Это ошибка называется
<em>двойная очистка</em>. Такая двойная очистка может быть причиной повреждения данных
в памяти, что в свою очередь может привести к проблемам безопасности.</p>
<p>Для обеспечения безопасности памяти, существует решение. Вместо копирования выделенной
памяти, Rust считает переменную <code>s1</code> недействительной. Кроме того т.к. переменная не
является действительной, то она не должна ничего освобождать. Пожалуйста, проверьте,
что произойдёт, когда вы попытаетесь использовать переменную <code>s1</code> после создания
<code>s2</code>:</p>
<pre><code class="language-rust ignore">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
    println!(&quot;{}, world!&quot;, s2);
}

</code></pre>
<p>В терминальной строке вы увидите подобное сообщение, информирующее о том, что переменную
<code>s1</code> уже нельзя использовать:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:4:27
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
which does not implement the `Copy` trait
</code></pre>
<p>Вы, наверное, уже слышали о разных вариациях копирования. Концепция копирования в Rust
может показать похожей на одну из них. Но у Rust есть существенное отличие - копируемая
переменная становится недействительной после операции копирования в другую переменную.
Эта операция называется перемещением. Так что можно сказать, что переменная <code>s1</code>
была перемещена в переменную <code>s2</code>. То, что действительно произошло показано на рисунке
4-6.</p>
<p><img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-6: Состояние памяти после перемещения переменной <code>s1</code></span></p>
<p>Это решает проблему множественного доступа к памяти в куче. Такой проблемы
просто нет. Только одна переменная действительна имеет права на данные - это переменная
<code>s2</code>.</p>
<p>Также обратите внимание, что Rust никогда не делает полного копирования данных.
Поэтому любое автоматическое копирование может быть недорогим с точки зрения производительности.</p>
<a class="header" href="print.html#aСпособы-взаимодействия-переменныx-и-данных-клонироване" id="aСпособы-взаимодействия-переменныx-и-данных-клонироване"><h4>Способы взаимодействия переменныx и данных: клонироване</h4></a>
<p>Если вы действительно хотите глубокого копирования данных в куче типа данных <code>String</code>,
вы можете использовать метод <code>clone</code>. Мы подробнее расскажем о синтаксисе этого
метода в главе 5.</p>
<p>Пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>Этот метод копирования замечательно работает и это способ, который вы можете использовать,
чтобы добиться поведения описанного на рисунке 4-5 (где данные кучи были скопированы).</p>
<p>Когда в исходном коде программы вы встречаете использование метода <code>clone</code> знайте,
что использование этого метода может быть затратным по производительности.</p>
<a class="header" href="print.html#aСтековые-данные-Копирование" id="aСтековые-данные-Копирование"><h4>Стековые данные: Копирование</h4></a>
<p>Это ещё одна особенность о которой мы ещё не говорили. Этот код использует целые
числа, часть которого была показа ранее в листинге 4-2. Этот код работает и не имеет
ошибок:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Но этот код кажется противоречит тому, что мы только что изучили: мы не должны
вызывать <code>clone</code>, но <code>x</code> остаётся действительной переменнной и не перемещается в <code>y</code></p>
<p>В Rust есть специальная аннотация <code>Copy</code> типаж, благодаря которой любой тип может
быть сохранён в стеке. Если тип имеет типаж <code>Copy</code>, переменные которые владели данными
до текущей переменной остаются доступными. Rust имеет следующие ограничения: тип не может
одновременно иметь типаж <code>Copy</code> и <code>Drop</code>. Любая группа скалярных значений может быть
<code>Copy</code>.</p>
<p>Список типов, которые имею типаж <code>Copy</code>:</p>
<ul>
<li>Все целочисленные типы, такие как <code>u32</code>.</li>
<li>Логический тип данных <code>bool</code>, значения которых <code>true</code> и <code>false</code>.</li>
<li>Все числа с плавающей запятой такие как <code>f64</code>.</li>
<li>Кортежи, но только если они содержат типы, которые также <code>Copy</code>. <code>(i32, i32)</code>
<code>Copy</code>, но <code>(i32, String)</code> нет.</li>
</ul>
<a class="header" href="print.html#aВладение-и-функции" id="aВладение-и-функции"><h3>Владение и функции</h3></a>
<p>Симантически передача значений в функцию схожа с присвоением значения переменной.
Переменная, которая передаётся в функцию будет перемещаться или копироваться. Пример
кода 4-7 демонстрирует как переменные входят и выходят из области видимости:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s comes into scope.

    takes_ownership(s);             // s's value moves into the function...
    //println!(&quot;{}&quot;, s);    // ... and so is no longer valid here.
    let x = 5;                      // x comes into scope.

    makes_copy(x);                  // x would move into the function,
    println!(&quot;{}&quot;, x);              // but i32 is Copy, so it’s okay to still
                                    // use x afterward.

} // Here, x goes out of scope, then s. But since s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope.
    println!(&quot;{}&quot;, some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope.
    println!(&quot;{}&quot;, some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
</code></pre></pre>
<p><span class="caption">Listing 4-7: Демонстрация изменения владения посредством передачи
функции переменной. Демонстрация выхода переменной за пределы области видимости и
освобождения ресурсов</span></p>
<p>Если вы попытаетесь использовать переменную после вызова метода <code>takes_ownership</code>,
компилятор Rust сообщит вам об ошибке. При повторном использовании переменной
<code>x</code> всё будет в порядке.</p>
<a class="header" href="print.html#aВозвращения-данных-из-области-видимости" id="aВозвращения-данных-из-области-видимости"><h3>Возвращения данных из области видимости</h3></a>
<p>Возвращение значений также может переместить владение.
Пример 4-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1: String = gives_ownership();
    println!(&quot;{}&quot;,s1);                       // takes_and_gives_back, which also                                    // value into s1.

    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope.

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
    //println!(&quot;{}&quot;,s2);                                    // takes_and_gives_back, which also
    println!(&quot;{}&quot;,s3);                                    // moves its return value into s3.
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it.

    let some_string = String::from(&quot;hello&quot;); // some_string comes into scope.
    println!(&quot;{}&quot;,some_string);
    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function.
}

// takes_and_gives_back will take a String and return one.
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope.

    a_string  // a_string is returned and moves out to the calling function.
}
</code></pre></pre>
<p>Изменение владения ведётся по описанным ранее законам. Оно перемещается при изменении
владельца данных.</p>
<p>На практике очень неудобно всегда отслеживать владение данными.</p>
<p>При передаче данных в функцию и из функции, для упрощения работы, удобно использовать
кортежи:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String.

    (s, length)
}
</code></pre></pre>
<p>Было бы конечно сложно писать программы на Rust если бы это были бы все опции
доступные программисту при работе с владением памятью. К счастью, существуют
<em>ссылки</em>, которые упрощают эту работу.</p>
<a class="header" href="print.html#aСсылочные-переменные-и-заимствование" id="aСсылочные-переменные-и-заимствование"><h2>Ссылочные переменные и заимствование</h2></a>
<p>Необходимость использования кортежа в коде (в последнем примере предыдущей секции главы 4),
обусловлена дальнейшим использованием переменной типа <code>String</code>. Для этого мы должны
вернуть владение из метода обратно. Т.е. метод <code>calculate_length</code> помимо результата
должен вернуть входной параметр назад из функции.</p>
<p>А теперь приведём пример использования передачи в метод ссылки для решения этой задачи.
При таком решении, возвращать кортеж нет необходимости. Владение не будет передано
внутрь метода:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>Обратите внимание:</p>
<ol>
<li>Кортеж удалён из декларирования переменной и возвращаемых данных метода.</li>
<li>Переменная метода имеет ссылочный тип <code>&amp;String</code>.</li>
</ol>
<p><code>&amp;</code> обозначает что тип данных ссылочный и поэтому передавать владение не нужно.
Иллюстрация работы 4-8.</p>
<p><img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" /></p>
<p><span class="caption">Figure 4-8: <code>&amp;String s</code> ссылка на <code>String s1</code></span></p>
<p>Давайте подробнее рассмотрим механизм вызова функции:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn calculate_length(s: &amp;String) -&gt; usize {
#     s.len()
# }
let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
#}</code></pre></pre>
<p>Синтаксическая конструкция <code>&amp;s1</code> создаёт ссылку на переменную <code>s1</code>. Передачи ей
владения не происходит. Т.к. нет передачи владения, переменная не удаляется из
области видимости, её статус не изменяется.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, nothing happens.
#}</code></pre></pre>
<p>Важное замечание - переменные ссылочного типа никогда не имеют владения, поэтому
не влияют на него.</p>
<p>В Rust передача ссылки в функцию в качестве параметра называется заимствованием.
Всё как в жизни, после того как что-то взято на время, потом надо это отдать.</p>
<p>А что произойдёт, если попытаться изменить то, что было заимствовано? Проверим на
примере 4-9 (предупреждение - это код с ошибкой):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">Listing 4-9: Попытка модификации заимствованной переменной</span></p>
<p>Here’s the error:</p>
<pre><code class="language-text">error: cannot borrow immutable borrowed content `*some_string` as mutable
 --&gt; error.rs:8:5
  |
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^
</code></pre>
<p>Как и переменные, ссылочные переменные неизменяемые. Т.е. изменять данные ссылки
нельзя.</p>
<a class="header" href="print.html#aИзменяемые-ссылочные-данные" id="aИзменяемые-ссылочные-данные"><h3>Изменяемые ссылочные данные</h3></a>
<p>Для того, чтобы исправить ошибку в предыдущем примере 4-9 необходимо сделать небольшие
изменения в коде:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
    println!(&quot;{}&quot;, s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}

</code></pre></pre>
<p>Для того, чтобы данные ссылочной переменной можно было изменить, также как и обычную
переменную её надо сделать изменяемой при инициализации. Это делается с помощью
префикса <code>mut</code>. В данному случае, в качестве параметра функции нужно написать <code>&amp;mut s</code>.</p>
<p>Изменяемое ссылочная переменная имеет значительное ограничение: у одной переменной
может быть только одна изменяемая ссылочная переменная в данной области видимости.
Такой код не будет скомпилирован:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}&quot;, r1);
    println!(&quot;{}&quot;, r2);
}


</code></pre></pre>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; borrow_twice.rs:5:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
6 | }
  | - first borrow ends here
</code></pre>
<p>Это ограничение позволяет изменять данные, но в тоже время позволяет всё держать
под контролем. Это немного удивляет, но всё это сделано для минимизации ошибок.</p>
<p>Это ограничение не даёт появлению эффекта гонки. Ошибки такого рода трудноуловимы
и сложны.</p>
<p>Создание вложенных областей видимости, может быть полезным (при необходимости).</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
        println!(&quot;{}&quot;, r1);
    }
    {
        let r2 = &amp;mut s;
        println!(&quot;{}&quot;, r2);
    }
}
</code></pre></pre>
<p>Подобное правило действительно и для комбинации изменяемых и неизменяемых
ссылочных переменных. Пример кода с ошибкой:</p>
<pre><pre class="playpen"><code class="language-rust">
fn main() {
    let s = String::from(&quot;hello&quot;);
    let r1 = &amp;s; // все нормально
    let r2 = &amp;s; // все нормально
    let r3 = &amp;mut s; // ОШИБКА
    println!(&quot;{}&quot;, r1);
    println!(&quot;{}&quot;, r2);
    println!(&quot;{}&quot;, r3);
}
</code></pre></pre>
<p>Ошибка:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
 --&gt; borrow_thrice.rs:6:19
  |
4 |     let r1 = &amp;s; // все нормально
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // все нормально
6 |     let r3 = &amp;mut s; // ОШИБКА
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Обратите внимание, что вы не можете иметь изменяемой ссылочной переменной пока
существует изменяемая переменная.  Наличие множества неизменяемых переменных допускается,
т.к. они не могут изменить данные.</p>
<p>Статической анализатор кода помогает предотвратить таким образом возможные скрытые
ошибка в коде. Такие ошибки легко устранить.</p>
<a class="header" href="print.html#aНедействительный-ссылки" id="aНедействительный-ссылки"><h3>Недействительный ссылки</h3></a>
<p>Работая с ссылками весьма легко создать недействительную ссылку или ссылку на
участок памяти, который уже или ещё используется другими переменными приложения.
Rust компилятор гарантирует защиту от создания подобных ссылок.</p>
<p>Попытаемся смоделировать подобную ошибку и посмотрим как с ней справится компилятор:
Давайте создадим висячую ссылку:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
    println!(&quot;{}&quot;, reference_to_nothing);
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);
    &amp;s
}

</code></pre>
<p>Текст в строке терминала:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; dangle.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^^^^^^^
  |
  = help: this function's return type contains a borrowed value, but there is no
    value for it to be borrowed from
  = help: consider giving it a 'static lifetime

error: aborting due to previous error
</code></pre>
<p>Эта ошибка сообщает об ещё не освещённой нами опции языка Rust - <em>времени жизни переменной</em>.
Мы расскажем подробнее о этой опции в главе 10. Также компилятор сообщил кое-что
ещё:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<p>Давайте рассмотрим что же происходит во время работы кода, который создаёт недействительные
ссылки:</p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangle возвращает ссылку на String

    let s = String::from(&quot;hello&quot;); //создаётся новая переменная s типа String

    &amp;s // вы возвращаем ссылку на созданную строку. При выходе из области видимости

}
  // переменная становится недействительной и удаляется. Ссылка становится недействительной!
</code></pre>
<p>Т.к. переменная создаётся внутри метода, когда область действия метода заканчивается,
<code>s</code> удаляется. Но код метода пытается возвратить ссылку на эту недействительную
переменную. Это ошибка, которую компилятор Rust предотвращает.</p>
<p>Исправлением ошибки в данном случае будет возвращение из функции самой созданной
переменной, а не ссылки на неё:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
#}</code></pre></pre>
<p>Это решние прекрасно работает, т.к. соблюдаются правила владения.</p>
<a class="header" href="print.html#aПравила-работы-с-ссылками" id="aПравила-работы-с-ссылками"><h3>Правила работы с ссылками</h3></a>
<p>Список правил:</p>
<ol>
<li>В одной области видимости единовременно может существовать только один тип ссылочных переменных на одни данные:</li>
</ol>
<ul>
<li>одна изменяемая ссылка на данные,</li>
<li>любое количество неизменяемых ссылок на данные.</li>
</ul>
<ol start="2">
<li>Все ссылки должны быть действительными.</li>
</ol>
<p>Сейчас вы рассмотрели ссылку на данные (на переменную).
В следующей главе мы рассмотрим другой тип ссылочных переменных - динамические массивы.</p>
<a class="header" href="print.html#aДинамические-массивы" id="aДинамические-массивы"><h2>Динамические массивы</h2></a>
<p><em>Динамический массив</em>  - это ссылочный тип не использующий владение.
Это непрерывная коллекция упорядоченных элементов.</p>
<p>Рассмотрим учебную задачу. Необходимо написать функцию, входным параметром которой
является строка. Выходным значением функции является первое слово, которое будет
найдено в этой строке. Если функция не находит разделителя слов (пробела), она
возвращает эту строку.</p>
<p>Прежде всего рассмотрим описание этой функции:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>Функция <code>first_word</code> имеет входной параметр типа <code>&amp;String</code>. Нам не нужно владение
переменной для её работы, так что это то что нам нужно. Для решения задачи мы можем
найти индекс конца строки в тексте. Вот как это можно сделать с помощью функции 4-10:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

fn main() {
    let index = first_word(&amp;String::from(&quot;hello, Nik!&quot;));
    println!(&quot;{}&quot;, index);
}

</code></pre></pre>
<p><span class="caption">Listing 4-10: Пример функции <code>first_word</code>, которая возвращает
index пробела в строке типа <code>String</code></span></p>
<p>Теперь давайте изучим код этой функции. Для нахождения пробела в строке
необходимо превратить в массив байтов используя метод <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Далее, используя метода массива <code>iter()</code> мы создаём объект для последовательного
перебора содержания массива - итератор. Далее, используя цикл <code>for</code>, мы перебираем
байты и анализируем каждый из них. Обратите внимание, что при каждой итерации мы
получаем индекс элемента и ссылку на него:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Мы будет изучать итераторы более детально в главе 13. Сейчас, достаточно понять,
что метод <code>iter</code>, который возвращает каждый элемент коллекции. Метод <code>enumerate</code>
передаёт результаты работы метода <code>iter</code> в кортеж. Первый элемент этого кортежа
возвращает индекс, второй элемент - ссылку на элемент. Такой способ перебора элементов
массива наиболее удобный.</p>
<p>Так как метод <code>enumerate</code> возвращает кортеж, мы можем использовать шаблон создающий
переменные, которые в дальнейшем можно использовать внутри тела цикла.</p>
<p>Нам надо найти байт, который представляет собой значение пробела. Для этого мы
приводим символьную константу ' ' к типу байт <em>b' '</em>. В выражении <code>if</code> мы сравниваем
полученное таким образом константное значение с текущим байтом из массива.</p>
<p>Если мы находим пробел, вы возвращаем позицию пробела. Иначе мы возвращаем длину
массива <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>Таким образом мы получаем искомое значение. Но оно может устареть в будущем  4-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn first_word(s: &amp;String) -&gt; usize {
#     let bytes = s.as_bytes();
#
#     for (i, &amp;item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word will get the value 5.

    s.clear(); // This empties the String, making it equal to &quot;&quot;.

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
</code></pre></pre>
<p><span class="caption">Listing 4-11: Сохранение результата вызова функции <code>first_word</code>,
потом изменяем содержимое переменной <code>s</code></span></p>
<p>Эта программа скомпилирует без всяких проблем.</p>
<p>Создадим ещё одну функцию, которая возвращает индексы начала и конца первого слова.
Вот как будет выглядеть её описание:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Обратите внимание, что весьма сложно удерживать в синхронном состоянии вcе эти переменные
(входящие и исходящие). Для этих целей существуют динамические массивы.</p>
<a class="header" href="print.html#aСтроковые-динамические-массивы" id="aСтроковые-динамические-массивы"><h3>Строковые динамические массивы</h3></a>
<p>Строковый динамический массив - это ссылка на часть строки <code>String</code> и её инициализация
выглядит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
#}</code></pre></pre>
<p>Эта инициализация похожа на создание ссылки на переменную <code>String</code>, но с дополнительными
условиями - указанием отрезка <code>[0..5]</code>. Вместо целой переменной мы получаем ссылку
на её часть. Начало и конец отрезка включено в динамический массив, а вот окончание
нет.</p>
<p>Мы можем создавать динамические массивы используя определение отрезка <code>[starting_index..ending_index]</code>.
Внутренне, переменная типа динамический массив устроена следующим образом:
начальная позиция, длина отрезка.</p>
<p>Рисунок 4-12.</p>
<p><img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 4-12: Динамический массив ссылается на часть
<code>String</code></span></p>
<p>Синтаксис Rust позволяет упростить описание динамического массива, если он начинается
с 0-го индекса:</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    let s = String::from(&quot;hello&quot;);

    let slice = &amp;s[0..2];
    println!(&quot;{}&quot;,slice);
    let slice = &amp;s[..2];
    println!(&quot;{}&quot;,slice);
}
</code></pre></pre>
<p>Таким же образом можно поступить с последним элементом, если это последний байт в
<code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);

    let len = s.len();
    println!(&quot;sting length = {}&quot;, len);
    let slice = &amp;s[3..len];
    println!(&quot;{}&quot;, slice);
    let slice = &amp;s[3..];
    println!(&quot;{}&quot;, slice);
}

</code></pre></pre>
<p>Таким образом динамический массив целого массива можно описать так:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);
    println!(&quot;{}&quot;, s);
    let len = s.len();
    println!(&quot;a length of the string = {}&quot;, s);
    let slice = &amp;s[0..len];
    println!(&quot;{}&quot;, slice);
    let slice = &amp;s[..];
    println!(&quot;{}&quot;, slice);
}

</code></pre></pre>
<p>Применим полученные знания и перепишем метод <code>first_word</code>. Для представления
динамического массива строк существует короткая запись <code>&amp;str</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p>Теперь, вызвав метод <code>first_word</code>, мы получим один объект, которые включает в себя
всю необходимую информацию.</p>
<p>Аналогичным образом можно переписать и второй метод <code>second_word</code>:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Благодаря использованию динамических массивом нельзя изменить данные строки, если
на неё ссылается динамический массив (т.к. это может привести к ошибке):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // Error!
}
</code></pre>
<p>Ошибка компиляции:</p>
<pre><code class="language-text">17:6 error: cannot borrow `s` as mutable because it is also borrowed as
            immutable [E0502]
    s.clear(); // Error!
    ^
15:29 note: previous borrow of `s` occurs here; the immutable borrow prevents
            subsequent moves or mutable borrows of `s` until the borrow ends
    let word = first_word(&amp;s);
                           ^
18:2 note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Благодаря соблюдению правил, Rust просто исключает класс подобных ошибок.</p>
<a class="header" href="print.html#aСтроковые-константы-и-динамические-массивы" id="aСтроковые-константы-и-динамические-массивы"><h4>Строковые константы и динамические массивы</h4></a>
<p>Вооружившись знаниями о динамических массивах по-новому можно посмотреть на
инициализацию переменной строкового типа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Hello, world!&quot;;
#}</code></pre></pre>
<p>Тип <code>s</code> является <code>&amp;str</code> - это динамический массив бинарных данных специального вида.
Поэтому строковой литерал неизменяемый, а тип <code>&amp;str</code> это неизменяемая ссылка.</p>
<a class="header" href="print.html#aСтроковые-динамические-массивы-как-параметры" id="aСтроковые-динамические-массивы-как-параметры"><h4>Строковые динамические массивы как параметры</h4></a>
<p>Используя строковые динамические массивы, как параметры вы можете улучшить
код наших методов:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Также можно записать этот код следующим образом:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Если мы используем динамический массив, мы может его передавать в методы.
Использование динамических массивов вместо переменных делает код боле удобным:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
   let bytes = s.as_bytes();
   for (i, &amp;item) in bytes.iter().enumerate() {
       if item == b' ' {
           return &amp;s[0..i];
       }
     }
   &amp;s[..]
}
fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word works on slices of `String`s
    let word = first_word(&amp;my_string[..]);
    println!(&quot;{}&quot;,word);
    let my_string_literal = &quot;hello world&quot;;

    // first_word works on slices of string literals
    let word = first_word(&amp;my_string_literal[..]);
    println!(&quot;{}&quot;,word);
    // since string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
    println!(&quot;{}&quot;,word);
}
</code></pre></pre>
<a class="header" href="print.html#aДругие-динамические-массивы" id="aДругие-динамические-массивы"><h3>Другие динамические массивы</h3></a>
<p>Существую также динамические массивы общего типа. Рассмотрим массив:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Создадим динамический массив:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<p>Этот динамический массив имеет тип данных <code>&amp;[i32]</code>. Мы поговорим о таком типе
коллекций в главе 8.</p>
<a class="header" href="print.html#aИтоги-1" id="aИтоги-1"><h2>Итоги</h2></a>
<p>Такие концепции как владение, заимствование и динамические массивы - это способы
защиты использования памяти.  Rust даёт вам возможность контролировать использование
памяти.</p>
<p>Владение влияет на множество других концепций языка Rust.
В следующей главе мы рассмотрим способ группировки данных в  <code>struct</code>.</p>
<a class="header" href="print.html#aИспользование-структуры-для-объединения-логически-связанных-данных" id="aИспользование-структуры-для-объединения-логически-связанных-данных"><h1>Использование структуры для объединения логически связанных данных</h1></a>
<p>Тип данных <em>struct</em> - это группировочный тип данных, который позволяет именовать
связанные данные. Этот тип напоминает объект в объектно-ориентированном программировании.
В этой главе мы сравним структуры с кортежами, рассмотрим наилучшие практики использования
этого типа данных, рассмотрим как определить методы и ассоциированные функции связанные
с данными. <em>struct</em> и <em>enum</em> (тема, которая будет освещена в 6 главе) - это строительные
блоки для создания новых типов данных в Rust. Мы также рассмотрим как компилятор
будет нам помогать создавать эти новые данные и избегать типичных ошибок.</p>
<a class="header" href="print.html#aОпределение-и-инициализация-структур" id="aОпределение-и-инициализация-структур"><h2>Определение и инициализация структур</h2></a>
<p>Внешне структуры похожи на кортежи. Также как кортежи, структуры могут содержать
разные типы данных. Но в отличии от кортежей, все данные должны быть именованными.
Поэтому структуры более удобные для создания новых типов данных, т.к. нет необходимости
запоминать порядковый номер какого-либо значения внутри экземпляра структуры.</p>
<p>Для определения структуры, необходимо указать ключевое слово и <code>struct</code> имя.
Имя должно описывать содержание. Далее, в фигурных скобках, через запятую, вписывается
именованный состав данного типа данных. Каждый элемент, <em>поле</em>, имеет тип данных.
Пример 5-1, описывает структуру для хранения информации о учётной записи пользователя:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
#}</code></pre></pre>
<p><span class="caption">Пример 5-1: определение структуры <code>User</code></span></p>
<p>После определения структуры можно создавать её <em>экземпляры</em>. Для этого каждому полю
определяется конкретное значение, соответствующее типу данных. Мы создаём экземпляр
указывая его имя и далее, в фигурных скобках, вписываем вместо типа данных конкретные
данные. Нет необходимости чётко следовать порядку следования полей (но всё-таки
желательно, для удобства чтения). Структура - это шаблон, а экземпляр - это шаблон
с данными. Пример 5-2:</p>
<pre><pre class="playpen"><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}


fn main() {
let user1 = User {
   email: String::from(&quot;someone@example.com&quot;),
   username: String::from(&quot;someusername123&quot;),
   active: true,
   sign_in_count: 1,
};

}
</code></pre></pre>
<p><span class="caption">Пример 5-2: создание экземпляра структуры <code>User</code></span></p>
<p>Чтобы получить какое-нибудь значения поля структуры, мы можем использовать
точечную нотацию (как в кортеже). Например: <code>user1.email</code>. Для изменения значения
данных поля структуры (если оно изменяемое), мы просто присваиваем ему новое значение.
Пример 5-3:</p>
<pre><pre class="playpen"><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn main() {
    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
    user1.email = String::from(&quot;anotheremail@example.com&quot;);
    println!(
        &quot;[{};{};{};{}]&quot;,
        user1.username,
        user1.email,
        user1.active,
        user1.sign_in_count
    );
}

</code></pre></pre>
<p><span class="caption">Пример 5-3: изменение значения поля <code>email</code> структуры <code>User</code></span></p>
<p>Как в любом выражении, мы можем вернуть экземпляр структуры из функции.
Пример 5-4:</p>
<pre><pre class="playpen"><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
fn main() {
  let mut user1 = build_user(String::from(&quot;someone@example.com&quot;),String::from(&quot;someusername123&quot;));
  user1.email = String::from(&quot;anotheremail@example.com&quot;);
  println!(&quot;[{};{};{};{}]&quot;, user1.username,user1.email,user1.active,user1.sign_in_count);

}
</code></pre></pre>
<p><span class="caption">Пример 5-4: Функция <code>build_user</code> имеющая две входные переменные</span></p>
<p>Если имя переменной функции и поля структуры повторяется, то можно не писать повторяющиеся
наименования:</p>
<pre><pre class="playpen"><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
fn main() {
  let mut user1 = build_user(String::from(&quot;someone@example.com&quot;),String::from(&quot;someusername123&quot;));
  user1.email = String::from(&quot;anotheremail@example.com&quot;);
  println!(&quot;[{};{};{};{}]&quot;, user1.username,user1.email,user1.active,user1.sign_in_count);

}

</code></pre></pre>
<a class="header" href="print.html#aСоздание-экземпляра-структуры-из-экземпляра-другой-структуры" id="aСоздание-экземпляра-структуры-из-экземпляра-другой-структуры"><h3>Создание экземпляра структуры из экземпляра другой структуры</h3></a>
<p>Часто бывает удобно создавать новый экземпляр на основе старого. Пример 5-6 показывает
пример создания нового экземпляра на основе старого:</p>
<pre><pre class="playpen"><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
fn main() {
  let mut user1 = build_user(String::from(&quot;someone@example.com&quot;),String::from(&quot;someusername123&quot;));
  user1.email = String::from(&quot;anotheremail@example.com&quot;);
  let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};

  println!(&quot;[{};{};{};{}]&quot;, user1.username,user1.email,user1.active,user1.sign_in_count);
  println!(&quot;[{};{};{};{}]&quot;, user2.username,user2.email,user2.active,user2.sign_in_count);

}
</code></pre></pre>
<p><span class="caption">Пример 5-6: Создание экземпляра <code>User</code> <code>user2</code> и
присвоение полям значений <code>user1</code></span></p>
<p>Очень интересный вариант установки значений из другого экземпляра. Обновление использует
синтаксис <code>..</code> для передачи данных из полей, которые не были установлены явно:</p>
<pre><pre class="playpen"><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
fn main() {
  let mut user1 = build_user(String::from(&quot;someone@example.com&quot;),String::from(&quot;someusername123&quot;));
  user1.email = String::from(&quot;anotheremail@example.com&quot;);
  let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};

  println!(&quot;[{};{};{};{}]&quot;, user1.username,user1.email,user1.active,user1.sign_in_count);
  println!(&quot;[{};{};{};{}]&quot;, user2.username,user2.email,user2.active,user2.sign_in_count);

}
</code></pre></pre>
<p><span class="caption">Пример 5-7: Использование сокращенного синтаксиса</span></p>
<a class="header" href="print.html#aСокращенное-определение-структур-как-кортежи" id="aСокращенное-определение-структур-как-кортежи"><h3>Сокращенное определение структур (как кортежи)</h3></a>
<p>Мы также можем определять структуры, с помощью сокращенной записи, очень напоминающую
кортежи (такое определение называют <em>кортежными структурами</em>). При определении такого
вида имена полей не определяются.
Пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
#}</code></pre></pre>
<p>Обратите внимание, что переменные <code>black</code> и <code>origin</code> имеют разные типы данных.
Обращение к полям структур осуществляется с помощью <code>.</code> точечной нотации.</p>
<a class="header" href="print.html#aСтруктуры-без-полей" id="aСтруктуры-без-полей"><h3>Структуры без полей</h3></a>
<p>Создателю новых типов доступно создание структур без полей. Такой объект бывает
полезен при более сложной работе, которая будет обсуждать в главе 10.</p>
<blockquote>
<a class="header" href="print.html#aВладение-данными-структуры" id="aВладение-данными-структуры"><h3>Владение данными структуры</h3></a>
<p>При определении структуры <code>User</code> в примере 5-1 мы предпочли использовать тип <code>String</code>
вместо <code>&amp;str</code>. Это было осознанное решение, т.к. мы хотели чтобы экземпляры структур
владели действительными данными во время своего существования в памяти.</p>
<p>Конечно, возможно чтобы структуры сохраняли ссылки на данные это накладывает
определённые ограничения, о которых мы поговорим в главе 10. Без учёта времени
жизни - такой код не будет действительным:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>Ошибка. Необходимы определители времени жизни:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt;
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt;
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>Мы расскажим, как исправить эту ошибку в главе 10. Для исправления этой ошибки
с помощью имеющегося у Вас багажа знаний по Rust - используйте тип <code>String</code> вместо
<code>&amp;str</code>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
fn main() {
    let mut user1 = build_user(
        String::from(&quot;someone@example.com&quot;),
        String::from(&quot;someusername123&quot;),
    );
    user1.email = String::from(&quot;anotheremail@example.com&quot;);
    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        username: String::from(&quot;anotherusername567&quot;),
        ..user1
    };

    println!(
        &quot;[{};{};{};{}]&quot;,
        user1.username,
        user1.email,
        user1.active,
        user1.sign_in_count
    );
    println!(
        &quot;[{};{};{};{}]&quot;,
        user2.username,
        user2.email,
        user2.active,
        user2.sign_in_count
    );
}


</code></pre></pre>
<a class="header" href="print.html#aПример-использования-структур" id="aПример-использования-структур"><h2>Пример использования структур</h2></a>
<p>Для понимания где же лучше всего использовать структуры, мы напишим программу,
которая будет рассчитывать площадь прямоугольника. Мы начнём с создания переменных,
а потом изменение за именение напишем код, который будет использовать структуры.</p>
<p>Создадим проект программы Cargo <em>rectangles</em>, которая будет получать на вход длину
и ширину прямоугольника в пикселах и будет рассчитывать площадь прямоугольника.
Пример кода 5-8 проиллюстрирует это:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let length1 = 50;
    let width1 = 30;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(length1, width1)
    );
}

fn area(length: u32, width: u32) -&gt; u32 {
    length * width
}
</code></pre></pre>
<p><span class="caption">Пример 5-8: Расчёт площади треугольника</span></p>
<p>Теперь, проверим её работу <code>cargo run</code>:</p>
<pre><code class="language-text">The area of the rectangle is 1500 square pixels.
</code></pre>
<a class="header" href="print.html#aРефакторинг-программы-с-помощью-кортежей" id="aРефакторинг-программы-с-помощью-кортежей"><h3>Рефакторинг программы с помощью кортежей</h3></a>
<p>Хотя пример 5-8 работает и расчитывает площадь прямоугольника, мы можем улучшить
программу. Переменные длина и ширина связаны логически, т.к. они описывают параметры
прямоугольника.</p>
<p>Задача этого метода описана в названии:</p>
<pre><code class="language-rust ignore">fn area(length: u32, width: u32) -&gt; u32 {
</code></pre>
<p>Функция <code>area</code> расчитывает площадь одного прямоугольника, но в функцию вводятся
два параметра. Эти параметры связаны, но это никак не оказывает влияние на код программы.
Было бы лучше, если бы код был более очивидным и управляемым, чтобы переменные ширина
и длина были сгруппированы вместе. Мы уже знаем один способ группировки переменны -
кортежи. Следующий пример показывает, как это можно реализовать:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (50, 30);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Пример 5-8: Определени длины и ширины в кортеже</span></p>
<p>Программа стала более понятной и структурированной. Но всёже есть проблема -
элемены кортежа - это безымянные индексы.</p>
<p>Это хорошо, что не важно в каком порядке в кортеже переменные, но если будет нужно
напечатать или сообщить какие-любо величину - можно сделать ошибку, перепутав переменные
местами.</p>
<a class="header" href="print.html#aИзменения-в-коде-с-помощью-структуры-Добавления-в-код-читабельности-и-определённости" id="aИзменения-в-коде-с-помощью-структуры-Добавления-в-код-читабельности-и-определённости"><h3>Изменения в коде с помощью структуры. Добавления в код читабельности и определённости</h3></a>
<p>Мы будем использовать структуры для улучнешния читабельности и упраления кодом.
Пример 5-10:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.length * rectangle.width
}
</code></pre></pre>
<p>или так:</p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = &amp;(Rectangle { length: 50, width: 30 });

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.length * rectangle.width
}
</code></pre></pre>
<p><span class="caption">Пример 5-10: Определение структуры <code>Rectangle</code></span></p>
<p>Мы определяем и именуем структуру <code>Rectangle</code>. Внутри фигурных скобок <code>{}</code> мы
определяем поля <code>length</code> и <code>width</code>, который имеют тип данны <code>u32</code>. Далее, в
методе <code>main</code> мы создаём экземпляр <code>Rectangle</code>, который имеет длину 50 и ширину 30.</p>
<p>Функция <code>area</code> также как и при работе с кортежем, использует один именованный параметр,
значение которого мы заимствуем из метода <code>main</code>. Как мы уже знаем в коде происходит
заимствование, а не изменение владения. Поэтому после работы в методе <code>area</code> переменную
<code>rect1</code> можно далее использовать в методе <code>main</code>. Заимствование осуществляется
благодаря использованию сомвола <code>&amp;</code> при передаче параметра и в описании параметра
функции.</p>
<p>Функция <code>area</code> имеет доступ к полям экземпляра. Теперь определение функции точно
объясняет, что она делает - высисляет площадь прямоугольника.</p>
<a class="header" href="print.html#aДобавим-функциональности-признаки-и-поведение" id="aДобавим-функциональности-признаки-и-поведение"><h3>Добавим функциональности (признаки и поведение)</h3></a>
<p>Было бы удобно иметь возможность печатать состояние экземпляра прямоугольника во
время отладки программы.
Пример 5-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">Пример 5-11: Попытка напечатать содержание состояние экземпляра
<code>Rectangle</code></span></p>
<p>Когда мы попытаемся выполнить этот код, то получим ошибку компиляции:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
</code></pre>
<p>С помощью макроса <code>println!</code> может делать различные виды форматирования. По умолчанию,
<code>{}</code> - это контейнер каких либо данных для форматирования, изветного как <code>Display</code>.
Простые встроенные типы данных реализуют <code>Display</code>. Но структуры не реализуют.
Это надо делать явно в коде.</p>
<p>Обратите внимание на информационное сообщение в коде:</p>
<pre><code class="language-text">note: `Rectangle` cannot be formatted with the default formatter; try using
`:?` instead if you are using a format string
</code></pre>
<p>Попробуем им воспользоваться. Изменим код соответствующим образом:</p>
<pre><code class="language-rust ignore">struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre>
<p>Мы использовали вывод поведение <code>Debug</code>, которое позволяет нам напечатать содержание
структуры по умолчанию.</p>
<p>Выполнив это код также получим сообщение об ошибке компиляции:</p>
<pre><code class="language-text">error: the trait bound `Rectangle: std::fmt::Debug` is not satisfied
</code></pre>
<p>Но, как и в прошлый раз компилятор спешит к нам на помощь и даёт ценные и важные
указания:</p>
<pre><code class="language-text">note: `Rectangle` cannot be formatted using `:?`; if it is defined in your
crate, add `#[derive(Debug)]` or manually implement it
</code></pre>
<p>Rust даёт возможность напечатать отладочную информацию, но для этого нам надо
явно описать это поведение. Для это необходимо аннотировать определение структуры
следующим текстом <code>#[derive(Debug)]</code>.</p>
<p>Пример 5-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Listing 5-12: Добавление аннтации для использования поведения
<code>Debug</code></span></p>
<p>Теперь ошибок компиляции не будет. Ура!</p>
<pre><code class="language-text">rect1 is Rectangle { length: 50, width: 30 }
</code></pre>
<p>Это, конечно, не самый лучший способ представления информации, но для отладки подойдёт.
Для более сложных структур было бы лучшим решением сделать вывод инфомации более удобным.
Для этого используем аннотацию <code>{:#?}</code> вместо <code>{:?}</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(&quot;rect1 is {:#?}&quot;, rect1);
}
</code></pre></pre>
<p>Результат:</p>
<pre><code class="language-text">rect1 is Rectangle {
    length: 50,
    width: 30
}
</code></pre>
<p>Rust предоставляет специальные объекты - признаки для реализаци поведения в структурах.
Мы раскажем как работать с этими объектами - поведениями в главе 10.</p>
<p>Функция <code>area</code> весьма специфична. Она делает расчет площади прямоугольника.
Было бы лучеше, если бы поведение было связано с структурой, т.к. функция может работать
только с этой ней. В следующей главе мы расскажем, как улучшить код и реализовать
эту связь. Мы расскажем, как сделать из обособленной функции метод структуры.</p>
<a class="header" href="print.html#aОсобенности-определения-методов" id="aОсобенности-определения-методов"><h2>Особенности определения методов</h2></a>
<p><em>Методы</em> имею множество схожих черт с функциями.
Сходства:</p>
<ul>
<li>Определение начинается с ключевого слова <code>fn</code>, далее идёт имя.</li>
<li>Они имеют параметры и возвращаемое значение.</li>
<li>Они содржат код, который выполняется, когда метод вызывается.
Различия:</li>
<li>они определяются в контексте структур (или перечислений или типажей, которые мы будем обсуждать в глава 6 и 17).</li>
<li>первый параметр всегда <code>self</code>, который представляет ссылку на экземпляр структуры.</li>
</ul>
<a class="header" href="print.html#aОпределение-методов" id="aОпределение-методов"><h3>Определение методов</h3></a>
<p>Давайте изменим функцию <code>area</code>, которая имеет один входной параметр, ссылку на экземпляр
<code>Rectangle</code>. Сделаем это определение частью функционала структуры <code>Rectangle</code>.
Пример 5-13:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.length * self.width
    }
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Пример 5-13: Определение метода <code>area</code> в структуре <code>Rectangle</code></span></p>
<p>Для определения функций в контексте структуры мы пишем <code>impl</code>, далее имя структуры.
Внутри фигурных скобок располагаются определения функций.  У функции <code>area</code> первым
и единственным аргументом является ссылка на экземпляр структуры. Метод экземпляра
вызывается через точку. Далее в скобках следуют аргументы.</p>
<p>Компилятор знает, что <code>&amp;self</code> в данном контексте это <code>rectangle: &amp;Rectangle</code>. Обратите
внимание, что мы используем ссылку <code>&amp;self</code>. Метод может взять <code>self</code> во владение,
заимствовать, как неизменяемую переменную, а также может заимствовать, как изменяемую
переменную.</p>
<p>В данной функции мы выбрали использование <code>&amp;self</code>, так как нам не нужно владение,
нам нужно только чтение данных структуры. Если нам понадобиться изменять значения
экземпляра структуры, мы должны вызвать <code>&amp;mut self</code>. Очень редко может понадобиться
получить владение <code>self</code>, т.к. это может лишь понадобиться для трансформации экземпляра
во что-то другое.</p>
<blockquote>
<a class="header" href="print.html#aГде-используется-оператор--" id="aГде-используется-оператор--"><h3>Где используется оператор <code>-&gt;</code>?</h3></a>
<p>В языках C++, два различных оператора используются для вызова методов:
вы используете <code>.</code> если вы вызываете метод непосредственно из экземпляра структуры
и с помощью <code>-&gt;</code> если вызываем метод из ссылки на объект. Другими словами, если
<code>object</code> является ссылкой вызовы метода <code>object-&gt;something()</code> и <code>(*object).something()</code>
аналогичны.</p>
<p>Rust не имет такого эквивалента (оператора <code>-&gt;</code>), наоборот, в Rust функционал,
который называется <em>автоматическая ссылка и разыменование</em>. Вызов методов является
одним из немногих мест в Rust, в котором есть такой функционал.</p>
<p>Как это работает: когда вы вызываете метод <code>object.something()</code>, Rust автоматически
добавляет <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> так  чтообы <code>object</code> имет соответсующеие опции
Другими словами, строки <em>p1.distance(&amp;p2);</em> <em>(&amp;p1).distance(&amp;p2);</em> эквивалентны:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug,Copy,Clone)]
struct Point {
  x: f64,
    y: f64,
}

impl Point {
   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
       let x_squared = f64::powi(other.x - self.x, 2);
       let y_squared = f64::powi(other.y - self.y, 2);

       f64::sqrt(x_squared + y_squared)
   }
}
fn main(){
let p1 = Point { x: 0.0, y: 0.0 };
let p2 = Point { x: 5.0, y: 6.5 };
p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
}

</code></pre></pre>
</blockquote>
<pre><code>
Первый вариант *p1.distance(&amp;p2);* выглядит давольно-таки понятно.
Компилятор Rust может по определить, что можно делать с переменной переменной
(читать значение (`&amp;self`), изменять содержание (`&amp;mut self`) или сохранять значение (`self`) ).
Тот факт, что опсание владения происходит неявно, делать код программы более компактным.


### Методы с несколькими параметрами

Давайте дальше практиковаться в использовании методов. Добавим метод проверки
вхождения одного прямоугольника в другой. Метод возвратит `true`, если ответ положительный
и `false` если отрицательный.
Пример 5-14:

&lt;span class=&quot;filename&quot;&gt;Filename: src/main.rs&lt;/span&gt;

```rust,ignore
fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };
    let rect2 = Rectangle { length: 40, width: 10 };
    let rect3 = Rectangle { length: 45, width: 60 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Listing 5-14: Демонстрация использование ещё несуществующего метода
<code>can_hold</code> method</span></p>
<p>Предполагаемый вывод:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>Мы знаем, что где и как добавляются методы внутре конструкции <code>impl Rectangle</code>.
Пример 5-15:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
   fn area(&amp;self) -&gt; u32 {
       self.length * self.width
   }

   fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
       self.length &gt; other.length &amp;&amp; self.width &gt; other.width
   }
}

fn main(){
let rect1 = Rectangle { length: 50, width: 30 };
   let rect2 = Rectangle { length: 40, width: 10 };
   let rect3 = Rectangle { length: 45, width: 60 };
   println!(&quot;area of rect1 = {}&quot;, rect1.area());
   println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
   println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}

</code></pre></pre>
<p><span class="caption">Listing 5-15: Реализация метода <code>can_hold</code> <code>Rectangle</code>,
который получает другой экземпляр <code>Rectangle</code> в качестве параметра</span></p>
<p>Когда будет выполнен код метода <code>main</code> вы увидите ожидаемый вывод в терминальной
строке. Методы могут иметь множество параметров, которые мы добавляем после параметра
<code>self</code> и все эти параметра работают также, как и параметры функции.</p>
<a class="header" href="print.html#aАссоциированные-функции" id="aАссоциированные-функции"><h3>Ассоциированные функции</h3></a>
<p>Ещё одна удобная опция блока <code>impl</code> - мы можем определять функции, которые не
имеют параметра <code>self</code>. Они называются <em>ассоциированными функциями</em>, т.к. они
находятся внутри структуры. Они функции, не методы, т.к. они не требуют для их
использования ссылки на экземпляр структуры. Пример (<code>String::from</code>).</p>
<p>Такие функция часто используются для инициализации экземпляра структуры.
Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
 #[derive(Debug)]
 struct Rectangle {
     length: u32,
     width: u32,
 }

impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { length: size, width: size }
    }
}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
   fn area(&amp;self) -&gt; u32 {
       self.length * self.width
   }

   fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
       self.length &gt; other.length &amp;&amp; self.width &gt; other.width
   }
   fn square(size: u32) -&gt; Rectangle {
       Rectangle { length: size, width: size }
   }
}

fn main(){
let rect1 = Rectangle { length: 50, width: 30 };
   let rect2 = Rectangle { length: 40, width: 10 };
   let rect3 = Rectangle { length: 45, width: 60 };
   println!(&quot;area of rect1 = {}&quot;, rect1.area());
   println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
   println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
   let rect4 = Rectangle::square(50);
   println!(&quot;area of rect4 = {}&quot;, rect4.area());
}

</code></pre></pre>
<p>Для вызова ассоциированной функции используется <code>::</code>. Пример (<code>let sq = Rectangle::square(3);</code>.
Также <code>::</code> используется в областях видимости создаваемые модулями. Об этом поговорим
в главе 7.</p>
<a class="header" href="print.html#aНесколько-блоков-impl" id="aНесколько-блоков-impl"><h3>Несколько блоков <code>impl</code></h3></a>
<p>Каждая структура может использовать множество блоков <code>impl</code>. Пример 5-15:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.length * self.width
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            length: size,
            width: size,
        }
    }
}
fn main() {
    let rect1 = Rectangle {
        length: 50,
        width: 30,
    };
    let rect2 = Rectangle {
        length: 40,
        width: 10,
    };
    let rect3 = Rectangle {
        length: 45,
        width: 60,
    };
    println!(&quot;area of rect1 = {}&quot;, rect1.area());
    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
    let rect4 = Rectangle::square(50);
    println!(&quot;area of rect4 = {}&quot;, rect4.area());
}

</code></pre></pre>
<p><span class="caption">Пример 5-16: неоднократное использование <code>impl</code></span></p>
<p>В главе 10 вы увидите, как множество таким блоков может быть эффективно использовано.</p>
<a class="header" href="print.html#aИтоги-2" id="aИтоги-2"><h2>Итоги</h2></a>
<p>Структуры помогают создавать типы и добавлять к ним методы. Методы могут быть
статическими и динамическими (требующими ссылки на экземпляр структуры).</p>
<p>Также существуют и другие способы создавать новые типы данных. Один из них - это
перечисления.</p>
<a class="header" href="print.html#aПеречисления-и-шаблоны-выбора" id="aПеречисления-и-шаблоны-выбора"><h1>Перечисления и шаблоны выбора</h1></a>
<p>В этой главе мы рассмотрим <em>перечисления</em> (<em>enums</em>). Это группировочный тип данных,
в который входит конечный набор константных значений. Сначала мы рассмотрим, как
можно использовать перечисление в коде. Далее, мы рассмотрим наиболее часто используемое
перечисление <code>Option</code>. Его удобно использовать, как оболочку для выходных данных
функции и или языковых контракций. Мы рассмотрим работу языковой конструкции <code>match</code>,
которая позволяет организовывать ветвления в коде. Также мы рассмотрим конструкцию
<code>if let</code>, которая позволяет использовать перечисления, как создании ветвления в коде.</p>
<p>Данный тип схож по <em>алгебраическими типами данных</em> в таких языках, как F#, OCaml или
Haskell.</p>
<a class="header" href="print.html#aОпределение-перечисления" id="aОпределение-перечисления"><h2>Определение перечисления</h2></a>
<p>Рассмотрим ситуацию, когда использование перечисления весьма желательно.</p>
<p>Мы можем создать определение перечисления  <code>IpAddrKind</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}
#}</code></pre></pre>
<a class="header" href="print.html#enum-values" id="enum-values"><h3>Enum Values</h3></a>
<p>Экземпляр перечисления можно создать следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
}

</code></pre></pre>
<p>Обратите внимание, что перед значением стоит идентификатор. <code>::</code> разделяет эти данные.
Две эти величины одного типа <code>IpAddrKind</code>. Следовательно, мы можем использовать этот
тип при указании типа данных функции:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
 enum IpAddrKind {
     V4,
     V6,
 }

fn route(ip_type: IpAddrKind) { }
#}</code></pre></pre>
<p>Значениями данной функции будут значения перечисления данного типа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
 enum IpAddrKind {
     V4,
     V6,
 }

 fn route(ip_type: IpAddrKind) { }

route(IpAddrKind::V4);
route(IpAddrKind::V6);
#}</code></pre></pre>
<p>Преимущества использования перечислений. Мы можем получать информацию о типе данных,
а не сами данные. Пример 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Пример 6-1: Сохранение данных <code>IpAddrKind</code>в структуре <code>struct</code></span></p>
<p>Мы также можем реализовать перечисление содержащие переменные данные внутри элементов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Мы добавили данные в каждый вариант перечисления. Таким образом, мы упростили наш
предыдущий код и получили тот же результат.</p>
<p>Ещё одно преимущество перечисления заключается в том, что каждый вариант данных
может иметь различный тип данных:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Мы показали несколько различных вариантов, которые можно использовать для определения
IP-адреса.</p>
<p>Рассмотрим какое решение реализовано в стандартной библиотеке:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // details elided
}

struct Ipv6Addr {
    // details elided
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>Этот код иллюстрирует возможность добавления любого типа данных в значение перечисления:
строк, чисел, структур и пр. Вы даже можете включит другие перечисления!
Стандартные типы данных, не очень сложны, хотя, потенциально, могут быть очень сложными
(вложенность данных может быть очень глубокой).</p>
<p>Обратите внимание, что имея определение перечисления <code>IpAddr</code> в стандартной библиотеке,
вы можете создавать и использовать свою собственную реализацию без каких-либо
конфликтов, т.к. вы можете не добавлять определение стандартной библиотеки в область
видимости. Подробнее об этом поговорим в главе 7.</p>
<p>Рассмотрим другой пример 6-2: в этом примере каждый элемент перечисления имеете свой,
особый, тип данных внутри:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Пример 6-2: Перечисление <code>Message</code>, в котором каждый элемент
хранит различные данные (наиболее удобные и нужные для использования)</span></p>
<p>Это перечисление имеет 4 элемента:</p>
<ul>
<li><code>Quit</code> - пустой элемент.</li>
<li><code>Move</code> - имеющий анонимную структуру.</li>
<li><code>Write</code> имеет строку <code>String</code>.</li>
<li><code>ChangeColor</code> имеет кортеж <code>i32</code> значений.</li>
</ul>
<p>Это определение компактно хранит данные. Оно подобно определению множеству структур:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>Но когда мы используем различные структуры, которые имеют свои собственные типы,
мы не можем легко определять функции, которые могли бы любые типы сообщений, которые
может содержать в себе перечисление.</p>
<p>Так и структуры и перечисления - это всё группировочные типы данные семантика
добавления функций в них идентична. Мы используем структуру <code>impl</code>:</p>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // method body would be defined here
    }
}
fn main() {
    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
}
</code></pre></pre>
<p>Метод может использовать <code>self</code> для получения значения. В данном случае, <code>self</code> -
это строка..</p>
<p>Теперь рассмотрим наиболее часто использованное перечисление стандартной библиотеки
<code>Option</code>.</p>
<a class="header" href="print.html#aПеречисление-option-и-его-преимущества-перед-нулевыми-значениями" id="aПеречисление-option-и-его-преимущества-перед-нулевыми-значениями"><h3>Перечисление <code>Option</code> и его преимущества перед нулевыми значениями</h3></a>
<p>В предудущей секции, вы рассматривали как перечисление <code>IpAddr</code> позволяет нам
использовать систему типов Rust для архивирования информации.
Перечисление <code>Option</code> используется так часто, потому что оно реализует часто используемый
сценарий, в котором значение может быть чем-то или ничем. Этот шаблон позволяет
уберечь программу от множества ошибок.</p>
<p>Дизайн языка программирования спроектирован так, что не имеет нулевых значений.
Перечисление <code>Option&lt;T&gt;</code> даёт возможность показать, что значение нулевое с помощью
одного из своих элементов <a href="https://doc.rust-lang.org/std/option/enum.Option.html">defined by the standard library</a><!-- ignore -->:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>Перечисление <code>Option&lt;T&gt;</code> очень важно для всей стандартной библиотеки. Также вы можете
использовать коде элементы перечисления <code>Option&lt;T&gt;</code> h <code>Option::</code> без префикса:<code>Some</code>,
<code>None</code>.</p>
<p>О подстановочных типах  <code>&lt;T&gt;</code> (дженерика), их синтаксисе мы ещё не говорили
Поговорим об этом в главе 10. <code>&lt;T&gt;</code> это обозначения того, что перечисление может иметь
любой тип. Пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>Если мы используем значение <code>None</code>, то нам обязательно нужно указывать конкретный
тип данных, который мы будем использовать.</p>
<p>Если вы используете значение <code>Some</code>, то это значит, что какое-либо значение существует.
Когда вы используете значение <code>None</code>, это значит, что никакого значения нет.</p>
<p>Т.к. <code>Option&lt;T&gt;</code> и <code>T</code> (<code>T</code> - это любой тип данных) разные типы данных, компилятор
не позволяет использовать значение <code>Option&lt;T&gt;</code> вместо конкретного типа данных.
Этот код не будет скомпилирован, т.к. тут происходит попытка суммирования двух разных
типов данных <code>i8</code> и <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<p>Оприсание ошибки:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
7 | let sum = x + y;
  |           ^^^^^
  |
</code></pre>
<p>Для того, чтобы испльзовать содержащееся значение в в <code>Some</code> необходимо конвертировать
его в данные. Это также типичное действие помогающее избежать ошибок.</p>
<p>Если есть такая возможность, что значение может иметь нулевое значение, лучше всего
использовать тип данных <code>Option&lt;T&gt;</code>. Использование этого перечисления значительно
повышает уровень безопасности кода.</p>
<p>Вам надо хорошо разобраться с методами перечисления <code>Option&lt;T&gt;</code>. Это поможет вам
лучше понимать исходный код Rust стандартной библиотеки.</p>
<p>В следующей секции будет рассмотрена конструкция <code>match</code>. Это управляющая конструкция,
которая используется совместно с перечислениями. Результат выполнения той или иной
ветви кода зависит от значения перечисления.</p>
<a class="header" href="print.html#aОператор-управления-работой-кода-match" id="aОператор-управления-работой-кода-match"><h2>Оператор управления работой кода <code>match</code></h2></a>
<p><code>match</code> весьма мощная конструкция, которая позволяет сравнивать значение с серией
шаблонов и затем выполнять код, в зависимости от того, какое значение было выбрано.
Шаблоном может выступать как литеральное значение, так и имена переменных, подстановочные
значения и многое другое. В главе 18 будет много рассказано о различных типах шаблонов
и что каждый из них делает. Мощь <code>match</code> выражается в выразительной синтаксической
конструкции и возможности перебора всех возможных значений.</p>
<p>Пример 6-3:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">Пример 6-3: перечисление и выражение <code>match</code>, которое использует
значение перечисления в качестве параметров</span></p>
<p>Подробнее рассмотрим работу выражения <code>match</code>. Оно похоже на <code>if</code> с той разницей,
что может возвращать любые значения.</p>
<p>Внутри выражение <code>match</code> напоминает осьминога или сороконожку. Оно разделяется на лапки,
каждый из которых состоит из шаблона и кода. Первая лапка содержит значение <code>Coin::Penny</code>.
Далее следует оператор-разделитель <code>=&gt;</code>, далее выполняемый код. В данном случае это
просто скалярное значение. Описание каждой лапки отделяется друг от друга запятой.</p>
<p>Когда выражение <code>match</code> выполняется, происходит сравнение результирующего значения с
шаблоном в каждой лапке по порядку. Если значение удовлетворяет правилам шаблона,
выполняется код, который связан с этим шаблоном. Если нет, проверка продолжается.</p>
<p>Код,  в каждой руке является выражением, т.е. возвращает значение.</p>
<p>Фигурный скобки в коде могут быть опущены, если выражение совсем простое:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#aШаблоны-которые-связываться-со-значениями" id="aШаблоны-которые-связываться-со-значениями"><h3>Шаблоны, которые связываться со значениями</h3></a>
<p>Ещё одно полезное качество, которое есть у рук выражения <code>match</code> следующее:
они могут связывать части значений, которые удовлетворяют шаблону поиска.</p>
<p>К примеру, давайте изменим одно из значений перечисления, чтобы оно содержало в себе
значение.
Пример 6-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // So we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // ... etc
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
#}</code></pre></pre>
<p><span class="caption">Пример 6-4: Перечисление <code>Coin</code>, где одно из значений <code>Quarter</code>
содержит значение перечисления <code>UsState</code> value</span></p>
<p>Т.е. поиск может быть вложенным:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}
fn main() {
    value_in_cents(Coin::Quarter(UsState::Alaska));
}

</code></pre></pre>
<p>Если Вы вызовите метод <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, где переменная
<code>coin</code> имеет значение <code>Coin::Quarter(UsState::Alaska)</code>. То мы сможем вывести на
печать значение <code>UsState::Alaska</code>.</p>
<a class="header" href="print.html#aИспользования-перечисления-optiont-в-конструкции-match" id="aИспользования-перечисления-optiont-в-конструкции-match"><h3>Использования перечисления <code>Option&lt;T&gt;</code> в конструкции match</h3></a>
<p>Перечисление <code>Option&lt;T&gt;</code> используется аналогичным образом.</p>
<p>Разберем работу с ним на примере. Возьмём перечисление  <code>Option&lt;i32&gt;</code>. Напишем функцию,
которая получает значение этого перечисления и содержит значение. Если значения нет,
оно имеет значение <code>None</code>.</p>
<p>Пример использования <code>match</code> и <code>Option&lt;T&gt;</code> 6-5:</p>
<pre><pre class="playpen"><code class="language-rust">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
    println!(&quot;{:?}&quot;, five);
    println!(&quot;{:?}&quot;, six);
    println!(&quot;{:?}&quot;, none);
}

</code></pre></pre>
<p><span class="caption">Пример использования <code>match</code> и <code>Option&lt;T&gt;</code></span></p>
<a class="header" href="print.html#aАнализ-значений-перечисления-optiont-somet" id="aАнализ-значений-перечисления-optiont-somet"><h4>Анализ значений перечисления <code>Option&lt;T&gt;</code>. <code>Some(T)</code></h4></a>
<p>Давайте рассмотрим работу функции <code>plus_one</code> более подробно.</p>
<p>Значение <code>Some(5)</code> не равно <code>None</code>, поэтому анализ идёт дальше.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p>Значение <code>Some(5)</code> соответствует шаблону <code>Some(i)</code>. Данные, содержащееся в
<code>Some</code> используется и изменяется. Создаётся новое значение <code>Some(i)</code> с новыми данными
внутри.</p>
<a class="header" href="print.html#none" id="none"><h4><code>None</code></h4></a>
<p>Теперь рассмотрим <code>None</code> и его поиск по шаблону.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Значения совпадают. Анализ останавливается на этом месте.</p>
<p>Использование перечисления в конструкции <code>match</code> весьма удобно и часто используется.
Понимание как это работает приходит с опытом. Надеюсь, что эта конструкция будет
вам помогать в работе.</p>
<a class="header" href="print.html#aПеребор-всех-значений" id="aПеребор-всех-значений"><h3>Перебор всех значений</h3></a>
<p>Обратите внимание! Если мы уберем ветку возможных вариантов значения перечисления,
компилятор не скомпилирует код и сообщит об ошибке:</p>
<pre><code class="language-rust ignore">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>Компилятор, проанализировав все возможные варианты перечисления, обнаружил, что какое-либо
из них не используется. Это ошибка.</p>
<a class="header" href="print.html#aИспользование-_" id="aИспользование-_"><h3>Использование <code>_</code></h3></a>
<p>В языке Rust есть специальный шаблон для <code>match</code>, который можно использовать, если
вы по каким-то причинам не хотите перебирать все значения перечисления. Т.е. <code>_</code>
используется для всех остальных вариантов. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>Код шаблона <code>_</code> обрабатывает все остальные значения.  <code>()</code> это пустой объект.</p>
<p>Выражение <code>match</code> имеет сокращенную форму, о котором мы поговорим в следующей секции.</p>
<a class="header" href="print.html#if-let" id="if-let"><h2><code>if let</code></h2></a>
<p>Конструкция <code>if let</code> позволяет комбинировать <code>if</code> и <code>let</code>, что позволяет присваивать
значение переменной, удовлетворяющее определённому шаблону. Пример 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Пример 6-6. Будет напечатана строка, если some_u8_value будет
равна <code>Some(3)</code></span></p>
<p>Существует возможность написать более компактный код этого примера. Пример 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
#}</code></pre></pre>
<p>Выбор между использованием <code>match</code> и <code>if let</code> зависит от задачи. Выбор за вами.</p>
<p><code>if let</code> является синтаксическим упрощением <code>match</code> в определённых обстоятельствах.</p>
<p>Мы также можем написать <code>if let</code> c <code>else</code>. Это будет полностью похоже на <code>match</code>.
Пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}
#}</code></pre></pre>
<p>Этот же код можно переписать с использованием <code>if let</code> и <code>else</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
#[derive(Debug)]
enum UsState {
   Alabama,
   Alaska,
}

enum Coin {
   Penny,
   Nickel,
   Dime,
   Quarter(UsState),
}

fn doit(coin:Coin){

  let mut count = 0;

  if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
  } else {
    count += 1;
  }

  println!(&quot;{:?}&quot;, count);
}

fn main(){
  doit(Coin::Penny);
  doit(Coin::Nickel);
  doit(Coin::Dime);
  doit(Coin::Quarter(UsState::Alabama));
  doit(Coin::Quarter(UsState::Alaska));
}

</code></pre></pre>
<p>Вам выбирать какая конструкция подходит для вашего кода лучше сего.</p>
<a class="header" href="print.html#aИтоги-3" id="aИтоги-3"><h2>Итоги</h2></a>
<p>В этой главе мы рассмотрели, как использовать перечисление (создание, примеры использования).
Также на пример типа из стандартной библиотеки <code>Option&lt;T&gt;</code> выяснили, как
предотвратить ошибки в коде.  Изучили использование конструкций <code>match</code> и <code>if let</code>
для анализа и выборки данных из значений перечислений, а также некоторые возможные
улучшения и упрощения кода.</p>
<p>Теперь вы можете создавать программы и использовать возможности группировочных структур
Rust.</p>
<p>Для логической организации большого количества файлов кода весьма удобно использовать модули,
о которых мы поговорим далее.</p>
<a class="header" href="print.html#aИспользование-модулей-для-организации-и-многократного-использования-кода" id="aИспользование-модулей-для-организации-и-многократного-использования-кода"><h1>Использование модулей для организации и многократного использования кода</h1></a>
<p>Когда вы только начинаете писать программу, ваш код может совершенно свободно
поместиться в функции <code>main</code>. Но по мере создания функциональных возможностей, добавления
все большего и большего количества функций вам понадобиться организовать код в
удобные для чтения, группировки структуры. Для этого в Rust есть система модулей.</p>
<p>Также как вы используете код программы в функциях, вы можете использовать функции в
модулях. Модуль представляет собой пространство имён, в которое может входить
различные функции и типы. Вы также можете управлять видимостью внутри модуля.</p>
<p>Общее описание возможностей модулей:</p>
<ul>
<li>Ключевое слово <code>mod</code> объявляет модуль. Код следующий после объявления модуля считается
включенным в него.</li>
<li>По умолчанию, модуль закрыт и чтобы извне был доступ к его элементам это надо указать
в коде. Для этого используется ключевое слово <code>pub</code>.</li>
<li>Ключевое слов <code>use</code> даёт возможность использовать в тексте программы функционал
модуля.</li>
</ul>
<p>Мы рассмотрим подробнее все эти возможности в следующих секциях.</p>
<a class="header" href="print.html#mod-и-файловая-система" id="mod-и-файловая-система"><h2><code>mod</code> и файловая система</h2></a>
<p>Мы начнём создавать наш пример использования модуля. Создадим проект библиотеки
кода.</p>
<p>Cоздадим основные блоки нашей библиотеки, которая будет предоставлять функциональные
возможности использования сетевых технологий. Назовём нашу библиотеку <code>communicator</code>.
По умолчанию Cargo создаёт библиотеки кода. Если при создании нового проекта мы
не установим флаг <code>--bin</code>, то будет создана библиотека:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Обратите внимание, что Cargo создаёт <em>src/lib.rs</em> вместо <em>src/main.rs</em>, в котором
мы видим вот такое содержание:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p>Cargo  создаёт пустой тест, чтобы показать как можно тестировать функционал библиотеки.
Мы изучим использование синтаксических конструкций <code>#[]</code> и <code>mod tests</code> в последующей
секции &quot;Использование <code>super</code> для доступа к родительскому модулю&quot; этой главы.</p>
<p>Сейчас же мы не будем использовать данный функционал, поэтому просто удалить этот код.</p>
<p>Т.к. у нас нет файла <em>src/main.rs</em>, нечего запускать на выполнение с помощью команды
<code>cargo run</code>. В тоже время мы можем воспользоваться командой <code>cargo build</code> для компиляции
нашей библиотеки.</p>
<p>Мы рассмотрим различные опции организации кода нашей библиотеки.</p>
<a class="header" href="print.html#aОпределение-модуля" id="aОпределение-модуля"><h3>Определение модуля</h3></a>
<p>Первым делом напишем определение модуля <code>network</code>, который будет содержать
определение функции <code>connect</code>. Определение начинается с ключевого слова <code>mod</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>После определения модуля, внутри фигурных скобок пишем определения функции и
все что входит в состав модуля. В нашем случае это описание функции.
Если мы хотим вызывать функцию извне модуля, мы должны явно указать это <code>network::connect()</code>.</p>
<p>У нас может быть множество описаний модулей в одном файле  <em>src/lib.rs</em>.
К примеру, модуль <code>client</code>, может содержать функцию <code>connect</code> 7-1:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class="caption">Пример 7-1: Определение модулей <code>network</code> и <code>client</code>в файле
<em>src/lib.rs</em></span></p>
<p>Теперь у нас есть описание двух функций, которые могут быть вызваны с помощью
синтаксических конструкций <code>network::connect</code> и <code>client::connect</code>.
У каждой из этих функций могут быть различные функциональные возможности, но у них нет
между собой никакого конфликта имён.</p>
<p>В этом случае, если мы создаём библиотеку, файл <em>src/lib.rs</em> хранит точку доступа к
библиотеке.  Также мы можем создать модуль в файле  <em>src/main.rs</em>
для какой-либо бинарной программы. Очень важная особенностью модулей - они
могут быть вложенными. Это весьма удобно для логической организации кода.
Пример 7-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption"> Пример 7-2: Перемещение модуля <code>client</code> внутрь модуля <code>network</code></span></p>
<p>Теперь у нас есть две разные функции <code>network::connect</code> и <code>network::client::connect</code>.
Каждая из которых находится в своём пространстве имён.</p>
<p>Теперь организация нашего кода имеет вот такую структуру:</p>
<pre><code class="language-text">communicator
 ├── network
 └── client
</code></pre>
<p>Пример вложенных модулей 7-2:</p>
<pre><code class="language-text">communicator
 └── network
     └── client
</code></pre>
<p>Логическая организация кода зависит от ваших задач.</p>
<a class="header" href="print.html#aРазмещение-модулей-по-нескольким-файлам" id="aРазмещение-модулей-по-нескольким-файлам"><h3>Размещение модулей по нескольким файлам</h3></a>
<p>Модульная структура похожа на файловую систему. Мы можем использовать модульную
систему для хранения кода в разных файлах. Рассмотрим пример 7-3:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Пример 7-3: Модули <code>client</code>, <code>network</code> и<code>network::server</code>,
все они находятся в <em>src/lib.rs</em></span></p>
<p>Архитектура модулей <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 ├── client
 └── network
     └── server
</code></pre>
<p>Если модули имеет множество функций и эти функции длинные, было бы удобно разделить
такой код на несколько файлов.</p>
<p>Сначала заменим код модуля <code>client</code> на декларацию модуля:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p>Тут мы видим декларацию модуля. Этим мы сообщаем, что в другом месте есть определение
модуля <code>client</code>:</p>
<pre><code class="language-rust ignore">mod client {
    // contents of client.rs
}
</code></pre>
<p>Теперь создадим файл <em>client.rs</em> в папке исходных кодов.:</p>
<p><span class="filename">Filename: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Обратите внимание, что вам не надо декларировать модуль, т.к. вы уже декларировали
его в файле <em>src/lib.rs</em>. Файл <em>src/client.rs</em> содержит компоненты модуля <code>client</code>. Если же
вы и здесь напишите декларацию модуля <code>mod client</code>, то это будет значит, что внутри модуля
<code>client</code> есть модуль <code>client</code>!</p>
<p>По умолчанию, компилятор сначала исследует содержание файла <em>src/lib.rs</em>. Если
есть необходимость добавать несколько файлов в проект, необходимо сообщить об этом
в файле <em>src/lib.rs</em>. Именно поэтому, модуль <code>client</code> надо определить в файле <em>src/lib.rs</em>
и не надо делать этого в файле <em>src/client.rs</em>.</p>
<p>Компиляция проекта пройдет успешно:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/client.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/lib.rs:4:5
  |
4 |     fn connect() {
  |     ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/lib.rs:8:9
  |
8 |         fn connect() {
  |         ^
</code></pre>
<p>Эти сообщения сигнализируют нам, что наши функции нигде не используются. Проигнорируем
их до секции &quot;Управление доступом с помощью ключевого слова <code>pub</code>&quot;.</p>
<p>Теперь перенесём модуль <code>network</code> в свой файл:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Далее, создадим файл <em>src/network.rs</em> и введём в него следующий код:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Обратите внимание, что у нас есть описание модулей в файле, т.к. у нас всё еще есть
вложенность модулей.</p>
<p>Выполним команды <code>cargo clean</code> а потом <code>cargo build</code>. Всё в порядке! Отлично!
Теперь осталось создать файл только для ещё одного модуля. Для этого создадим
описание подчиненного модуля в файле <em>src/network.rs</em> <code>mod server;</code>:</p>
<p><span class="filename">Filename: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Далее создадим файл <em>src/server.rs</em> и добавим в него содержание:</p>
<p><span class="filename">Filename: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Выполним команды <code>cargo clean</code> а потом <code>cargo build</code>. Получим сообщение об ошибке 7-4:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `network` to its own directory via `network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Код 7-4: Ошибка при переносе кода вложенного модуля <code>server</code>
в файл <em>src/server.rs</em></span></p>
<p>Компилятор предлагает решение:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>Вместо того, чтобы создавать файл аналогично предыдущему, сделаем следующее:</p>
<ol>
<li>Создадим <em>папку</em> с именем <em>network</em> (это имя нашего родительского модуля).</li>
<li>Перенесём файл <em>src/network.rs</em> в эту новую папку и переменуем файл в <em>src/network/mod.rs</em>.</li>
<li>Далее перенесём файл <em>src/server.rs</em> в папку <em>network</em>.</li>
</ol>
<p>Для подчиненных модулей проделаем тоже самое.</p>
<a class="header" href="print.html#aПравила-модульной-файловой-системы" id="aПравила-модульной-файловой-системы"><h3>Правила модульной файловой системы</h3></a>
<p>Список правил:</p>
<ul>
<li>Если модуль <code>foo</code> не имеет подчиненных модулей, вы можете сохранить код модуля в
файл <em>foo.rs</em>.</li>
<li>Если модуль <code>foo</code> имеет подмодуль, вы должны перенести код модуля в файл <em>foo/mod.rs</em></li>
</ul>
<p>Это правило применяется рекурсивно если модуль с именем <code>foo</code> имеет подмодуль с
<code>bar</code> и <code>bar</code> не имеет подмодулей, то у Вас получить вот такая файловая система
в папке <em>src</em>:</p>
<pre><code class="language-text">├── foo
│   ├── bar.rs (contains the declarations in `foo::bar`)
│   └── mod.rs (contains the declarations in `foo`, including `mod bar`)
</code></pre>
<p>Модули должны быть определены в своих файлах используя ключевое слово <code>mod</code>.</p>
<p>Далее, мы поговорим о модификаторе доступа <code>pub</code> и устраним сообщения о проблемах
в коде.</p>
<a class="header" href="print.html#aУправление-доступом-с-помощью-ключевого-слова-pub" id="aУправление-доступом-с-помощью-ключевого-слова-pub"><h2>Управление доступом с помощью ключевого слова <code>pub</code></h2></a>
<p>Мы исправили ошибки связанные с распределением кода. Но остались проблемы с использованием
кода (функци не используются):</p>
<pre><code class="language-text">warning: function is never used: `connect`, #[warn(dead_code)] on by default
src/client.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/mod.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/server.rs:1:1
  |
1 | fn connect() {
  | ^
</code></pre>
<p>Почему имеют место эти ошибки? Библиотеку существуют для того, чтобы ими пользовались
пользователи. Поэтому важно, чтобы проблемы с доступом к функционалу были решены.</p>
<p>Для того, чтобы понять почему существуют такие ошибки, а как важно их устранить,
попробуем воспользоваться функционалом кода извне. Для этого создадим выполняемый
проект в этой же директории. Создадим файл <em>src/main.rs</em>, который содержит:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p>Мы сейчас использовали команду <code>extern crate</code> для того чтобы использовать функционал
библиотеки <code>communicator</code> в нашей новой программе. Cargo использует файл <em>src/main.rs</em>,
как точку доступа для бинарной программы, в то время, как <em>src/lib.rs</em> используется
для библиотеки. Такая организация кода довольно-таки обычна. Большинство кода
находится в библиотеках, а бинарный файл просто использует эту библиотеку. Результатом
такой архитектуры является возможность другим программам также использовать функционал
библиотеки.</p>
<p>Со стороны стороннего кода все что находится в библиотеке имеет пространство имён
<code>communicator</code> (имя библиотеки) верхнего уровня. Всё остальное, это подчиненные модули.</p>
<p>Также обратите внимание, что когда мы используем внешние библиотеки с подомодулями,
команда <code>extern crate</code> начинает искать модули с верхнего уровня.</p>
<p>В нашей программе бинарный файл вызывает библиотечную функцию <code>connect</code> из
модуля <code>client</code>. Но при компиляции этого кода получим сообщении об ошибке:</p>
<pre><code class="language-text">error: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Это сообщение говорит нам о том, что модуль <code>client</code> закрытый.
Т.к. код в модуле закрытый по умолчанию и не используется внутри библиотеки - на
это надо обратить внимание, т.к. это явная ошибка в организации кода.</p>
<p>После определения функции <code>client::connect</code>, как доступной (<code>pub</code>), не только сообщение
об ошибке исчезнет, но и проподёт сообщение о том, что код не используется.
Создания доступного кода в Rust даёт возможность его использования вне библиотеки.
Когда какой-либо кода помечается как <code>pub</code>, компилятор больше не сообщает об неиспользованном
коде, если даже он фактически не используется.</p>
<a class="header" href="print.html#aСделать-функции-доступными" id="aСделать-функции-доступными"><h3>Сделать функции доступными</h3></a>
<p>Для того, чтобы сделать что-либо доступным извне необходимо добавить ключевое слово
<code>pub</code> в начало декларирования элемента кода. Для исправления ошибки мы добавить
это спецификатор доступа перед определение имени модуля.
:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p>Ключевое слово <code>pub</code> перед <code>mod</code>. Компиляция. Сообщение об ошибке:</p>
<pre><code class="language-text">error: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Сделаем исправления в определении функции в файле <em>src/client.rs</em>:</p>
<p><span class="filename">Filename: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>Снова компилируем <code>cargo clean &amp;&amp; cargo build</code> снова:</p>
<pre><code class="language-text">warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/mod.rs:1:1
  |
1 | fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/server.rs:1:1
  |
1 | fn connect() {
  | ^
</code></pre>
<p>Код скомпилировался и предостережения о функции <code>client::connect</code> уже нет!</p>
<p>Вам решать, что делать с неиспользованным кодом, то ли открыть к нему доступ, то ли
удалить.</p>
<p>В данном случае мы хотим, чтобы эти функции были доступны. Поэтому добавим <code>pub</code>
там, где это необходимо:</p>
<p><span class="filename">Filename: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>Скомпилируем и проанализируем ошибки:</p>
<pre><code class="language-text">warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/mod.rs:1:1
  |
1 | pub fn connect() {
  | ^

warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/server.rs:1:1
  |
1 | fn connect() {
  | ^
</code></pre>
<p>Для того, чтобы открытые функции модуля были доступны, сам модуль должен быть доступен:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>Новые сообщения компилятора:</p>
<pre><code class="language-text">warning: function is never used: `connect`, #[warn(dead_code)] on by default
 --&gt; src/network/server.rs:1:1
  |
1 | fn connect() {
  | ^
</code></pre>
<p>Надеюсь, что теперь исправить последний недочёт программы Вам не составит труда.</p>
<a class="header" href="print.html#aПравила-доступа" id="aПравила-доступа"><h3>Правила доступа</h3></a>
<ol>
<li>Если элемент открытый, он должен быть открытый и все родительские модули тоже.</li>
<li>Если элемент закрытый, он может быть доступен только из родительского модуля и из любых подчиненных модулей.</li>
</ol>
<a class="header" href="print.html#aПримеры" id="aПримеры"><h3>Примеры</h3></a>
<p>Создадим новый проект библиотеки secret 7-5 <em>src/lib.rs</em>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">Код 7-5: Примеры открытых и закрытый функций с ошибками</span></p>
<p>Перед компиляцией кода, попробуйте догадаться, где будет ошибка. Убедитесь в этом
с помощью компиляции. Исправьте ошибки в коде!</p>
<a class="header" href="print.html#aРассмотрим-ошибки" id="aРассмотрим-ошибки"><h4>Рассмотрим ошибки</h4></a>
<p>Функция <code>try_me</code> находится на верхнем уровне модуля нашего проекта. Модуль
<code>outermost</code> закрытый, но к его функциям может быть доступ, т.к. модуль верхнего
уровня.</p>
<p>Вызов остальных двух функций вызовет ошибку, т.к. не применяются правила видимости.
Пожалуйста, исправьте ошибку!</p>
<a class="header" href="print.html#aИсправление-ошибок" id="aИсправление-ошибок"><h4>Исправление ошибок</h4></a>
<p>Пожалуйста, попытайтесь поэкспериментировать с доступом к функциям  и посмотрите
на описания ошибок!</p>
<p>Далее, мы поговорим об использовании ключевого слова <code>use</code>.</p>
<a class="header" href="print.html#aИмпорт-имён" id="aИмпорт-имён"><h2>Импорт имён</h2></a>
<p>Мы изучили как вызывать функции, определённые в модуле используя имена модулей, как
часть вызова. Пример 7-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {
                println!(&quot;nested_modules&quot;);
            }
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">Пример 7-6: Вызов функции, указав полный к ней путь</span></p>
<p>Как вы видите, указание полного пути к функции весьма утомительно. Конечно же, в Rust
имеется функционал упрощающий вызов функций.</p>
<a class="header" href="print.html#aКраткий-импорт-Использование-use" id="aКраткий-импорт-Использование-use"><h3>Краткий импорт. Использование <code>use</code></h3></a>
<p>Использование ключевого слова <code>use</code> сокращает указание полного пути к функции, которую
вы хотите использовать в определённой области видимости. Пример применения <code>use</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {
                println!(&quot;nested_modules&quot;);
            }
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p>Строка <code>use a::series::of;</code>, что в данной области видимости могут использовать элементы,
которые находятся в модуле <code>of</code>. Их можно вызывать просто указывая префикс имени этого
модуля <code>of::</code>.</p>
<p>В область видимости попадают только элементы модуля. Подчиненные модуле не включаются.
Если в этом будет необходимость - надо явным образом это указать.
Поэтому укажем <code>of::nested_modules</code>, вместо <code>nested_modules</code>.</p>
<p>Чтобы не указывать имя модуля можно выполнить т.н. статический импорт функции в
область видимости:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {
                println!(&quot;nested_modules&quot;);
            }
        }
    }
}
use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>Такой способ импорт даёт нам возможность сокращать список импорта.</p>
<p>Очень интересная возможность импорта значений перечислений!
Т.к. перечисления можно назвать разновидность пространств имеет, то можно указать
только необходимые элементы перечисления при импорте:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;

    println!(&quot;{:?}&quot;,red);
    println!(&quot;{:?}&quot;,yellow);
    println!(&quot;{:?}&quot;,green);
}
</code></pre></pre>
<p>Так как мы не включили <code>TrafficLight</code> в список импортированных значений перечисления,
то для его использования нам необходимо указать полный путь до этого элемента.</p>
<a class="header" href="print.html#aИмпорт-всех-элементов-с-помощью-" id="aИмпорт-всех-элементов-с-помощью-"><h3>Импорт всех элементов с помощью <code>*</code></h3></a>
<p>Есть ли возможность импортирования всех элементов выбранного пространсва имён?!
Да. Есть. Используйте <code>*</code>:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p>Символ <code>*</code> называют <em>glob</em> и его функция - импорт всех элементов, видимых извне
пространства имён. Обратите также внимание, что наряду с удобствами, существуют
также недоставки использования полного импорта пространства имён, т.к. это может привести
к конфликтными или неожиданным ситуациями, когда в разных пространствах имён существуют
одинаковые (по имени) функции, которые будут импортироваться.
Пример:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of1 {
            pub fn nested_modules() {
                println!(&quot;nested_modules 1&quot;);
            }
        }
        pub mod of2 {
            pub fn nested_modules() {
                println!(&quot;nested_modules 2&quot;);
            }
        }
    }
}
use a::series::of1::*;
use a::series::of2::*;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>Описание ошибки:</p>
<pre><code>error: `nested_modules` is ambiguous
  --&gt; src/main.rs:19:5
   |
19 |     nested_modules();
   |     ^^^^^^^^^^^^^^
   |
note: `nested_modules` could refer to the name imported here
  --&gt; src/main.rs:15:5
   |
15 | use a::series::of1::*;
   |     ^^^^^^^^^^^^^^^^^^
note: `nested_modules` could also refer to the name imported here
  --&gt; src/main.rs:16:5
   |
16 | use a::series::of2::*;
   |     ^^^^^^^^^^^^^^^^^^
   = note: consider adding an explicit import of `nested_modules` to disambiguate
</code></pre>
<a class="header" href="print.html#aДоступ-к-функционалу-родительского-модуля-с-помощью-super" id="aДоступ-к-функционалу-родительского-модуля-с-помощью-super"><h3>Доступ к функционалу родительского модуля с помощью <code>super</code></h3></a>
<p>Как вы помните, при создании библиотеки Cargo предлагает использовать модуль <code>tests</code>.
Сейчас разберёмся подробнее. Добавим код теста в исходный код файла <em>src/lib.rs</em>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
</code></pre>
<p>В главе 11  подробно рассказывается о тестировании. Сейчас мы только немного расскажем.
Обратите внимание на специальную аннотацию и то что это отдельный модуль в нашем коде.
Модульная система нашего проекта теперь имеет вид:</p>
<pre><code class="language-text">communicator
 ├── client
 ├── network
 |   └── client
 └── tests
</code></pre>
<p>Тесты помогат отлаживать код библиотеки. Напишем наш первый тест. Он будет вызывать
функцию <code>client::connect</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Выполнение тестов осуществляется командой<code>cargo test</code>:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^^^^^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>Почему-то компиляция прошла неуспешно. Почему же? Нам не надо добавлять префикс
библиотеки <code>communicator::</code>, т.к. мы находимся внутри неё.</p>
<p>Как же вызвать функцию <code>client::connect</code> из модуля <code>tests</code>? В модуле <code>tests</code> мы
можем указать что мы хотим начать поиски модулей с корневого модуля:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>Или мы можем использовать <code>super</code> для того чтобы переместиться по модульной иерархии
на один уровень выше текущаего модуля:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>Эти две опции выглядят одинаковыми в этом примере. Если находитесь глубоко
внутри модульной иерархии, то начиная с корневого модуля ваш код будет длинным.
Есть случаи, когда использование <code>super</code> более удобно.</p>
<p>Это бывает утомительно печать <code>super::</code> в каждом тесте. Есть решение <code>use</code>.
Функциональность <code>super::</code> изменяет путь, который вы используете в <code>use</code>.</p>
<p>Для тех случаев, когда вы пишите тесты к библиотекам использование <code>use super::something</code>
наилучшее решение.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Когда вы теперь выполните команду <code>cargo test</code>  вы увидите следующий вывод:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<a class="header" href="print.html#aИтоги-4" id="aИтоги-4"><h2>Итоги</h2></a>
<p>Теперь вы знаете ещё один способ, как можно организовать ваш код. Её можно использовать
для группировки различных элементов вместе, при рефакторинг большого количества
кода.</p>
<p>Далее, мы рассмотрим структуры данных стандартной библиотеки.</p>
<a class="header" href="print.html#aКоллекции-стандартной-библиотеки" id="aКоллекции-стандартной-библиотеки"><h1>Коллекции стандартной библиотеки</h1></a>
<p>Стандартная библиотека содержит полезные структуры данных, которые называются
<em>коллекциями</em>. Другие типы данных представляют собой хранение какого-то одного типа
данных. Особенностью коллекций является хранение множества однотипных данных.
В отличии от массива и кортежа, данных хранятся в куче, а это значит, что размер
коллекций может быть неизвестен в момент компиляции программы. Она может изменяться
(увеличиваться, уменьшаться) во время работы программы. Каждый вид коллекции имеет
свои особенности и ограничения производительности. Выбор конкретной коллекции зависит
от целей, которые необходимо решить. В этой главе будет рассмотрено несколько
коллекций:</p>
<ul>
<li><em>Вектор</em> позволяет нам сохранять данные последовательно.</li>
<li><em>Строка</em> - последовательность символов. В этой главе мы поговорим о этом типе данных подробнее.</li>
<li><em>Хеш таблица</em> позволяет сопоставлять значение ключу. Это реализация структуры <em>map</em>.</li>
</ul>
<p>Для того, чтобы узнать о других видах коллекций, пожалуйста, перейдите на страницу
документации <a href="https://doc.rust-lang.org/std/collections/index.html">the documentation</a>.</p>
<p>Мы начинаем свой рассказ с того, как создать и обновить вектора, строки и хэш таблицы.</p>
<a class="header" href="print.html#aВекторы" id="aВекторы"><h2>Векторы</h2></a>
<p>Первым видом коллекции, который мы разберем будет <em>вектор</em> <code>Vec&lt;T&gt;</code>. Вектора могут
сохранять множество данных в одной структуре, сохраняя данные один за одним. Данные
могут быть только одного типа. Этот тип данных удобен, когда нужно иметь список
данных.</p>
<a class="header" href="print.html#aСоздание-нового-вектора" id="aСоздание-нового-вектора"><h3>Создание нового вектора</h3></a>
<p>Для создания нового вектора используется функция <code>Vec::new</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let v: Vec&lt;i32&gt; = Vec::new();
    print!(&quot;{:?} &quot;, v);


}
</code></pre></pre>
<p>Обратите внимание, что мы добавили описание (аннотацию) типа данных. Очень важным
момент: пока мы не добавим хотя бы один элемент в вектор, компилятор (Rust) не будет
знать, что за тип данных будет содержать в этой коллекции. Как мы уже говорили,
вектор может содержать только один тип данных. Это его особенность.</p>
<p>Более удобный способ инициализации вектора - с помощью макроса <code>vec!</code> (по умолчанию
тип числовых данных i32):</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let v = vec![1, 2, 3];
   println!(&quot;{:?}&quot;,v);
}

</code></pre></pre>
<p>Так как мы создали коллекцию скалярных значений, то компилятор на основе типов
данных самостоятельно установит тип данных вектора.
Интересно, кой тип данных будет у вектора, если сделать такие изменения в коде
инициализации:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let v = vec![1, 2, (3 as u64)];
   println!(&quot;{:?}&quot;,v);
}

</code></pre></pre>
<p>В следующей секции вы узнаете, как изменить содержания коллекции вектор.</p>
<a class="header" href="print.html#aИзменение-вектора" id="aИзменение-вектора"><h3>Изменение вектора</h3></a>
<p>Для заполнения вектора данными, используется метод <code>push</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   //let mut v = Vec::new();
   let mut v = vec![];
    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
    println!(&quot;{:?}&quot;,v);
}
</code></pre></pre>
<p>Обратите внимание, что мы использовали <code>mut</code> для того, чтобы была возможность
изменять значения переменной. Компилятор определяет тип данных после добавления
первого элемента в коллекцию.</p>
<a class="header" href="print.html#aУдаление-элементов-из-вектора" id="aУдаление-элементов-из-вектора"><h3>Удаление элементов из вектора</h3></a>
<p>По работе памяти с объектами вектор ведёт себя также как и структура. Память, занимаемая
вектором очищается после выхода кода за пределы области видимости:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v

} // &lt;- v goes out of scope and is freed here
#}</code></pre></pre>
<p>При удалении коллекции, удаляется всё её содержимое. Есть кое-какие особенности в
этом процессе, которые мы обсудим далее.</p>
<a class="header" href="print.html#aЧтение-данных-вектора" id="aЧтение-данных-вектора"><h3>Чтение данных вектора</h3></a>
<p>Следующим навыком, который вам пригодится при работе с векторами - это чтение
содержания. Существует два способа получения ссылке на данные: по индексу и с помощью
метода <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;{}&quot;, third);
    let third: Option&lt;&amp;i32&gt; = v.get(2);
    println!(&quot;{:?}&quot;, third);
}

</code></pre></pre>
<p>Содержимое вектора индексируется по номерам начиная с 0. Второй способ - использовать
метод <code>get</code>,  который возвращает <code>Option&lt;&amp;T&gt;</code>. Каждый из этих способов имеет свои
плюсы и минусы. Плюсы. Первый быстрый, второй надёжный (при ошибке выбора индекса
программа, аварийно, прекращает работу, а при втором просто возвращает <code>None</code>).
Какой способ доступа к данным выбрать зависит он контекста и целей программы.</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<pre><code></code></pre>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3, 4, 5];
    println!(&quot;{}&quot;, v[100]);
    //println!(&quot;{}&quot;, &amp;v[100]);
}
</code></pre></pre>
<pre><code>thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 100', /checkout/src/liballoc/vec.rs:1555:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3, 4, 5];
    println!(&quot;{}&quot;, v[100]);
}
</code></pre></pre>
<pre><code>None
</code></pre>
<a class="header" href="print.html#aНеправильные-ссылки" id="aНеправильные-ссылки"><h4>Неправильные ссылки</h4></a>
<p>Освежите в памяти правила заимствования, ссылочной целостности, с которыми мы
познакомились в главе 4! Здесь мы ещё раз  посмотрим на их работу в действии в контексте
работы с векторами:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>Получим ошибку компиляции:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Правильный код будет иметь вид:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    v.push(6);
    let first = &amp;v[0];

    //v.push(6);

    println!(&quot;{:?}&quot;, v);
    println!(&quot;{}&quot;, first);
}
</code></pre>
<p>Такие строгие ограничения существуют для того, чтобы исключить ошибку</p>
<blockquote>
<p>Более подробно об этом читайте на странице
<em>https://doc.rust-lang.org/stable/nomicon/vec.html</em>.</p>
</blockquote>
<a class="header" href="print.html#aИспользование-перечисления-для-хранения-множества-разных-типов" id="aИспользование-перечисления-для-хранения-множества-разных-типов"><h3>Использование перечисления для хранения множества разных типов</h3></a>
<p>В начале этой главы мы выяснили, что вектор может хранить только однотипные данные.
Бывают ситуации, когда нужно хранить разные типы данных. В этом нм помогу перечисления.</p>
<p>Приведем пример. К примеру, нам надо получить данные из строки ячеек данных, где
разные колонки хранят разные типы данных (целые числа, дробны числа, строки).
Создадим вектор, который будет содержать элементы перечисления:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    #[derive(Debug)]
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
    println!(&quot;{:?}&quot;, row);
}
</code></pre></pre>
<p><span class="caption">Пример 8-1: Определение перечисления, которое будет иметь возможность
содержать различные типы данных в векторе</span></p>
<p>Компилятору, обязательно, надо знать, какой тип данных будет у вектора во время
компиляции, для того, чтобы рассчитать сколько памяти нужно будет выделить в куче
для хранения одного элемента. Также используя перечисление и  <code>match</code> можно будут
обработаны все возможные варианты.</p>
<a class="header" href="print.html#aСтроки" id="aСтроки"><h2>Строки</h2></a>
<p>Мы уже говорили о строках в предыдущих главах. Сейчас мы рассмотрим работу с этим
типом данных более подробно. Этот тип данных в Rust сложен для понимания начинающими
программистами, т.к. это комбинация трёх(!) элементов.
Строки являются коллекциями байтов, интерпритируемых как текст. Кроме того, строки
имеют свои специфические методы. В этой главе мы рассмотрим отличительныe черты
данной коллекции, а также обратим внимание на то как строки интерпретируются.</p>
<a class="header" href="print.html#aЧто-же-такое-строка" id="aЧто-же-такое-строка"><h3>Что же такое строка?</h3></a>
<p>Что же значит <em>строка</em>. В самом Rust есть только один строковый тип данных <code>str</code>.
Это отрезок данных, обычно получаемый по ссылке <code>&amp;str</code>. Это ссылка на текстовые
данные формата UTF-8. Код типа данных <code>String</code> входит в состав стандартной библиотеки.
Этот тип может изменяться, можно использовать при владении. Когда в Rust говорят
о работе со строками то, обычно, имеют ввиду <code>String</code> и срез строковых данных <code>&amp;str</code>.
Оба этих типа данных манипулируют данными в кодировке UTF-8. В этой секции мы поподробнее
остановимся на <code>String</code>.</p>
<p>В стандартную библиотеку Rust также входят и другие типы, которые манипулируют строковыми
данными. Это <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, и <code>CStr</code>. Кроме того сторонние библиотеки
могут предлагать ещё больше опций. Если вы хотите узнать о других типах данных,
которые работаю со строками, пожалуйста, обратитесь к документации.</p>
<a class="header" href="print.html#aСоздание-новых-строк" id="aСоздание-новых-строк"><h3>Создание новых строк</h3></a>
<p>Те операции, которые возможны в <code>Vec</code> также возможны в <code>String</code>. Метод <code>new</code> создаёт
новую строку:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>Это выражение создаёт новую стоку <code>s</code>, в которую потом можно будет загрузить данные.</p>
<p>Часто, в каком-нибудь типе данных нам надо получить состояние объекта. Для этого
используется метод <code>to_string</code>, который реализован во многих типах данных, которые
реализовали поведение <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>Эти выражения создают строку с  <code>initial contents</code>.</p>
<p>Мы также можем использовать функцию <code>String::from</code> для создания <code>String</code> из литерала.
Это эквивалент использованию фикции <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>Так как строки используются для различных целей, например, интенсивно применяются в
различных API. Некоторый из опций строк кажутся избыточными, но весьма удобны.
Некоторые функции имеют одинаковые действия, хотя имеют различные свойства.
Например, <code>String::from</code> и <code>.to_string</code>. Выбор использованной функции, порой, зависит
от стиля программирования.</p>
<p>Так как строки закодированы в кодировке UTF-8, мы можем использовать тексты на различных
языках:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;السلام عليكم&quot;;
let hello = &quot;Dobrý den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;שָׁלוֹם&quot;;
let hello = &quot;नमस्ते&quot;;
let hello = &quot;こんにちは&quot;;
let hello = &quot;안녕하세요&quot;;
let hello = &quot;你好&quot;;
let hello = &quot;Olá&quot;;
let hello = &quot;Здравствуйте&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#aОбновление-строковых-данных" id="aОбновление-строковых-данных"><h3>Обновление строковых данных</h3></a>
<p>Данные переменой типа <code>String</code> в процессе своей жизни могут изменять своё содержание,
также как <code>Vec</code>. Кроме того, <code>String</code> могут быть объедены с помощью операции <code>+</code>.</p>
<a class="header" href="print.html#aДобавление-данных-с-помощью-push" id="aДобавление-данных-с-помощью-push"><h4>Добавление данных с помощью push</h4></a>
<p>Мы можем добавить данные с помощью метода <code>push_str</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
    println!(&quot;{}&quot;, s);
}

</code></pre></pre>
<p>Результатом работы кода будет вывода на экран <code>foobar</code>. Метод <code>push_str</code> получает
отрезок символьных данных в качестве параметра. Переменная <code>s</code> будет содержать
строку “foobar”.</p>
<p>Метод <code>push_str</code> получает срез в качестве параметра, т.к. для использования
данного типа данных вдадение не нужно. К примеру, было бы очень жаль, если бы
вы не имели бы возможности использовать данные переменной <code>s2</code> после добавления её
содержания в переменную <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = String::from(&quot;bar&quot;);
    s1.push_str(&amp;s2);
    println!(&quot;{}&quot;, s1);
    println!(&quot;{}&quot;, s2);
    println!(&quot;{}&quot;, s2);
}

</code></pre></pre>
<p>Метод <code>push</code> имеет в качестве параметра символьную переменную и добавляет её в
массив символов строки <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>После этого, переменная <code>s</code> будет содержать “lol”.</p>
<a class="header" href="print.html#aОбъединение-с-помощью-оператора--или-макроса-format" id="aОбъединение-с-помощью-оператора--или-макроса-format"><h4>Объединение с помощью оператора + или макроса <code>format!</code></h4></a>
<p>Весьма часто приходится объединять строки. Один из возможных способов - использование
оператора <code>+</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // Note that s1 has been moved here and can no longer be used
    println!(&quot;{}&quot;, s3);
}

</code></pre></pre>
<p>Результат - вывод строки <code>Hello, world!</code>. Причина такой вот жёсткой конструкции
оператора объединения - использование метода <code>add</code>:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Это не точное определение метода <code>add</code> стандартной библиотеки. Этот метод использует
обобщения (т.н. дженерики). К <code>String</code> мы можем добавлять только <code>&amp;str</code>. Также метод
<code>add</code> использует получение данных по ссылке так что если даже второй параметр
имеет тип <code>String</code> всё равно он преобразуется в <code>str</code>.</p>
<p>Также обратите внимание, что первый параметр отдаётся во владение, поэтому его
дальнейшее использование невозможно.</p>
<p>Для объединения множества строк оператор <code>+</code> не очень нагляден:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
    println!(&quot;{}&quot;, s);
}

</code></pre></pre>
<p>Есть лучшее решение - макрос <code>format!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
    println!(&quot;{}&quot;, s);
}

</code></pre></pre>
<p>Такое решение более предпочтительно, т.к. в последующих строках все переменые
можно использовать.</p>
<a class="header" href="print.html#aИндексация-в-string" id="aИндексация-в-string"><h3>Индексация в String</h3></a>
<p>Во многих языках программирования для получения символа из строки достаточна сослаться
на него по индексу. В Rust это приведёт к ошибке:</p>
<pre><code class="language-rust ignore">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
    println!(&quot;{}&quot;, h);
}

</code></pre>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{integer}&gt;` is not satisfied
 --&gt;
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`
</code></pre>
<p>Глубинная причина не реализованности этой опции в системе хранения строк в памяти.</p>
<a class="header" href="print.html#aВнутренее-представление" id="aВнутренее-представление"><h4>Внутренее представление</h4></a>
<p>Тип <code>String</code> это объертка <code>Vec&lt;u8&gt;</code>. Прежде всего, рассмотрим пример:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let len = String::from(&quot;Hola&quot;).len();
    println!(&quot;{}&quot;, len);
}

</code></pre></pre>
<p><code>len</code> содержит 4. Это значит, что вектор <code>Vec</code> содержит строку “Hola” состоящую из
4 байт. Рассмотрим другой пример:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let len = String::from(&quot;Здравствуйте&quot;).len();
    println!(&quot;{}&quot;, len);
}

</code></pre></pre>
<p>В данном случает <code>len</code> содержит 24. Каждый символ закодирован двумя байтами.</p>
<p>В качестве примера, рассмотрите этот некорректный Rust код:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Этот код также не скомпилируется.</p>
<a class="header" href="print.html#aБайты-скалярные-значения-и-графемные-кластеры" id="aБайты-скалярные-значения-и-графемные-кластеры"><h4>Байты, скалярные значения и графемные кластеры</h4></a>
<p>В Rust можно оперировать UTF-8 данными тремя способами: байтами, скалярными значениями
и графемными кластерами (наиболее близкое к понятию символов).</p>
<p>Если мы посмотрим на слова в хинди “नमस्ते”, в векторном виде (в виде байт) оно будет
выглядеть следующим образом:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Это 18 байт. Если мы посмотрим на скалярные данные Rust <code>char</code>, то они будут выглядеть
слудующим образом:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Это 6 симвлов <code>char</code>, но 4 и 6 - это не символы, это диакртики (вспомогательные символы).
И наконец, посмотрим на графемные кластеры:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Вам решать, какой способ представления строковых данных Вам удобно для решения задачи.</p>
<p>Ещё одна причина по которой Rust не позволяет получать символ по индексу, это
постоянная сложность данной операции (O(1)). Это ухудшает производительность
программ и поэтому не используется.</p>
<a class="header" href="print.html#aСрезы-строк" id="aСрезы-строк"><h3>Срезы строк</h3></a>
<p>Если Вам действительно нужно массив байтов из сроки - используйте срезы:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Здесь <code>s</code> типа данных <code>&amp;str</code>, которая будет содержать четыре первых байта.
В данном случае это будет “Зд”.</p>
<p>А что произойдет при такой выборке данных <code>&amp;hello[0..1]</code>? Ответ - ошибка времени
выполнения, такая же если бы Вы попытались получить значение несуществующего индекса
вектора:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `Здравствуйте` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>Пожалуйста, используйте срезы строковых данных с осторожностью, тщательно тестируйте
подобные участки кода!</p>
<a class="header" href="print.html#aМетоды-итерации" id="aМетоды-итерации"><h3>Методы итерации</h3></a>
<p>Сейчас поговорим о предпочтительных способах доступа к элементам строки.</p>
<p>Если Вам необходимо производить операции над юникод-элементами строки, наилучший
способ - использовать метод <code>chars</code>. Вызов <code>chars</code> из “नमस्ते” разделяет и возвращает
6 значений типа <code>char</code>. Далее, вы можете производить итерации для получения элементов
этой строки:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for c in &quot;नमस्ते&quot;.chars() {
        println!(&quot;{}&quot;, c);
    }
}

</code></pre></pre>
<p>Будет напечатано:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>Метод <code>bytes</code> возвращает очередной байт при каждой итерации:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for b in &quot;नमस्ते&quot;.bytes() {
        println!(&quot;{}&quot;, b);
    }
}
</code></pre></pre>
<p>Этот код напечатает 18 байт, из которых состоит данные строки:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>Работая с байтами, пожалуйста, учитывайте тот факт, что значение одного символа
может состоять из более одного байта.</p>
<p>Получение графемных кластеров из строки весьма сложное дело, поэтому этот функционал
не входит в стандартную библиотеку. Но существуют дополнительные библиотеки, которые
решают эту задачу.</p>
<a class="header" href="print.html#aСтроки---это-сложно" id="aСтроки---это-сложно"><h3>Строки - это сложно</h3></a>
<p>Это, действительно, сложно. Каждый язык программирования старается найти своё
решение трудной задачи обработки, работы со строками. Методология Rust призвана
сократить ошибки, поэтому функционал работы со строками реализован подобным образом.</p>
<p>Далее будет рассмотрена менее сложная тема - hash maps!</p>
<a class="header" href="print.html#hash-maps" id="hash-maps"><h2>Hash Maps</h2></a>
<p>Последняя коллекция, которую мы рассмотрим в нашей книге будет <em>hash map</em>.
<code>HashMap&lt;K, V&gt;</code> сохраняет ключи типа <code>K</code> и значения типа <code>V</code>. Данная структура организует и хранит данные
с помощью <em>функции хэширования</em>. Во множестве библиотек языков программирования
реализована данная структура и функционал. Все они, что неудивительно, имеют разные
наименования: hash, map, object, hash table, или ассоциированный массив.</p>
<p>Использование <code>HashMap&lt;K, V&gt;</code> удобно, когда доступ к элементам структуры необходимо
осуществлять по ключу (который может иметь любой тип). Например, в игре, вы можете
сохранять счет игроков в хэше, где имя игрока - это ключ, значение - счёт. По имени
игрока вы можете получить его счёт.</p>
<p>В этой главе мы рассмотрим только основные возможности API HashMap. Более подробную
информацию вы можете получить в документации.</p>
<a class="header" href="print.html#aСоздание-нового-hashmapk-v" id="aСоздание-нового-hashmapk-v"><h3>Создание нового HashMap&lt;K, V&gt;</h3></a>
<p>С помощью метода <code>new</code> можно создать новый HashMap&lt;K, V&gt;. Метод <code>insert</code>
предназначен для добавления элементов.
Пример:</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);
    println!(&quot;{:?}&quot;, scores);
}
</code></pre></pre>
<p>Обратите внимание на необходимость импорта <code>HashMap</code>. Эта коллекция не имеет
создающего макроса.</p>
<p>Также как и вектор, данные хранятся в куче. Также как и вектор <code>HashMap</code> имеет
однародную структуру.</p>
<p>Ещё один способ создания <code>HashMap</code>, использование метода вектора кортежей <code>collect</code>,
где каждый кортеж содержит ключ и его значение. Этот метод может объединять любые
типы данных, даже <code>HashMap</code>. Например, если у нас есть список команд и значения
счёта этих команд в двух различных векторах, мы можем использовать метод <code>zip</code>,
чтобы создать вектор кортежей где элементы с одинаковыми индексами образуют пары
&quot;ключ-значение&quot;. Далее, мы можем использовать метод <code>collect</code> для создания `HashMap:</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    use std::collections::HashMap;

    let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
    let initial_scores = vec![10, 50];

    let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
    println!(&quot;{:?}&quot;, scores);
}
</code></pre></pre>
<p>Такой необычный тип данных <code>HashMap&lt;_, _&gt;</code> необходим, т.к. метод <code>collect</code> может
содержать данные разных типов и Rust не может заранее проверить их соответствие.</p>
<a class="header" href="print.html#aВладение-1" id="aВладение-1"><h3>Владение</h3></a>
<p>Для типов данных, которые реализовали поведение <code>Copy</code>, значения копируются в хэш:</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;Blue&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point
    println!(&quot;{:?}&quot;, map);
}
</code></pre></pre>
<p>После внесения данные в хэш строковые переменные уже не действительны.
Если так случается, что в хэш вносятся ссылки, значение этих ссылочных данных
должно быть действительным до конца срока жизни хэша. Более подробно об этом мы
поговорим в главе 10.</p>
<a class="header" href="print.html#aДоступ-к-данным" id="aДоступ-к-данным"><h3>Доступ к данным</h3></a>
<p>Для получения данных из <code>HashMap</code> используется метод <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name);
    println!(&quot;{} {:?}&quot;, team_name, score);
}

</code></pre></pre>
<p>Здесь установлено соответствие <code>Blue</code> значению <code>score</code>. В результате выборки данных
по ключу мы получим <code>Some(&amp;10)</code>. Результат содержится в <code>Some</code>, т.к. <code>get</code>
возвращает <code>Option&lt;&amp;V&gt;</code>.  Если данные не были найдены, то возвращается <code>None</code>.</p>
<p>Обход данных (пар &quot;ключ-значение&quot;) в хэш:</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{}: {}&quot;, key, value);
    }
}

</code></pre></pre>
<p>Результат:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#aОбновление-данных" id="aОбновление-данных"><h3>Обновление данных</h3></a>
<p>В то время, как количество ключей и значений растёт, каждый уникальный ключ
может иметь только одно значение, ассоциированное с ним. Если вы хотите изменить
это значение, вы должны решить каким образом это лучше сделать. Можно заменить
старое значение на новое, вы можете оставлять старое и игнорировать новое, добавляя
только новые значения. Или вы можете комбинировать старые и новые значения.</p>
<a class="header" href="print.html#aПерезаписывание-старых-данных" id="aПерезаписывание-старых-данных"><h4>Перезаписывание старых данных</h4></a>
<p>Если мы внесём ключ и значение в хэш, а потом внесём этот же ключ с другим значением,
значение замениться. Несмотря на то, что метод <code>insert</code> вызывается дважды, сохраняется
только одна пара &quot;ключ-значение&quot;:</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);

    println!(&quot;{:?}&quot;, scores);
}

</code></pre></pre>
<p>Будет напечатано <code>{&quot;Blue&quot;: 25}</code>. Первое значение 10 будет перезаписано.</p>
<a class="header" href="print.html#aВнесение-данных-в-хэш-только-если-нет-данных" id="aВнесение-данных-в-хэш-только-если-нет-данных"><h4>Внесение данных в хэш, только если нет данных</h4></a>
<p>Весьма часто необходимо знать присвоено ли определенному ключу какое-либо значение.
Если не присвоено - привязать к этому ключу значение. <code>HashMap</code> имеет специальную
API для этой цели - <code>entry</code>, которая получает ключ в качестве аргумента. Результатом
работы этой функции является значение перечисления <code>Entry</code>. Давайте проверим есть
ли значени по ключу <code>Yellow</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
}

</code></pre></pre>
<p>Метод <code>or_insert</code> перечисления <code>Entry</code> возвращает значение ключа <code>Entry</code> если он
существует, и если он не существует, сохраняет новое значение. Этот метод весьма
удобен.</p>
<p>Результат - будет напечатано <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>.</p>
<a class="header" href="print.html#aОбновление-значения-основанное-на-предыдущих-данных" id="aОбновление-значения-основанное-на-предыдущих-данных"><h4>Обновление значения основанное на предыдущих данных</h4></a>
<p>Ещё один весьма распространённый способ использования хэш, это поиск значений
основанных на предыдущем. К примеру, если вы хотите посчитать сколько раз слово
встречается в тексте, вы можете использовать хэш со словом в качестве ключа и
увеличивать на единицу каждый раз, когда вы будете встречать это слово.</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {

    let text = &quot;hello world wonderful world&quot;;

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!(&quot;{:?}&quot;, map);
}

</code></pre></pre>
<p>Будет напечатано <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. Метод <code>or_insert</code>
возвращает изменяемую ссылку (<code>&amp;mut V</code>) по ключу. Мы сохраняем изменяемую ссылку
в переменной <code>count</code>. Для того, чтобы присвоить переменной значение, необходимо
произвести разименование с помощью звёздочки (<code>*</code>). Изменяемая ссылка удаляется
сразу же после выхода из области видимости цикла <code>for</code>. Все эти изменения безопасны
и согласуются с правилами заимствования.</p>
<a class="header" href="print.html#aФункция-хэширования" id="aФункция-хэширования"><h3>Функция хэширования</h3></a>
<p>По умолчанию <code>HashMap</code> использует криптографическую защитную функцию, которая может
противостоять DOS-атакам. В этой реализации используется не самый быстрый алгоритм
хэширования, но достаточно защищенный. Если после профилирования вашего кода окажется,
что хэш функция очень медленная, вы можете её заменить на другую подобную функцию
(<em>hasher</em>). Эта функция реализует поведение <code>BuildHasher</code>. Подробнее о поведении
вы узнаете в главе 10. Вам совсем не обязательно реализовывать свою собственную функцию
хэширования. crates.io имеет достаточное количество библиотек для этих целей.</p>
<a class="header" href="print.html#summary-1" id="summary-1"><h2>Summary</h2></a>
<p>Векторы, строки и хэш-карты помогают вам, когда необходимо сохранять, получать доступ
и модифицировать данные. Для закрепления рассмотренного материала, пожалуйста,
выполните следующие учебные задания:</p>
<ul>
<li>Есть список целых чисел. Создайте функцию, входной параметр, которой вектор и возвращает: среднее; медиану (значение центрального элемента списка); значение, которое есть в списке набольшее количество раз.</li>
<li>Сконвертируюйте строку в Pig Latin, где первая согласная каждого слова перемещается в конец и добавлением окончания “ay”. Пример, “first” - “irst-fay”. Если слово начинается на гласную, добавляет в конец слова суффикс “hay”. Пример,   “apple” - “apple-hay”.</li>
<li>Используя хэш мапы и векторы, создайте программу, позволяющую принимать текстовые данные и хранить структуры информации. Необходимо иметь возможность вводить имя работника в отдел компании. Например, добавьте Александра в отдел инжиниринга, добавьте Эмира в отдел продаж. Далее предоставьте возможность получить список всех введенных работников. Отсортируйте эти данные в алфавитном порядке, сгруппируйте данные по отделам.</li>
</ul>
<p>Документация к стандартной библиотеке достаточно подробна и будет вам помогать в
решении поставленных задач.</p>
<p>В следующей главе мы рассмотрим работу с ошибками и сообщениями о них. Как их предотвратить
и как описать ошибки.</p>
<a class="header" href="print.html#aОбработка-ошибок" id="aОбработка-ошибок"><h1>Обработка ошибок</h1></a>
<p>В языке Rust и в стандартной библиотеке есть средства обработки ошибок. В большинстве
случаев, Rust делает множество проверок, чтобы избежать ошибок, но их всё же недостаточно,
чтобы исключить их вовсе.</p>
<p>В Rust ошибки делятся на две большие группы: обрабатываемые и необрабатываемые.
Обрабатываемые ошибки случаются, когда, например, файл не найден. К необрабатываемым
ошибками, т.н. багам кода относятся обращения к неверному индексу массива.</p>
<p>Во многих языках эти виды ошибок не разделяют каким-либо образом. Rust не имеет
механизма обработки ошибок. Вместо этого есть значения типа <code>Result&lt;T, E&gt;</code> для
обрабатываемых ошибок и макрос <code>panic!</code>, который останавливает выполнение программы,
когда происходит необрабатываемая ошибка. В конце главы мы поделится методами оценки
проблем: как следует поступить, если произошла ошибка - обработать исключительную
ситуацию или следует остановить выполнение программы.</p>
<a class="header" href="print.html#aНеобрабатываемые-ошибки-с-помощь-макроса-panic" id="aНеобрабатываемые-ошибки-с-помощь-макроса-panic"><h2>Необрабатываемые ошибки с помощь макроса <code>panic!</code></h2></a>
<p>Бывает, что ошибки случаются и ничего с этим нельзя поделать. В таких случаях Rust
предлагает использовать макрос <code>panic!</code>. Когда этот макрос выполняется программа
печатает сообщене об ошибке, очищается стеки данных и затем программа завершает свою
работу. Весьма часто бывает, что нельзя предугадать появление ошибки.</p>
<blockquote>
<a class="header" href="print.html#unwinding-the-stack-versus-aborting-on-panic" id="unwinding-the-stack-versus-aborting-on-panic"><h3>Unwinding the Stack Versus Aborting on Panic</h3></a>
<p>По умолчанию, когда срабатывает макрос <code>panic!</code>, программа входит в определенное
состояние, при котором очищаются стеки и данные каждой функции. Происходит много
служебных действий, гарантирующих удаление устаревших данных, очисти буферов и пр.
Есть также возможность просто мгновенно прервать работу программы без очистки
буферов, данных. При этом очистка буферов, данных ложиться на плечи операционной
системы. Самый простой вариант работы программы - это простое прерывание. При этом
программа будет иметь минимальных код.  Для этого просто добавьте текст <code>panic = 'abort'</code>
в соответствующую секцию <code>[profile]</code> файла конфигурации <em>Cargo.toml</em>.
Например, если вы хотите прерывания в релизных версиях вашей программы:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Вызов макроса <code>panic!</code> в программном коде:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>Строка вывода:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<a class="header" href="print.html#aИспользование-информационных-сообщений-макроса-panic" id="aИспользование-информационных-сообщений-макроса-panic"><h3>Использование информационных сообщений макроса <code>panic!</code></h3></a>
<p>Рассмотрим пример, где макрос <code>panic!</code> вызывается из библиотечных функций. В данном
примере ошибка в коде программы:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[100];
}
</code></pre></pre>
<p>Попытка доступа к несуществующему элементу привела к ошибке.</p>
<p>В таких языках, как C подобная ошибка приводит к переполнению буфера.</p>
<p>Для защиты от подобного рода ошибок в Rust останавливается работа программы.</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
100', /stable-dist-rustc/build/src/libcollections/vec.rs:1362
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
</code></pre>
<p>Здесь приводится ссылка на файл из стандартной библиотеки <em>libcollections/vec.rs</em>.
Это реализация <code>Vec&lt;T&gt;</code>.
<code>RUST_BACKTRACE</code> - это переменная системы. Если она установлена - происходит оповещение
о ошибке.</p>
<pre><code class="language-text">$ set RUST_BACKTRACE=1 &amp;&amp;cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 100', /stable-dist-rustc/build/src/libcollections/vec.rs:1392
stack backtrace:
   1:     0x560ed90ec04c - std::sys::imp::backtrace::tracing::imp::write::hf33ae72d0baa11ed
                        at /stable-dist-rustc/build/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:42
   2:     0x560ed90ee03e - std::panicking::default_hook::{{closure}}::h59672b733cc6a455
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:351
   3:     0x560ed90edc44 - std::panicking::default_hook::h1670459d2f3f8843
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:367
   4:     0x560ed90ee41b - std::panicking::rust_panic_with_hook::hcf0ddb069e7abcd7
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:555
   5:     0x560ed90ee2b4 - std::panicking::begin_panic::hd6eb68e27bdf6140
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:517
   6:     0x560ed90ee1d9 - std::panicking::begin_panic_fmt::abcd5965948b877f8
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:501
   7:     0x560ed90ee167 - rust_begin_unwind
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:477
   8:     0x560ed911401d - core::panicking::panic_fmt::hc0f6d7b2c300cdd9
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:69
   9:     0x560ed9113fc8 - core::panicking::panic_bounds_check::h02a4af86d01b3e96
                        at /stable-dist-rustc/build/src/libcore/panicking.rs:56
  10:     0x560ed90e71c5 - &lt;collections::vec::Vec&lt;T&gt; as core::ops::Index&lt;usize&gt;&gt;::index::h98abcd4e2a74c41
                        at /stable-dist-rustc/build/src/libcollections/vec.rs:1392
  11:     0x560ed90e727a - panic::main::h5d6b77c20526bc35
                        at /home/you/projects/panic/src/main.rs:4
  12:     0x560ed90f5d6a - __rust_maybe_catch_panic
                        at /stable-dist-rustc/build/src/libpanic_unwind/lib.rs:98
  13:     0x560ed90ee926 - std::rt::lang_start::hd7c880a37a646e81
                        at /stable-dist-rustc/build/src/libstd/panicking.rs:436
                        at /stable-dist-rustc/build/src/libstd/panic.rs:361
                        at /stable-dist-rustc/build/src/libstd/rt.rs:57
  14:     0x560ed90e7302 - main
  15:     0x7f0d53f16400 - __libc_start_main
  16:     0x560ed90e6659 - _start
  17:                0x0 - &lt;unknown&gt;
</code></pre>
<p><span class="caption">Listing 9-1: Подробное сообщение об ошибке, когда переменная
<code>RUST_BACKTRACE</code> установлена</span></p>
<p>Здесь мы видим описание всех функций, которые связана с данной проблемой.</p>
<a class="header" href="print.html#aОбрабатываемы-ошибки-и-result" id="aОбрабатываемы-ошибки-и-result"><h2>Обрабатываемы ошибки и <code>Result</code></h2></a>
<p>Множество ошибок не являются настолько критичными, чтобы останавливать выполнение
программы. Весьма часто необходим просто правильная их обработка. К примеру, при
открытии файла может произойти ошибка из-за отсутствия файла. Решения могут быть
разные: от игнорирования до создания нового файла.</p>
<p>Надеюсь, что вы ещё помните содержание главы 2, где мы рассматривали перечисление
<code>Result</code>. Оно имеет два значения <code>Ok</code> и <code>Err</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p><code>T</code> и <code>E</code> параметры перечисления. <code>T</code>  - это тип, которые будет возвращён, при
успехе, а <code>E</code> при ошибке.</p>
<p>Let’s call a function that returns a <code>Result</code> value because the function could
fail: opening a file, shown in Listing 9-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 9-2: Opening a file</span></p>
<p>Интересно, как узнать, какой тип возвращает метод <code>File::open</code>. Это просто. Надо
поставить тип  данных, который точно не подойдет и увидим тип данных в описании
ошибки:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>Информационное сообещение:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  = note:    found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>Всё, я думаю, ясно из описания.</p>
<p>Для обработки исключительной ситуации необходимо добавить следующий код:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listing 9-3: Использование выражения <code>match</code> для обработки
<code>Result</code></span></p>
<p>Обратите внимание, что перечисление <code>Result</code>, также как <code>Option</code> входит в состав
экспорта по умолчанию.</p>
<p>Здесь мы сообщаем значение <code>Ok</code> содержит значение типа <code>File</code> <code>file</code>.
Другое значение может хранить значение типа <code>Err</code>. В этом примере мы используем
вызов макроса <code>panic!</code>. Если нет файла с именем <em>hello.txt</em>, будет выполнен этот код.
Следовательно, будет выведено следующее сообщение:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:8
</code></pre>
<a class="header" href="print.html#aОбработка-различных-ошибок" id="aОбработка-различных-ошибок"><h3>Обработка различных ошибок</h3></a>
<p>Пример создание нового файла при отсутствии запрашиваемого файла:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
            Ok(fc) =&gt; fc,
            Err(e) =&gt; panic!(&quot;Tried to create file but there was a problem: {:?}&quot;, e),
        },
        Err(error) =&gt; panic!(&quot;There was a problem opening the file: {:?}&quot;, error),
    };
    print!(&quot;{:#?}&quot;,f);
}

</code></pre>
<p><span class="caption">Listing 9-4: Обработка различных ошибок несколькими способами</span></p>
<a class="header" href="print.html#aСокращенные-макросы-обработки-ошибок-unwrap-и-expect" id="aСокращенные-макросы-обработки-ошибок-unwrap-и-expect"><h3>Сокращенные макросы обработки ошибок <code>unwrap</code> и <code>expect</code></h3></a>
<p>Метод <code>unwrap</code> - это оболочка выражения <code>match</code>, которая возвращает <code>Ok</code> или <code>Err</code>.</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
    print!(&quot;{:#?}&quot;, f);
}

</code></pre></pre>
<p>Если мы выполним код без наличия файла <em>hello.txt</em>, будет выведена ошибка:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
/stable-dist-rustc/build/src/libcore/result.rs:868
</code></pre>
<p>Есть ещё один метод похожий на <code>unwrap</code>. Используя <code>expect</code> вместо <code>unwrap</code> и
предоставляющей хорошие информативные описания ошибок::</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
    print!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>Мы используем <code>expect</code> таким же образом, каким и <code>unwrap</code>: возвращаем ссылку на файл или
вызов макроса <code>panic!</code>.</p>
<a class="header" href="print.html#aГенерировании-ошибок" id="aГенерировании-ошибок"><h3>Генерировании ошибок</h3></a>
<p>Когда вы пишите функцию, в результате работы которой может произойти непредвиденная
ошибка, вместо того, чтобы обрабатывать эту ошибку вы можете создать подробное
описание этой и передать ошибку по цепочке на верхний уровень обработки кода.</p>
<p>Например, код программы 9-5 читает имя пользователя из файла. Если файл не существует
или не может быть прочтён, то функция возвращает эти ошибку в код, которые вызвал
эту функцию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-5: Эта функция, которая возвращает ошибки вызова
выражения <code>match</code></span></p>
<p>Давайте, рассмотрим тип возвращаемого значения <code>Result&lt;String, io::Error&gt;</code>.Если
эта функция будет выполнена успешно, будет возвращено <code>Ok</code>, содержащее значение
типа <code>String</code>. Если же при чтении файла будут какие-либо проблемы - <code>io::Error</code>.</p>
<p>Тело этой функции начинает с вызову функции <code>File::open</code>. Далее мы получаем результат
анализа результата чтения файла функцией <code>match</code>. Если функция <code>File::open</code> сработала
успешно, мы сохраняет ссылку на файл в переменную <code>f</code> и программа продолжает свою
работу.</p>
<p>Далее, мы создаём строковую переменную <code>s</code> и вызываем метод файла <code>read_to_string</code>,
которая читает содержание файла, как строковые данные в переменную <code>s</code>. Результатом
работы этой фунции будет знанчение перечисления <code>Result</code>: <code>Ok</code> или <code>io::Error</code>.</p>
<p>Этого же результата можно достичь с помощью сокращенного написания (с помощью использования
символа <code>?</code>).</p>
<a class="header" href="print.html#aСокращение-описание-match--" id="aСокращение-описание-match--"><h3>Сокращение описание <code>match</code>  <code>?</code></h3></a>
<p>Код программы 9-6 показывает реализацию функции <code>read_username_from_file</code>, функционал
которой аналогичен коду программы 9-5, но имеет сокрощённое описание:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><span class="caption">Код программы 9-6: Пример функции, которая возвращает ошибку,
используя символ <code>?</code></span></p>
<p>Благодаря и использованию символа <code>?</code> сокращается запись кода (код, написанный в
предыдущем примере создаётся компилятором самостоятельно).</p>
<p>В коде примера 9-6 в первой строке функция <code>File::open</code> возвращает содержимое значения
перечисления <code>Ok</code> в переменную <code>f</code>. Если же в при работе этой функции происходит
ошибка, будет возвращен экземпляр структуры <code>Err</code>. Те же самые действия произойдут
при чтении текстовых данных из файла с помощью функции <code>read_to_string</code>.</p>
<p>Использование сокращенных конструкций позволят уменьшить количество строк кода и
место потенциальных ошибок. Написанный в предыдущем примере сокращенный код можно
сделать ещё меньше с помощью сокращения промежуточных переменных и конвейерного вызова
методов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p>Мы перенесли создание экземпляра структуры <code>String</code> в начало функции. Вместо того,
чтобы создавать переменную <code>f</code> мы последовательно вызываем методы экземпляров
выходные данных.</p>
<a class="header" href="print.html#aОграничения-использования-" id="aОграничения-использования-"><h3>Ограничения использования <code>?</code></h3></a>
<p>Сокращенную запись с помощью символа <code>?</code> можно использовать в функциях, которые
возвращают значение перечисления <code>Result</code>. Соответственно, если функция не возвращает
значение перечисления <code>Result</code>, а в коде написано обратное - компилятор сгенерирует
ошибку. Пример:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!-- NOTE: as of 2016-12-21, the error message when calling `?` in a function
that doesn't return a result is STILL confusing. Since we want to only explain
`?` now, I've changed the example, but if you try running this code you WON'T
get the error message below.
I'm bugging people to try and get
https://github.com/rust-lang/rust/issues/35946 fixed soon, hopefully before this
chapter gets through copy editing-- at that point I'll make sure to update this
error message. /Carol -->
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
3 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found enum
`std::result::Result`
  |
  = note: expected type `()`
  = note:    found type `std::result::Result&lt;_, _&gt;`
</code></pre>
<p>В описании ошибки сообщается, что функция <code>main</code> должна возвращать кортеж, а вместо
этого - функция возвращает <code>Result</code>.</p>
<p>В следующем разделе будет рассказано об особенностях вызова макроса <code>panic!</code>, приведены
рекомендации при выборе конструкции для отслеживания ошибок.</p>
<a class="header" href="print.html#aТу-пи-о-нот-ту-пи-Паниковать-или-нет-вот-в-чём-вопрос--" id="aТу-пи-о-нот-ту-пи-Паниковать-или-нет-вот-в-чём-вопрос--"><h2>Ту пи о нот ту пи. Паниковать или нет, вот в чём вопрос. :-)</h2></a>
<p>Как понять использовать макрос <code>panic!</code> или нет и когда лучше всего возвращать
значение <code>Result</code>? Если код уже находится в режиме паник - нет возможности восстановления.
Заранее Вы только можете выбрать использование <code>panic!</code> для разных ситуаций.
Например, вы решили, что можете решить, что в определенных случаях восстановление
ненужно. Когда вы возвращаете
некоторых из них возможно реализовать восстановление состояния работы программы,
в некоторых нет. Когда вы возвращаете значение перечисления <code>Result</code> пользователю
вашего кода, то вы предлагаете ему опцию, а не решаете за него. Пользователи решают</p>
<ul>
<li>попытаться восстановить текущую работу программы или самим вызвать макрос <code>panic!</code>,
создав невосстанавливаемую ситуацию. Возвращение значение перечисления <code>Result</code> -
это поведение по умолчанию.</li>
</ul>
<a class="header" href="print.html#aПримеры-шаблоны-кода-и-тесты-все-что-нужны-для-паники" id="aПримеры-шаблоны-кода-и-тесты-все-что-нужны-для-паники"><h3>Примеры, шаблоны кода и тесты: все что нужны для паники</h3></a>
<p>Очень мало бывает таких ситуаций, когда будет необходимо изменить это поведение.
Далее, мы разберем работы с макросом <code>panic!</code>. Мы напишем и разберем код, протестируем
его. Далее мы смоделируем ситуации, приводящие к срабатыванию <code>panic!</code> в коде стандартной
библиотеки.
Выбор вспомогательного метода обработки ошибок зависит от целей и задач, которые вы
ставите. Методы <code>unwrap</code> и <code>expect</code> весьма удобны при начальном написании, кода.</p>
<a class="header" href="print.html#aСлучаи-когда-вы-можете-получить-больше-информации-для-анализа-чем-компилятор" id="aСлучаи-когда-вы-можете-получить-больше-информации-для-анализа-чем-компилятор"><h3>Случаи, когда вы можете получить больше информации для анализа, чем компилятор</h3></a>
<p>Бывают ситуации, когда наилучшим решением было бы вызов метода <code>unwrap</code>, в тех случаях,
когда часть кода вашей программы ожидает значение <code>Ok</code>. К сожалению, не всегда
компилятор может корректно понять логику вашей программы. Если в соответствующем месте
кода вашей программы вам необходимо получить результат работы в виде значения <code>Result</code>,
то в этом случае, использование метода <code>unwrap</code> - наилучший выбор.
Пример:</p>
<pre><pre class="playpen"><code class="language-rust">use std::net::IpAddr;

fn main() {

    let home = &quot;127.0.0.1&quot;.parse::&lt;IpAddr&gt;().unwrap();
    println!(&quot;{}&quot;, home);
}

</code></pre></pre>
<p>В данном примере, мы создаём экземпляр перечисления <code>IpAddr</code> и защищаем код от
возможных негативных последствий результата работы анализатора с помощью метода
<code>unwrap</code>.</p>
<a class="header" href="print.html#aРуководство-про-обработке-ошибок" id="aРуководство-про-обработке-ошибок"><h3>Руководство про обработке ошибок</h3></a>
<p>Рекомендуем использовать макрос `panic!, когда существует вероятность того, что
программа может войти в ошибочное состояние. Ошибочное состояние - это не выполняются
предположения, соглашения, когда могут быть недоступны или утеряны какие-либо данные.
Ошибочное состояние - это непредвиденная основной логикой программы проведение.
Основные тезисы ошибочного состояния:</p>
<ul>
<li>это состояние не является целью работы программы,</li>
<li>необходимо иметь возможность выйти из этого состояния после подобного происшествия,</li>
<li>нет идеального способа получения информации о причинах и последствиях
этого состояния в полном объеме.</li>
</ul>
<p>Если пользователи вашего кода введут неправильные входные данные, то лучшим способом
реакции на них может быть макрос <code>panic!</code> и информирование о этом. Также макрос <code>panic!</code>
удобен при работе со сторонними библиотеками, логику работы кода, которых вы не
можете контролировать.</p>
<p>Если программа вошла в ошибочное состояние, но это состояние было спрогнозировано,
наилучшим решением - вернуть значение перечисления <code>Result</code> с информацией о проблеме.</p>
<p>Когда код программы сначала проверяет корректность данных можно вызвать макрос <code>panic!</code>,
лучше всего проинформировать о том, что входные данные неверны.
Примерами такого поведения могут быть ошибки разбора текстовый информации, или
сообщения об ошибочных состояниях HTTP запроса.</p>
<p>В стандартной библиотеке наиболее частый вариант обработки ошибок - использования
<code>panic!</code>. Это делается для безопасности. После получения данный информации, программист
решает что делать и как лучше в данном конкретном случае обработать ошибку.
В документации сообщается, если такое поведение возможно.</p>
<p>Множественные проверки на ошибки, конечно же делают ваш код более понятным в работе,
но в тоже время достаточно неудобны для чтения. Для решения этого вопроса, в
библиотеке Rust существует система типов (тех, которые могут быть обработаны компилятором).
Эти типы помогают сделать Ваш код компактным и удобным для чтения. Если ваша функция
имеет определённый параметр, вы даёте компилятору больше информации для анализа и
принятия решений. Чем большое будет ограничений на тип данных, тем безопаснее будет
ваш код.</p>
<a class="header" href="print.html#aСоздание-типа-данных-для-проверки" id="aСоздание-типа-данных-для-проверки"><h3>Создание типа данных для проверки</h3></a>
<p>Давайте рассмотрим идею использования типов для проверки корректности данных.
Для этого будем использовать пример нашей программы &quot;Игры в угадай число&quot; (Глава 2).
В программе мы не анализировали входные данные. В ней мы просто проверяли данные на
совпадение. Было бы удобно и интересно, если бы программа реагировала на введенные
неправильные данные более точно.</p>
<p>Один из способов решения - анализ строки. Рассмотрим пример:</p>
<pre><code class="language-rust ignore">loop {
    // snip

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // snip
}
</code></pre>
<p>Выражение <code>if</code> проверяет корректность значения - не выходит ли оно за заданный диапазон.
Если значение в <code>if</code> - положительно - вызывается <code>continue</code> и итерация повторяется.
После успешного прохождения дополнительных проверок - происходит сравнение значения
с секретным числом.</p>
<p>Хотя, конечно, подобные проверки - не идеальное решение, это может быть важно, когда
в программе необходимо быть уверенным, что далее будет производиться работа с числом,
входящим в определенный диапазон.</p>
<p>Наилучшим решением может быть новый тип данных, который при создании нового экземпляра
производит необходимые проверки. Т.е. сокращается количество однотипных действий,
что может привести к повышению производительности и читаемости кода.</p>
<p>Создадим структуру <code>Guess</code>, которая решает поставленную задачу:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; u32 {
        self.value
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 9-8: Тип <code>Guess</code>, который создаёт свой экземпляр, только
на основе данных, соответствующие заданным условиям</span></p>
<p>Мы определили структуру с именем <code>Guess</code>, которая имеет поле <code>value</code> типа <code>u32</code>.</p>
<p>Далее, мы реализуем функцию <code>new</code>, которая создаёт новый экземпляр <code>Guess</code>.
У функции <code>new</code> имеется один входной параметр <code>value</code> типа <code>u32</code>.
Код функции <code>new</code> тестирует входной параметр, чтобы убедиться, что его значение
находится между 1 и 100. Если значение выходит за эти приделы, будет вызван
макрос <code>panic!</code>. Условия при котором будет вызван этот макрос будут описаны в генерируемой
документации к функции <code>Guess::new</code>. Мы поговорим подробнее о документации в Главе 14.
Если результаты проверки значения <code>value</code> будут положительными - будет создан экземпляр
структуры <code>Guess</code>.</p>
<p>Далее, мы реализуем метод <code>value</code>, который использует ссылку <code>self</code> и не имеет
других параметров. Этот метод возвращает значение поля <code>value</code> типа данных <code>u32</code>.
Это синтаксическая структура похожа на реализацию свойства для чтения. Этот метод
необходим для доступа к значению поля <code>value</code>, т.к. это доступ к этом полю закрыт
соответствующим спецификатором. Пользователи данной структуры обязаны использовать
метод <code>Guess::new</code> для создания экземпляра.</p>
<p>Использование экземпляра структуры <code>Guess</code> заметно повышает читабельность кода,
устраняет повторяемость ненужных проверок. Как следствие всё это должно привести к
повышению производительности программ.</p>
<p>Полный код улучшенного примера программы &quot;Угадай число&quot;:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; u32 {
        self.value
    }
}

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);


        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        let guess_item: Guess = Guess::new(guess as u32);
        let guess: u32 = guess_item.value();

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}

</code></pre></pre>
<a class="header" href="print.html#aИтоги-5" id="aИтоги-5"><h2>Итоги</h2></a>
<p>Опции отслеживания и генерации сообщений об ошибках в Rust реализованы таким образом,
чтобы помочь создавать удобный для чтения и использования код. Макрос <code>panic!</code>
сигнализирует о том, что программа находится в аварийной ситуации и предоставляет
возможности как для остановки работы программы, так и для восстановления её работы.
Результатом работы макроса <code>panic!</code> является значение перечисления <code>Result</code>.
Вы можете использовать содержание данного значения для анализа случившийся проблемы.</p>
<p>Далее, мы познакомится с удобными практиками стандартной библиотеки использования
перечислений <code>Option</code> и <code>Result</code> в шаблонах и рассмотрим возможности работы с шаблонами.</p>
<a class="header" href="print.html#aШаблонные-типы-данных-типажи-и-время-жизни" id="aШаблонные-типы-данных-типажи-и-время-жизни"><h1>Шаблонные типы данных, типажи и время жизни</h1></a>
<p>Наверное, каждый прагматичный язык программирования имеет в своём арсенале эффективное средство.
борьбы с дублированием кода. В Rust одним из таким средств является концепция
шаблонных типов данных - <em>generics</em>. Это абстрактные типы для конкретных типов или
свойств. Когда мы пишем и компилируем код мы можем подставить конкретный тип данных.
Мы можем решать задачи с различными типами данных без учёта их специфики.</p>
<p>Эта концепция напоминает работу функции, тип входных параметров которой заранее
не известен. Мы также можем создавать функции, которые получают шаблонный тип данных
в качестве параментра. Мы уже использовали такие типы данных в Главе 6 <code>Option&lt;T&gt;</code>,
в Главе 8 <code>Vec&lt;T&gt;</code> и <code>HashMap&lt;K, V&gt;</code>, в Главе 9 <code>Result&lt;T, E&gt;</code>. В этой главе мы
рассмотрим, как определить наши собственные типы данных, функции и методы используя
возможности шаблонных типов данных.</p>
<p>Прежде всего, мы рассмотрим механизм получения функции, которая уменьшает дублирование
кода. Далее, мы будем использовать тот же механизм для получения функции с шаблонным
типом данных.  Мы также можем использовать шаблонные типы данных при определении
структур и перечислений.</p>
<p>После этого, мы поговорим о <em>типажах</em>. Типажи - это способ определения поведения
в стиле шаблонных типов данных. Типажи могут быть комбинацией шаблонных типов данных
для уменьшения возможных типов данных, которые имеют определённое поведение.</p>
<p>В конец главы, мы поговорим о <em>времени жизни</em>. Это функционал похож на шаблонные
типы данных, которое даёт нам информацию из компилятора о связях между ссылками в
памяти. Время жизни - это опция в Rust,  которая позволяет заимствовать в различных
ситуациях и в тоже время помогает компилятору проверять ссылочную целостность.</p>
<a class="header" href="print.html#aУдаление-дублирование-кода-с-помощью-выделение-функции" id="aУдаление-дублирование-кода-с-помощью-выделение-функции"><h2>Удаление дублирование кода с помощью выделение функции</h2></a>
<p>Прежде чем перейти к рассмотрению синтаксиса шаблонных типов данных, предлагаю
рассмотреть технику устранения дублирования кода. Поняв механизм устранения дублирования
применим его для создания шаблонных типов данных.</p>
<p>Рассмотрим небольшую программу, которая ищет наибольшее число в списке (Текст кода 10-1):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
#  assert_eq!(largest, 100);
}
</code></pre></pre>
<p><span class="caption">Текст кода 10-1: Программа поиска наибольшего числа в списке</span></p>
<p>В программе вектор целых чисел сохраняется в переменной <code>number_list</code>. Первое значение
из списка получает переменная <code>largest</code>. Далее, итератор перебирает элементы вектора.
Если текущий элемент больше наибольшего, его значение присваивается наибольшему.
После перебора всех элементов, переменная <code>largest</code> хранит наибольшее числовое значение.</p>
<p>Если необходимо искать наибольшее число в друх различных списках, мы должны будем
дублировать код и использовать такую же логику в двух различных местах программы.
Текст кода 10-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Текст кода 10-2: Программа поиска наибольшего числа в <em>двух</em>
списках</span></p>
<p>Несмотря на то, что код программы работает - этот код может содержать ошибки.
В этом код можно улучшить (прежде всего логику его работы).</p>
<!-- Мы надеемся, что наши читатель знаком с некоторыми понятиями объектно-ориентированного
программирования. Прежде всего с понятием "абстракция".
 -->
<p>Для устранения дублирования нам надо создать абстрактный код. В данном случае, это
это будет абстрактная функция, которая принимает любые списки целочисленных данных.
Создание и использование такой функции увеличит ясность и уменьшит количество кода.
В программе  10-3, мы выбрали код, который ищет наибольшее значение в нескольких
списках:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 6000);
}
</code></pre></pre>
<p><span class="caption">Текст программа 10-3: Функция поиска наибольшего элемента
в списках числовых значений</span></p>
<p>Функция принимает параметр <code>list</code>, который представляет собой любой отрезок
числовых данных. Когда функция вызывается, функция работает с входными данными.</p>
<p>Порядок устранения дублирования кода:</p>
<ol>
<li>Находим дублированный код.</li>
<li>Выбираем дублирующий код из тела функции. Создаем отдельную функцию с этим кодом.</li>
<li>Заменяем код на вызов функции.</li>
</ol>
<p>Этот же алгоритм можно применить для создания шаблонных решений. Также код функции
будет обрабатывать какой-то абстрактный список данных. У шаблонных решений есть свои
синтаксические отличия, о которых мы поговорим далее.</p>
<p>Что будет если у нас будет две функции, одна ищет наибольшее значение в отрезке
с типами данных <code>i32</code>, а вторая с <code>char</code>? Как в этом случае избежать дублирования.
Об этом поговорим на следующей главе.</p>
<a class="header" href="print.html#aШаблонные-типы-данных-родовые-типы-дженерики-generic-data-types" id="aШаблонные-типы-данных-родовые-типы-дженерики-generic-data-types"><h2>Шаблонные типы данных (родовые типы, дженерики) (Generic Data Types)</h2></a>
<p>Использование шаблонных типов данных в описании входных параметров функций, полях
и методах структур позволяет нам создавать структуры, языковые конструкции, которые
можно использовать с различными типами данных. Далее, будут рассмотрены определения
функций, структур, перечислений, методов, с помощью использования шаблонных типов
данных. Также мы рассмотрим производительность кода, который использует этот подход.</p>
<a class="header" href="print.html#aИспользование-шаблонных-типов-данных-в-определении-функций" id="aИспользование-шаблонных-типов-данных-в-определении-функций"><h3>Использование шаблонных типов данных в определении функций</h3></a>
<p>Мы можем создавать определения функций с помощью шаблонов. При этом код становится
более удобным и универсальным.</p>
<p>Продолжим исследование функции, которую мы создали в предыдущем разделе - <code>largest</code>.
Создадим коды искомых функций для срезов. Первая функция будет искать наибольшее значение в
данных в типа <code>i32</code>. Вторая функция будет искать наибольшее значение в типах данных
<code>char</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
#    assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
#    assert_eq!(result, 'y');
}
</code></pre></pre>
<p><span class="caption">Listing 10-4: Две функции, отличия которых (кроме названий) только
в типе обрабатываемых данных</span></p>
<p>Функции <code>largest_i32</code> и <code>largest_char</code> имеют абсолютно одинаковое содержание. Было бы,
конечно, замечательно если бы была возможность объединить содержание в одну функцию.
Это возможно с дженериков.</p>
<p>Для параметризирования параметров функции, необходимо дать имя типу параметра. Также,
как мы даём имя параметру функции. Назовём этот тип <code>T</code>. В качестве этого имени могут
быть любой идентификатор, но учитывая конвенции языка программирования Rust - имя будет
таковым. <code>T</code> - это сокращения от &quot;тип&quot;. Для упрощения это имя в языке Rust выбирается
по умолчанию.</p>
<p>Для того, чтобы использовать данный параметр, мы должны определить его специальным образом.
Переменная типа записывается в квадратных скобках между именем функции и списком параметров.</p>
<p>В результате описание функции <code>largest</code> будет иметь следующий вид:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
...
</code></pre>
<p>Читает это определение следующим образом: обобщенная функция <code>largest</code> имеет тип параметров
<code>T</code>. Эта финкция имеет один параметр <code>list</code>. Тип данных данного параметра <code>T</code>. Функция
возвращает значение типа данных <code>T</code>.</p>
<p>В следующим тексте программы (10-5) будет продемонстрирован полный текст данной
функции, а также её использование. Обратите внимание, что данный код ещё имеет недостатки!
Пожалуйста, попробуйте скомпилировать код данного примера и ознакомьтесь с сообщениями
компилятора!</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-5: Объявление функции <code>largest</code>, которая использует
концепцию обобщенного программирования (дженерики) для параметризации используемых типов
данных</span></p>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; largest {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>Мы подробнее поговорим о <em>типажах</em> (таких как <code>std::cmp::PartialOrd</code>) в последующих
главах книги. Эта ошибка сообщает нам о том, что содержание функции не будет работать
для всех типов данных, т.к. внутри функции используется оператор сравнения <code>&gt;</code>, а для
его использования типы параметризированных переменных должны реализовать типаж <code>std::cmp::PartialOrd</code>.</p>
<a class="header" href="print.html#aИспользование-обобщенных-типов-данных-при-определении-структур" id="aИспользование-обобщенных-типов-данных-при-определении-структур"><h3>Использование обобщенных типов данных при определении структур</h3></a>
<p>Мы можем определять структуры для использования внутри. Для этого также, как и в функции
между названием структуры и списком параметров пишем в квадратных скобах имена используемых
типов данных. Код программы (10-6) наглядно демонстрирует это. Структура <code>Point</code>
содержит параметризированные поля <code>x</code> и <code>y</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{:?}&quot;, integer);
    println!(&quot;{:?}&quot;, float);
}

</code></pre></pre>
<p><span class="caption">Listing 10-6: Использование структуры <code>Point</code> содержащей поля
<code>x</code> и <code>y</code> типа <code>T</code></span></p>
<p>Обратите внимание, на схожие черты синтаксиса при определении обобщенной функции и структуры.
Мы называем тип параметра, располагаем его в определённом синтаксисом языка месте.
Вызов и использование синтаксических структуру аналогичны.</p>
<p>Также обратите внимание, что типы данных полей структуры имеют один и тот же тип дынных.
Если структура будет инициирована различными числовыми типами данных - код не скомпилируется:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
/*
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{:?}&quot;, integer);
    println!(&quot;{:?}&quot;, float);

    */

    let wont_work = Point { x: 5, y: 4.0 };
    println!(&quot;{:?}&quot;, wont_work);
}
</code></pre>
<p><span class="caption">Listing 10-7:Пример ошибки. Поля <code>x</code> и <code>y</code> должны быть инициированы
одинаковыми типами данных <code>T</code></span></p>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
  floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`
</code></pre>
<p>Когда мы присваиваем значение первой переменной (в данном случае <code>x</code>), компилятор определяет
тип данных обобщенного типа. Следовательно, все последующие входные параметры должны иметь
тотже тип данных. Поэтому введение иного типа данных приводит к ошибке.</p>
<p>Если же необходимо использовать различные типы данных для входящих значений и переменных,
для этого надо описать все типы при определении и корректно их использовать.</p>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };

    println!(&quot;{:?}&quot;, both_integer);
    println!(&quot;{:?}&quot;, both_float);
    println!(&quot;{:?}&quot;, integer_and_float);
}

</code></pre></pre>
<p><span class="caption">Listing 10-8: Структура <code>Point</code> имеет два поля разного типа</span></p>
<p>Теперь все эти экземпляры структуры <code>Point</code> можно использовать, код компилируется.
Нет ограничений на количество используемых параметров типов данных. Но большое их количество
может негативно повлиять на читабельность кода. Если всё же такая необходимость появляется,
то это обстоятельство может служить сигналом для реструктуризации имеющегося кода программы.</p>
<a class="header" href="print.html#aИспользование-обобщенного-программирования-в-перечислениях" id="aИспользование-обобщенного-программирования-в-перечислениях"><h3>Использование обобщенного программирования в перечислениях</h3></a>
<p>Также как и в структурах, перечисления могут иметь обобщенные типа данные. Мы уже использовали
такой тип данных в наших предыдущих примерах - <code>Option&lt;T&gt;</code> (в Главе 6). Рассмотрим определение
данного перечисления подробнее:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>Это определение перечисления с обобщенным типом данных <code>T</code>. Перечисление имеет два
значения: <code>Some</code>, которое содержит значение типа <code>T</code> и <code>None</code>, которое не содержит каких-либо
данных. Стандартная библиотека предоставляет такой функционал - опциональное значение,
идея которого более абстрактная. Она позволяет обойтись без дублирования.</p>
<p>Как и структура и функция, перечисления также могут использовать список обобщенных параметров.
Примером этого - определение перечисления <code>Result</code> из Главы 9:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>Перечисление <code>Result</code> имеет два обобщенных типа <code>T</code> и <code>E</code>. <code>Result</code> имеет два значения:
<code>Ok</code>, которое содержит тип <code>T</code> и <code>Err</code>, которое содержит тип <code>E</code>. Такое определение
позволяет использовать перечисление <code>Result</code> везде, где операции могут быть выполнены
успешно (возвращение значение типа данных <code>T</code>) или неуспешно (возвращение значения типа данных
<code>E</code>). Обратимся к коду программы 9-2, где мы открывали файл. При открытии файла предоставлялись
данные типа <code>T</code>, т.е. в том примере <code>std::fs::File</code> или, при ошибке, <code>E</code> (<code>std::io::Error</code> -
т.е. при каких-либо проблемах с открытием файла).</p>
<p>Мы надеемся, что Вам стало понятно, как избежать дублирование кода, используя возможности
обобщенного программирования при работы с функциями, структурам и перечислениями.</p>
<a class="header" href="print.html#aИспользование-обобщенных-типов-данных-в-определении-методов" id="aИспользование-обобщенных-типов-данных-в-определении-методов"><h3>Использование обобщенных типов данных в определении методов</h3></a>
<p>Также как и в Главе 5, мы может реализовать методы структур и перечислений с помощью
обобщенного программирования. Код программы 10-9 демонстрирует пример добавления метода
<code>x</code> в структуру <code>Point&lt;T&gt;</code>. Метод возвращает ссылку на значение данных поля <code>x</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: p1.x, y: p1.y };

    println!(&quot;p1.x() = {}&quot;, p1.x());
    println!(&quot;p2.x = {}&quot;, p2.x());
}

</code></pre></pre>
<p><span class="caption">Код программы 10-9: Реализация метода <code>x</code> в структуре <code>Point&lt;T&gt;</code>.
Метод <code>x()</code> возвращает ссылку на данные поля <code>x</code> (имеет тип <code>T</code>).</span></p>
<p>Конечно же, Вы обратили внимание на особенную структуры при описании обобщенного типа данных.
После <code>impl</code> находится имя обобщенного типа <code>impl&lt;T&gt;</code>. Таким образом в синтаксисе языка
компилятору передаётся информация о типах данных внутри структуры.
Например, мы можем выбрать реализацию методов <code>Point&lt;f32&gt;</code>.
Пример::</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 10-10: Реализация <code>impl</code> блока структуры <code>Point</code>.
При данной реализации метод структуры Point можно использовать только с определенным
типом данных. В данном случае это <code>f32</code>.</span></p>
<p>Пожалуйста, попробуйте откомпилировать код примера программы и познакомьтесь с описанием
ошибки:</p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
fn main() {
    let p2 = Point { x: 3., y: 1. };
    println!(&quot;p2.x() = {}&quot;, p2.x());
    println!(&quot;distance from origin =  {}&quot;, p2.distance_from_origin());

    ///////////////////

    let p1 = Point { x: 5, y: 10 };

    println!(&quot;p1.x() = {}&quot;, p1.x());

    println!(&quot;distance from origin =  {}&quot;, p1.distance_from_origin());
}

</code></pre></pre>
<p>Описание ошибки помогает понять, что экземпляры типа <code>Point&lt;f32&gt;</code> имеют метод <code>distance_from_origin</code>,
а экземпляры типа <code>Point&lt;T&gt;</code>, где <code>T</code> не является типом данных <code>f32</code> такого метода не
имеют.</p>
<p>Обобщенные типы параметров в определении структур не всегда такие же, которые вы бы хотели
использовать в методах. Код программы 10-11 описывает метод <code>mixup</code> структуры <code>Point&lt;T, U&gt;</code>.
Метод получает другую структуру <code>Point</code> в качестве параметра, которая может содержать
другие типы данных в качестве обобщенных типов данных. Метод создаёт новый экземпляр
структуры <code>Point</code>, который получает значение <code>x</code> из <code>self</code> <code>Point</code> (типа <code>T</code>) и <code>y</code> из
<code>Point</code> (типа <code>W</code>):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Код программы 10-11: Методы могут иметь различные обобщенные типы,
нежели те, которые есть в определении структур</span></p>
<p>В методе <code>main</code> мы создали экземпляр <code>Point</code>, который имеет тип данных <code>i32</code> для <code>x</code> и
<code>f64</code> для <code>y</code>. Далее мы создали экземпляр <code>Point</code>, который имеет тип данных срез строкового
типа для <code>x</code> и <code>char</code> для <code>y</code>. Вызов метода <code>mixup</code> из переменной <code>p1</code> с аргументом <code>p2</code>
создаёт новый экземпляр типа <code>Point</code>, копирую данные из уже имеющихся экземпляров.</p>
<p>Обратите внимание, что параметры типов <code>T</code> и <code>U</code> объявляется в блоке реализации после
ключевого слова <code>impl</code>. Параметры <code>V</code> и <code>W</code> объявляются после имени метода, и, следовательно,
могут быть использованы только в этом методе.</p>
<a class="header" href="print.html#aПроизводительность-программ-использующие-обобщенное-программирование" id="aПроизводительность-программ-использующие-обобщенное-программирование"><h3>Производительность программ, использующие обобщенное программирование</h3></a>
<p>Наверное, это немного удивительно какие же накладные расходы могут быть у программ с
прадватирельной компиляцией, даже есль используюется обобщенное программирование.
Так и есть. Программ созданные на Rust не имеет такой проблемы, но только лишь тогда,
когда будут использованы конкретные типы данных, т.е. они будут определены в процессе
компиляции программы.
Технология <em>мономорфизации</em> кода позволяет это реализовать. Этот процесс конвертирует
обобщенный код в конкретный.</p>
<p>Рассмотрим пример компиляции кода. Создадим два экземпляра перечисления <code>Option</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let integer = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>При компиляции произойдет оптимизация (<em>мономорфизации</em>). Компилятор прочитает значения
внутри значений перечисления <code>Option</code> и создаст необходимы типы <code>Option&lt;i32&gt;</code> и <code>Option&lt;f64&gt;</code>.
Оптимизированная версия кода будет выглядеть следующим образом:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Подведём итоги.
Мы познакомились с обобщенным программированием в Rust. Благодаря внутренней оптимизации
обобщенного кода, нет накладных расходов при работе программ.</p>
<a class="header" href="print.html#aТипажи-определение-общего-поведения" id="aТипажи-определение-общего-поведения"><h2>Типажи: определение общего поведения</h2></a>
<p>Типажи позволяют использовать особые виды абстракций. Он позволяют типам данных
получать поведение. <em>Типаж</em> сообщает компилятору о функциональности определенного
типа, который может быть передан другому типу. Дополнительно к тому, что мы можем
использовать обобщенные типы данных, мы можем использовать <em>связывание с типажами</em>.</p>
<blockquote>
<p>Обратите внимание: <em>Типажи</em> похожи на интерфейсы (например, в языке Java), но
имеют отличия.</p>
</blockquote>
<a class="header" href="print.html#aОпределение-типажа" id="aОпределение-типажа"><h3>Определение типажа</h3></a>
<p>Поведение типа определяется теми методами, которые мы можем использовать.
Различные типы разделяют поведение, если мы можем вызвать одни и теже методы во всех
типах. Определение типажей - это способ группировки определений методов вместе для
того чтобы иметь множество поведений необходимых для достижения каких-либо целей.</p>
<p>Например, у нас есть несколько структур, которые имеют различные типы и количество
текста. Структура <code>NewsArticle</code> содержит новости, которые печатаются в различных
местах в мире. Структура <code>Tweet</code> имеет 140 символов для содержания ссылки и короткого
сообщения.</p>
<p>Мы хотим создать библиотеку для хранения и отображения коротких описаний данных,
которые могли бы быть сохранены в экземплярах структур <code>NewsArticle</code> или <code>Tweet</code>.
Необходимо, чтобы каждая структура имела возможность делать короткие заметки
на основе имеющихся данных. Это должно происходить при вызове метода экземпляра
<code>summary</code>. Пример (10-12) иллюстрирует определение типажа <code>Summarizable</code>, в котором
есть необходимый метод (действие, поведение):</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn summary(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p><span class="caption">Код 10-12: Определение типажа <code>Summarizable</code>, который содержит
поведение (метод <code>summary</code>)</span></p>
<p>Обратите внимание на синтаксис определения поведения. Синтаксис напоминает определение
структуры. Отличие вы, наверное, тоже заметили. Оно в описании метода. Только описание.
Реализации нет. Каждый тип данных, которые реализует это поведение должен иметь
свою реализацию. Компилятор будет проверять, что каждый тип реализующий данное поведение
делал это в точном соответствии с описанием.</p>
<p>Типаж может иметь несколько описаний методов. Каждое описание должно находиться на
одной строке и все они должны закачиваться символом &quot;;&quot;.</p>
<a class="header" href="print.html#aРеализация-типажа-в-типах" id="aРеализация-типажа-в-типах"><h3>Реализация типажа в типах</h3></a>
<p>После описания типажа <code>Summarizable</code> можно описать, реализовать типы имеющие соответствующее
поведение. Код (10-13) показывает реализацию типажа <code>Summarizable</code> в структуре
<code>NewsArticle</code>. Эта структура имеет поля для формирования описания.
Структура <code>Tweet</code> также имеет поля, для формирования содержания описания.</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
 pub trait Summarizable {
     fn summary(&amp;self) -&gt; String;
 }

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summarizable for NewsArticle {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summarizable for Tweet {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 10-13: Реализация типажа <code>Summarizable</code>
в структурах <code>NewsArticle</code> и <code>Tweet</code></span></p>
<p>Реализация типажа это тоже самое, что реализация методов, которые не связаны с
типажом. Различия в том что после ключевого слова <code>impl</code> мы сообщаем имя типажа,
который будем реализовывать. Далее идет ключевое слово <code>for</code> и затем типа. Внутри
блока мы пишем определение функции и её реализацию.</p>
<p>После того, как мы реализовали типаж, мы можем вызвать методы экземпляров
<code>NewsArticle</code> и <code>Tweet</code> тем же способом, что и вызов методов, которые не являются
частью типажа:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summary());
</code></pre>
<p>Чтобы проверить работу созданных программных решений в одной проекте, создадим
новый проект с названием aggregator:</p>
<pre><code>cargo new aggregator &amp;&amp; cd aggregator
</code></pre>
<p>Далее в файле <em>lib.rs</em> внесем код (10-13). Далее создадим файл <em>main.rs</em>.
Внесем в него следующий код:</p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Summarizable;
use aggregator::Tweet;


fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summary());
}

</code></pre>
<p>Далее, запускайте проект на выполнение:</p>
<pre><code>cargo run
</code></pre>
<p>В результате работы кода этой программы будет напечатано:
<code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Обратите внимание, что т.к. мы объявили типаж <code>Summarizable</code> и типы <code>NewsArticle</code>
и <code>Tweet</code> в файле <code>lib.rs</code>, все они в одной и той же области видимости.
Если кто-либо ещё захочет использовать функционал нашего контейнера и также реализовать
поведение <code>Summarizable</code>, то в этом случае необходимо импортировать типаж <code>Summarizable</code>
в область видимости (10-14):</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Summarizable;

struct WeatherForecast {
    high_temp: f64,
    low_temp: f64,
    chance_of_precipitation: f64,
}

impl Summarizable for WeatherForecast {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;The high will be {}, and the low will be {}. The chance of
        precipitation is {}%.&quot;, self.high_temp, self.low_temp,
        self.chance_of_precipitation)
    }
}
</code></pre>
<p><span class="caption">Listing 10-14: Добавление типажа <code>Summarizable</code> из контейнера
<code>aggregator</code> в область видимости другого крата</span></p>
<p>Для проверки работы этого кода программы создайте новый проект ch10_weather_forecast.
В файл lib.rs добавьте код (10-14). Далее, создайте файл main.rs в него внесите
следующий код:</p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Summarizable;

struct WeatherForecast {
    high_temp: f64,
    low_temp: f64,
    chance_of_precipitation: f64,
}

impl Summarizable for WeatherForecast {
    fn summary(&amp;self) -&gt; String {
        format!(&quot;The high will be {}, and the low will be {}. The chance of
        precipitation is {}%.&quot;, self.high_temp, self.low_temp,
        self.chance_of_precipitation)
    }
}
</code></pre>
<p>Обратите внимание, что данный код не будет скомпилирован, т.к. контейнер <code>aggregator</code>
не будет найден. В этом проявляется ограничение работы с типажами.</p>
<p>Пожалуйста, обратите внимание на реализации типажей. Нельзя реализовывать внешние типажи
во внешних типах данных. Например, нельзя реализовать типаж <code>Display</code> в структуре <code>Vec</code>,
т.к. их код находится в стандартной библиотеке. Разрешается реализовывать внешние
типажи во внутренних типах. Например, типаж <code>Display</code> можно реализовать в структуре
<code>Tweet</code> внутри крата <code>aggregator</code>. Также можно изменить структуру стандартной библиотеки
<code>Vec</code> реализовав в ней типаж <code>Summarizable</code> также  внутри контейнера <code>aggregator</code>.
Такое ограничение называется <em>orphan rule</em> и оно существует для предотвращения
дублирования и надёжности библиотек кода.</p>
<a class="header" href="print.html#aРеализации-по-умолчанию" id="aРеализации-по-умолчанию"><h3>Реализации по умолчанию</h3></a>
<p>Весьма удобно, когда существует поведение по умолчанию. Это может уменьшить
трудозатраты программиста, если это поведения ему подходи в его структурах.</p>
<p>Код (10-15) демонстрирует реализацию поведения в типаже. Это поведение можно будет
переписать в реализации:</p>
<p><span class="filename">Filename: lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn summary(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-15: Реализация в типаже <code>Summarizable</code> поведения
<code>summary</code></span></p>
<p>Если по каким-то причинам вы хотите реализовать поведение типажа без его перезаписывания,
то просто напишите следующий код (пустой блок):</p>
<pre><code class="language-rust ignore">
impl Summarizable for DefaultArticle {}
</code></pre>
<p>Использование структуры и унаследованного поведения от типажа <code>NewsArticle</code>:</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summary());
</code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Изменения сделанные в типаже <code>Summarizable</code> (реализация поведения) не отражается
каким-либо образом на структурах, которые ещё реализовали ранее.</p>
<p>Можно усложнить реализацию метода и в нём вызывать методы, которые не имеют
реализации:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summarizable {
    fn author_summary(&amp;self) -&gt; String;

    fn summary(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.author_summary())
    }
}
#}</code></pre></pre>
<p>Теперь для того чтобы использовать типаж <code>Summarizable</code> в каждой реализации необходимо
реализовать метод <code>author_summary</code>:</p>
<pre><code class="language-rust ignore">impl Summarizable for Tweet {
    fn author_summary(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>Т.е. после того как вы реализуете <code>author_summary</code> в структуре <code>Tweet</code> реализация
по умолчанию вызовет метод <code>author_summary</code>.
Если вы знакомы с объектно-ориентированным программированием в Java, уверен, тут
у Вас не будет возникать вопросов. Всё это напоминает интерфейсы и абстрактные классы
Java.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summary());
</code></pre>
<p>This will print <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Обратите также внимание, что нельзя вызвать метод по умолчанию из реализации.</p>
<a class="header" href="print.html#aСвязывание-с-типажом" id="aСвязывание-с-типажом"><h3>Связывание с типажом</h3></a>
<p>Теперь, когда мы создали типажи и реализовали их в типах, мы можем усложнить код и
добавить в них элементы обобщенного программирования. Мы может сократить количество
возможных обобщенных типов данных с помощью типажей. Этот приём называется
<em>связывание с типажом</em> в обобщенном типе данных.</p>
<p>Например, в примере кода (10-13) мы реализовали типаж <code>Summarizable</code> в структурах
<code>NewsArticle</code> и <code>Tweet</code>. Теперь мы можем объявить функцию <code>notify</code>, которая будет
вызывать метод <code>summary</code> из переменной. Мы объявим в коде, что тип переменной <code>item</code>
должен реализовывать типаж <code>Summarizable</code>:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summarizable&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summary());
}
</code></pre>
<p>Добавим этот метов внутрь блока <code>Summarizable</code>:</p>
<pre><code class="language-rust ignore">pub trait Summarizable {
//  fn summary(&amp;self) -&gt; String;
//  fn summary(&amp;self) -&gt; String {
//      String::from(&quot;(Read more...)&quot;)
//  }

  fn author_summary(&amp;self) -&gt; String;

    fn summary(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.author_summary())
    }

    fn notify&lt;T: Summarizable&gt;(item: T) {
        println!(&quot;Breaking news! {}&quot;, item.summary());
    }
}
</code></pre>
<p>Связывание с типажом - это ограничение накладываемое на обобщенный тип. Входящая
переменной может быть экземпляром любой структуры реализовавшей типаж <code>Summarizable</code>.
Внешний код программы, может вызвать метод <code>notify</code>, как, например <code>WeatherForecast</code>.
Все остальные типы данных, такие как <code>String</code> или <code>i32</code> не могут быть входными данными
этой функции, т.к. они не реализовали типаж <code>Summarizable</code>.</p>
<p>Для того, чтобы указать несколько типажей в список ограничений необходимо использовать
знак <code>+</code>, чтобы объединить их названия. Например, можно добавить <code>T: Summarizable + Display</code>, чтобы наложить ограничение на особенности форматирования и реализацию
методов <code>Summarizable</code>.</p>
<p>Для функций, которые имеют множество обобщенных типов параметров, каждый обобщенный
параметр может иметь своё собственное связывание.</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>Для упрощения этой записи существует альтернативный синтаксис (использование <code>where</code>):</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Такое описание более понятно.</p>
<a class="header" href="print.html#aИсправление-кода-функции-largest-с-помощью-связывание-с-типажом" id="aИсправление-кода-функции-largest-с-помощью-связывание-с-типажом"><h3>Исправление кода функции <code>largest</code> с помощью связывание с типажом</h3></a>
<p>Каждый раз, когда вы хотите использовать поведение определенное в типаже в
обобщенном методе, вам необходимо определить обобщенный тип в области типа.</p>
<p>Для того, чтобы использовать оператор сравнения вам нужно указать в ограничении
типаж стандартной библиотеки  <code>std::cmp::PartialOrd</code>:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Но это ещё не всё (попытавшись скомпилировать этот код, вы получите ошибку):</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut largest = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref largest` or `ref mut largest`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>Т.к. вы сделали функцию <code>largest</code>, то есть потенциальная возможность использовать
типы данных, которые не реализовали типаж <code>Copy</code> (только реализации типажа <code>Copy</code>)
имеют известный размер, а следовательно могут быть измерены, сравнены. Добавим
это ограничение в список:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::cmp::PartialOrd;

fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Код 10-16: Реализация <code>largest</code> с помощью наложения ограничений
на типы входных параметров</span></p>
<p>Если вы не хотите накладывать ограничение типажа <code>Copy</code> вы можете указать вместо
него типаж <code>Clone</code>. При этом будет использована куча для хранения данных.
Если же вы не хотите наложения ограничений - просто используйте ссылку <code>&amp;T</code>, как
результат работы функции.</p>
<a class="header" href="print.html#aИспользование-связывание-типажа-при-выполнении-определенных-условий" id="aИспользование-связывание-типажа-при-выполнении-определенных-условий"><h3>Использование связывание типажа при выполнении определенных условий</h3></a>
<p>Пойдём дальше и сделаем наш код ещё интереснее. Мы можем связывать с типажом при
наступлении определенных условий.</p>
<p>Например, тип <code>Pair&lt;T&gt;</code> из примера кода (10-17), всегда реализует метод <code>new</code>, но
в тоже время, реализует метод <code>cmp_display</code> только лишь если внутренний тип <code>T</code>
реализует типаж <code>PartialOrd</code> и <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 10-17: Реализация метода только при соблюдении
типами параметров определенных условий</span></p>
<p>Мы также можем опционально реализовать типа для типа для любого типа который реализует
типаж. Эта особенность весьма часто используется в стандартной библиотеке.
Например, в стандартной библиотеке типаж <code>ToString</code> реализован, только если реализован
типаж <code>Display</code>. Синтаксис такого условия выглядит следующим образом:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // ...snip...
}
</code></pre>
<p>При таком условии мы можем вызвать метод <code>to_string</code> определенный в типаже <code>ToString</code>,
который реализовал типаж <code>Display</code>. Например, такой код будет корректным, т.к.
целочисленный тип реализовал типаж <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<p>В секции документации “Implementors” описываются подобные случаи использования типажей.</p>
<p>Все эти возможности, предоставляют инструмент для минимизации дублирования кода.
Rust предоставляет такие широкие возможности для того чтобы на этапе компиляции
можно было отследить возможные ошибки связывания типов.</p>
<p>Существует ещё одни тип обобщенного типов данных, которые можно использовать
даже без реализации. Это т.н. <em>lifetimes</em>. Вместо того, чтобы проверять наличие
реализаций в типах эти языковые конструкции помогают удостовериться в том, что
ссылки действительны. В следующей части этой главы вы узнаете об этом подробнее.</p>
<a class="header" href="print.html#aПроверка-ссылок-с-помощью-lifetimes" id="aПроверка-ссылок-с-помощью-lifetimes"><h2>Проверка ссылок с помощью Lifetimes</h2></a>
<p>Когда мы говорили о ссылках в Главе 4, мы опустили весьма важную деталь:
каждая ссылка в Rust имеет <em>время жизни</em>. Это область действия, в которой она является
действительной.</p>
<p>Lifetimes являются уникальной парадигмой языка Rust. Эта тема несколько обширна, что
в этой главе мы сможем изложить только синтаксис. В Главе 19 вы узнаете больше и
подробнее о возможностях этой парадигмы программирования на Rust.</p>
<a class="header" href="print.html#lifetimes-защищают-программу-от-недействительных-ссылок" id="lifetimes-защищают-программу-от-недействительных-ссылок"><h3>Lifetimes защищают программу от недействительных ссылок</h3></a>
<p>Самое важное свойство lifetimes - это предотвращение недействительных ссылок. Такую
ошибку весьма трудно заметить. Это весьма коварная ошибка. Для примера, давайте
рассмотрим код (10-18). Здесь демонстрируется поведение переменных в различных
областях видимости. Во внешней области видимости мы декларируем переменную <code>r</code> без
её инициализации. Во внутренней области видимости мы декларируем переменную <code>x</code> и
инициализируем её значением <code>5</code>. Внутри области видимости переменой <code>x</code> мы присваиваем,
точнее, пытаемся присвоить значение переменной <code>r</code>. Присваиваем её ссылочное значение
переменной <code>x</code>. Затем, мы хотим напечатать содержимое переменной <code>r</code> во внешней
области видимости:</p>
<pre><code class="language-rust ignore">fn main(){
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Listing 10-18: Попытка использования ссылки, которая стала
недействительной после выхода переменной из внутренней области видимости</span></p>
<blockquote>
<a class="header" href="print.html#aНеинициализированные-переменные-не-использоваться-в-выражениях-параметрах" id="aНеинициализированные-переменные-не-использоваться-в-выражениях-параметрах"><h4>Неинициализированные переменные не использоваться (в выражениях, параметрах</h4></a>
</blockquote>
<p>вызова функций или методов и пр.)</p>
<blockquote>
<p>Следующие примеры демонстрируют объявление переменных без их инициализации.
Имя переменной существует во внешней области видимости.</p>
</blockquote>
<p>Сообщение об ошибке:</p>
<pre><code class="language-text">error: `x` does not live long enough
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>Переменная <code>x</code> больше не существует, т.к. её области видимости закончилась сразу же
после выхода за пределы области её объявления. В тоже время переменная <code>r</code> продолжает
находится в зоне свого объявления. Как же в таком случае компилятор Rust понимает,
что содержание переменной уже недействительно?</p>
<a class="header" href="print.html#aПроверка-заимствования" id="aПроверка-заимствования"><h4>Проверка заимствования</h4></a>
<p>У в состав компилятора Rust входит функционал называющий ся <em>провека заимствования</em>.
Демонстрационный код (10-19) иллюстрирует всё тот же пример (10-18), графически
изображая область действия имеющихся переменных:</p>
<pre><code class="language-rust ignore">{
    let r;         // -------+-- 'a
                   //        |
    {              //        |
        let x = 5; // -+-----+-- 'b
        r = &amp;x;    //  |     |
    }              // -+     |
                   //        |
    println!(&quot;r: {}&quot;, r); // |
                   //        |
                   // -------+
}
</code></pre>
<p><span class="caption">Пример кода 10-19: Описание времени жизни переменных <code>r</code> и
<code>x</code>, с помощью идентификаторов <code>'a</code> и <code>'b</code></span></p>
<!-- Just checking I'm reading this right: the inside block is the b lifetime,
correct? I want to leave a note for production, make sure we can make that
clear -->
<!-- Yes, the inside block for the `'b` lifetime starts with the `let x = 5;`
line and ends with the first closing curly brace on the 7th line. Do you think
the text art comments work or should we make an SVG diagram that has nicer
looking arrows and labels? /Carol -->
<p>Мы описываем время жизни переменной <code>r</code> с помощью <code>'a</code> и время жизни переменной <code>x</code>
с помощью описательной переменной <code>'b</code>. Обратите внимание, что блок <code>'b</code> находится
внутри блока <code>'a</code> и значительно меньше. Во время компиляции, компилятор Rust сравнивает
два идентификатора времени жизни и получается так, что описание времени жизни переменной
<code>r</code> находится в идентификаторе времени жизни <code>'a</code>, но в тоже время хранит в себе
ссылку на объект с идентификатором времени жизни <code>'b</code>. Такая программа не компилируется,
т.к. время жизни <code>'b</code> короче, чем время жизни <code>'a</code>, время жизни переменой больше,
чем её содержание. Это неприемлемо.</p>
<p>Рассмотрим другой пример (10-20), в котором нет проблем с недействительными ссылками.
В нём просто закомментировали наличие вложенного блока кода. Данный код пройдет тест
на ссылочную целостность и будет  принят компиляторов, как действительный и готовый
к исполнению:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x = 5;            // -----+-- 'b
    //{                   //      |
    let r = &amp;x;           // --+--+-- 'a
    //}                   //   |  |
    println!(&quot;r: {}&quot;, r); //   |  |
                          // --+  |
}                         // -----+
#}</code></pre></pre>
<p><span class="caption">Блок кода 10-20: Все ссылки действительные, т.к. и данные и
ссылка имеют одинаковое время жизни</span></p>
<p>В данном примере переменная <code>x</code> имеет время жизни <code>'b</code>, что большое чем время жизни
<code>'a</code>. Это означает, что переменная <code>r</code> может ссылаться на переменную <code>x</code> и её значение
будет действительно при введении значения на консоль и до конца блока, в котором
переменная <code>x</code>  была объявлена.</p>
<p>В этом пример мы рассмотрели и проанализировали работу анализатора времени жизни
переменных. Далее, рассмотрим время жизни обобщенных переменных, а также возвращаемых
функциями значений.</p>
<a class="header" href="print.html#aИдентификаторы-времени-жизни-обобщенных-типов-данных-в-функциях" id="aИдентификаторы-времени-жизни-обобщенных-типов-данных-в-функциях"><h3>Идентификаторы времени жизни обобщенных типов данных в функциях</h3></a>
<p>Напишем функцию, которая возвращает наибольшую по длине строку. Эта функция
должна получать две переменные в качестве параметров функции и возвращать результат.
В строке вывода должно быть напечатано <code>The longest string is abcd</code>.
Пример кода (10-21):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Пример кода 10-21: Функция <code>main</code> вызывает функцию <code>longest</code>
для поиска наибольшей строки</span></p>
<p>Обратите внимание, что мы хотим иметь в качестве параметров срезы строк (которые
являются ссылками (об этом мы говорили в Главе 4)). Это делается для того, чтобы
не передавать владение в функцию передаваемых аргументов. Мы хотим, чтобы функция
принимала в качестве аргументов строковые срезы.</p>
<!-- why is `a` a slice and `b` a literal? You mean "a" from the string "abcd"? -->
<!-- I've changed the variable names to remove ambiguity between the variable
name `a` and the "a" from the string "abcd". `string1` is not a slice, it's a
`String`, but we're going to pass a slice that refers to that `String` to the
`longest` function (`string1.as_str()` creates a slice that references the
`String` stored in `string1`). We chose to have `string2` be a literal since
the reader might have code with both `String`s and string literals, and the way
most readers first get into problems with lifetimes is involving string slices,
so we wanted to demonstrate the flexibility of taking string slices as
arguments but the issues you might run into because string slices are
references.
All of the `String`/string slice/string literal concepts here are covered
thoroughly in Chapter 4, which is why we put two back references here (above
and below). If these topics are confusing you in this context, I'd be
interested to know if rereading Chapter 4 clears up that confusion.
/Carol -->
<p>Освежим в памяти материал Главы 4 (секцию &quot;Срезы строк в качестве аргументов&quot;)
для того, чтобы хорошо представлять особенности а тонкости рассматриваемого вопроса
в данном примере.</p>
<p>Если просто реализовать функции так, как это показано в примере кода (10-22), то
то программа не будет скомпилирована:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Код программы 10-22: Пример реализации функции <code>longest</code>,
которая возвращает наибольший срез строки, но пока ещё не компилируется (содержит
в себе ошибку)</span></p>
<p>В описании ошибки компилятор сообщает о проблемах в определении времени жизни:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
   |
1  | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
   |                                 ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the
   signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>Описание ошибки давольно-таки информативно, но всё-таки не очень понятно.
Ясно одно - анализатору времени жизни переменных не хватает данных для анализа
корректности ссылочной целостности. Необходимо видоизменить код функции так, чтобы
было устранить неопределенность и дать возможность компилятору провести все необходимые
проверки.</p>
<a class="header" href="print.html#aСинтаксис-описания-времени-жизни-переменных" id="aСинтаксис-описания-времени-жизни-переменных"><h3>Синтаксис описания времени жизни переменных</h3></a>
<p>Описания времени жизни не может изменить время жизни ссылок в программе.
Также как функции могут принимать любые входные данные удовлетворяющие условиям,
также функции потенциально могут принимать любые ссылки с любым временем жизни.
Описание времени жизни связывает между собой ссылки.</p>
<p>Описание времени жизни имеет необычный синтаксис: имена параметров времени жизни
обязаны начинаться с символа <code>'</code>. Имена их обычно пишутся в нижнем регистре и также,
как обобщенные типы данных, их имена очень короткие. Обычно, по умолчанию используется
<code>'a</code>. Параметры описания времени жизни следуют после символа <code>&amp;</code> ссылочного типа данных
и разделяются пробелом от названия тип данных.</p>
<p>Пример ссылки на переменную типа данных <code>i32</code>:</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
</code></pre>
<p>Пример ссылки на переменную типа данных <code>i32</code> с описанием времени жизни <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;'a i32     // a reference with an explicit lifetime
</code></pre>
<p>Пример изменяемой переменной типа данных <code>i32</code> с описанием времени жизни <code>'a</code>:</p>
<pre><code class="language-rust ignore">&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<p>Само по себе описание времени жизни не имеет значения: оно сообщает компилятору Rust,
как обобщенные параметры времени жизни изменяемой переменных связаны между собой.
Если у нас есть функция с параметром <code>first</code>, которая имеет ссылочный тип данных <code>i32</code> и
имеет описание времени жизни <code>'a</code> и эта функция имеет другой параметр с именем
<code>second</code>, который в свою очередь является ссылкой на переменную типа <code>i32</code> и имеет
описание времени жизни <code>'a</code>, то, следовательно у них одно и тоже описание времени
жизни. Следовательно эти ссылки существовать столько же, сколько существует обобщенное
описание времени жизни.</p>
<a class="header" href="print.html#aОписания-времени-жизни-в-синтаксисе-функций" id="aОписания-времени-жизни-в-синтаксисе-функций"><h3>Описания времени жизни в синтаксисе функций</h3></a>
<p>Теперь когда мы познакомились с аннотациями времени жизни переменных, применим
эти знания. В функцию <code>longest</code> внесём описания времени жизни переменных. Обратите
внимание, что аннотации в функциях располагаются в том же мести и квадратных скобках,
также как и обобщенные типы данных. Ограничение которое мы хотим внести в данную
функцию следующее: время жизни параметров и возвращаемого значения одно и тоже.
Пример (10-23):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 10-23: В функции <code>longest</code> определено время жизни
ссылочных переменных <code>'a</code>, благодаря чему компилятор может провести соответствующие проверки
корректности кода </span></p>
<p>Теперь код (10-21) использующий эту функцию может быть скомпилирован.</p>
<p>Компилятор теперь знает достаточно, о функции <code>longest</code>, чтобы убедиться в ссылочной
целостности.</p>
<p>Когда необходимо описание времени жизни функций, это описание может располагаться
только в заголовке функции. Это описание необходимо, как тонкая настройка целостности
данных.</p>
<p>Т.к. время жизни переменных может отличаться друг от друга при использовании данной
функции берется наименьшее значение. Только в этом случае мы можем гарантировать,
что возвращаемое значение будет иметь действительное время жизни.</p>
<p>Рассмотрим пример ограничений времени жизни работает на следующем примере (10-24):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
#
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p><span class="caption">Код программы 10-24: Использование функции <code>longest</code> и ссылок
на строковые данные <code>String</code>, которые имеют разное время жизни</span></p>
<p>Далее, рассмотрим пример, которые покажет, что время жизни результата работы
функции минимальное из имеющихся. Мы переместим определение переменной <code>result</code>
из внутренней области видимости, но присвоим значение внутри внутренней области
видимости. При таких условиях, пример кода 10-25 не будет скомпилирован:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-25: Попытка использование переменной <code>result</code>
после выхода переменной <code>string2</code> за пределы области видимости</span></p>
<p>Описание ошибки:</p>
<pre><code class="language-text">error: `string2` does not live long enough
   |
6  |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
7  |     }
   |     ^ `string2` dropped here while still borrowed
8  |     println!(&quot;The longest string is {}&quot;, result);
9  | }
   | - borrowed value needs to live until here
</code></pre>
<p>Эта ошибка возникает из-за минимального значения времени жизни одного из значений
входных данных функции.</p>
<p>Пожалуйста, поэкспериментируйте со значениями времени жизни ссылок! Посмотрите,
какая из ссылок используется для определения времени жизни результата.</p>
<a class="header" href="print.html#aДумай-категориями-времени-жизни" id="aДумай-категориями-времени-жизни"><h3>Думай категориями времени жизни</h3></a>
<p>Для того, чтобы точно определить время жизни параметров необходимо точно знать,
что будет делать функция. Например, если мы изменили реализацию функции <code>longest</code>
в новой редакции функция будет всегда возвращать первый аргумент, то в этом случае
нет необходимости устанавливать время жизни параметра <code>y</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>Для того, чтобы не было сообщений компилятора о неиспользуемом параметре, сделайте,
как рекомендуется:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, _y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>В этом примере мы сообщили параметр времени жизни <code>'a</code> для параметра <code>x</code> и возвращаемого
значения, но не для параметра <code>y</code>.</p>
<p>Если же в коде метода возвращаемая ссылка не будет ссылаться на какой-либо из аргументов,
тогда эта ссылка при выходе из области видимости станет недействительной, что приведёт
к ошибке компиляции и другим тревожным сообщениям:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Даже если будет установлен параметр время жизни у возвращаемого значения, этот код
также не будет скомпилирован, т.к. возвращаемое значение не будет связано с временем
жизни какого-либо из параметров.</p>
<p>Сообщение об ошибке:</p>
<pre><code class="language-text">error: `result` does not live long enough
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the block
at 1:44...
  |
1 | fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
  |                                             ^
</code></pre>
<p>Т.к. время жизни переменной истекает после выхода её из области видимости функции,
такой код не будет скомпилирован.</p>
<p>Как только будет установлена связь времени жизни входящих переменных и возвращаемого
значения - для компилятора будет достаточно информации, чтобы сделать проверки и
скомпилировать код, исключив возможность появления недействительных ссылок.</p>
<a class="header" href="print.html#aОпределение-времени-жизни-при-объявлении-структур" id="aОпределение-времени-жизни-при-объявлении-структур"><h3>Определение времени жизни при объявлении структур</h3></a>
<p>До сих пор мы объявляли структуры, которые содержали нессылочные типы данных.
Также возможно в структурах использовать ссылочные типы данных, но при этом необходимо
добавить описание времени жизни каждой ссылки в определение структуры. Пример кода
10-26 описывает структуру <code>ImportantExcerpt</code> содержащую срезы строковых данных:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };

    println!(&quot;{}&quot;,i.part);
}
</code></pre></pre>
<p><span class="caption">Пример кода 10-26: Структура, которая содержит ссылку и определение
времени жизни</span></p>
<p>Обратите внимание, что поле структуры <code>ImportantExcerpt</code> содержит ссылку</p>
<p>Синтаксис такой же, как и при работе с обобщенными типами данных.</p>
<p>Функция <code>main</code> создаёт экземпляр структуры <code>ImportantExcerpt</code>, который содержит
ссылку на перовое предложение из переменной <code>novel</code>.</p>
<a class="header" href="print.html#aПравила-неявного-определения-времени-жизни" id="aПравила-неявного-определения-времени-жизни"><h3>Правила неявного определения времени жизни</h3></a>
<p>Подведём промежуточные итоги изучения описания времени жизни. Из этой части главы
мы узнали, что каждая ссылка имеет время жизни и нам нужно устанавливать параметры
времени жизни для функций или структур, которые используют ссылки.</p>
<p>Также, изучая материал Главы 4, мы создали функции (в секции “String Slices”), которая
также использует ссылки, но при этом компилятор для её работы не требует информации
о времени жизни (Пример кода 10-27):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
#}</code></pre></pre>
<p><span class="caption">Код программы 10-27: Обратите внимание, что функция, которою
мы определили в Главе 4 компилируется без описания времени жизни ссылок, несмотря на
то, что и входной параметр и выходной - ссылки</span></p>
<p>Причина по которой это код может быть скомпилирован - историческая, первые версии
Rust предполагали явное указание подобной функциональности.
Сейчас мы рекомендуем написать данный код следующим образом, чтобы иметь возможность
использовать возможности компилятора по анализ возможных ошибок:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>После продолжительной работы и накопления большого опыта, разработчики языка Rust
обнаружили, что описания времени жизни программисты пишут в определённых шаблонных
решениях, практиках. Программисты Rust решили сделать так, что в таких случаях
сам компилятор может расставлять переменные времени жизни без явного объявления его
в коде программы.</p>
<p>Т.к. язык Rust постоянно развивается, возможно, в будущем роль переменных времени
жизни будут уменьшиться и больше будет случает в описаниях функций и перечислений.</p>
<p>Шаблоны, по которым компилятор Rust анализирует ссылки называется <em>правилами неявного
поредения времени жизни</em>. Эти правила существую для компилятора, а не для пишущего
программы на Rust программиста. Знание этих правил позволит не описывать время
жизни ссылок там, где это делать необязательно.</p>
<p>Неявные правила не имеет четких ограничений. Эти правила выводятся на основе имеющихся
данных в коде программы. Если этих данных не будет достаточно - компилятор выведет
соответствующие сообщения и не скомпилирует код.</p>
<p>Сейчас мы рассмотрим правила анализа переменных времени жизни.
Первое правило применяется к входным переменным. Последующие два правила применяются
к выходным переменным. Если компилятор применил эти правила и в результате этого
он не смог определить связывание данных переменных компилятор остановит свою работу и
сообщит об ошибке. Вот эти правила:</p>
<ol>
<li>
<p>Каждый параметр является ссылкой получающей свой собственный параметр времени жизни.
Другими словами, функция с одним параметром получает один параметр времени жизни:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>. Функция с двумя аргументами получает два различных
параметров времени жизни: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code> и так далее.</p>
</li>
<li>
<p>Если существует одни параметр времени жизни он связывается со всеми выходными
параметрами: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
</li>
<li>
<p>Если есть множество входных параметров времени жизни и один из них является
ссылкой <code>&amp;self</code> или <code>&amp;mut self</code> (т.к. это ссылка на метод структуры или перечисления
то в этом случае, параметр времени жизни <code>self</code> будет связан со всеми выходными
параметрами времени жизни.</p>
</li>
</ol>
<p>Вооружившись этими знаниями вернёмся к функции <code>first_word</code> и рассмотрим подробнее
анализ компилятора её заголовка. В нём нет описания времени жизни:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Далее, применим первое правило, которое говорит, что каждый параметр получает свой
собственный параметр времени жизни. Пропишем это условие явным образом:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>Второе правило таки применяется, т.к. здесь только один входной параметр времени
жизни. Следовательно, данная переменная времени жизни свяжется с выходной переменной
времени жизни. Перепишем заголовок функции с учётом этого правила:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Теперь все ссылки в этой функции имеют параметры времени жизни и компилятор может
продолжить свой анализ без необходимости получить дополнительную информацию от
программиста.</p>
<p>Давайте рассмотрим ещё один пример - заголовок функции <code>longest</code>, в котором нет
параметров времени жизни из примера 10-22:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Применим правила времени жизни:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Второе правило нельзя применить, т.к. входных параметров несколько. Смотрим
третье правило. Оно также не применимо, т.к. это функция, а не метод. Поэтому
компилятор в данном случае сообщит об ошибке (Пример кода 10-22)</p>
<p>Т.к. третье правило применяется только к методам, давайте рассмотрим работу этого
правила подробнее.</p>
<a class="header" href="print.html#aОписание-времени-жизни-в-определении-методов" id="aОписание-времени-жизни-в-определении-методов"><h3>Описание времени жизни в определении методов</h3></a>
<!-- Is this different to the reference lifetime annotations, or just a
finalized explanation? -->
<!-- This is about lifetimes on references in method signatures, which is where
the 3rd lifetime elision rule kicks in. It can also be confusing where lifetime
parameters need to be declared and used since the lifetime parameters could go
with the struct's fields or with references passed into or returned from
methods. /Carol -->
<p>Когда мы реализуем методы в структурах с описанием времени жизни, синтаксис
описаний схож с аннотациями обобщенного программирования (Пример кода 10-11).
Место где описания времени жизни определяется и используется зависит от того
с чем он связывается - с полем структуры либо с аргументами методов и возвращаемыми
значениями.</p>
<p>Имена переменных времени жизни для полей структур всегда должны описывается после
ключевого слова <code>impl</code> и затем помещаться после имени структуры, т.к. это имя -
неотъемлемая часть типа данных структуры.</p>
<p>В описании методов внутри блока <code>impl</code>, ссылки могут быть связаны с ссылками полей
или могут быть независимыми. Дополнительно, правила неявного использования
времени жизни делают использование переменных времени жизни необязательными.
Рассмотрим пример кода. Используем структуру <code>ImportantExcerpt</code> из примера 10-26.</p>
<p>Здесь метод в методе <code>level</code> входной параметр - ссылка на <code>self</code> и возвращаемое
значение типа <code>i32</code> (не ссылка):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
#}</code></pre></pre>
<p>Описание параметра времени жизни находится после <code>impl</code> и используется после имени.
Нам не надо добавлять информацию к входному параметру (правило 1).</p>
<p>Пример применения третьего правила:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct ImportantExcerpt&lt;'a&gt; {
#     part: &amp;'a str,
# }
#
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
#}</code></pre></pre>
<p>Тут два входных параметра. Применяем первое правило. Т.к. один из параметров <code>&amp;self</code>
возвращаемое значения будет иметь время жизни переменой <code>&amp;self</code></p>
<a class="header" href="print.html#aСтатическая-переменная-времени-жизни" id="aСтатическая-переменная-времени-жизни"><h3>Статическая переменная времени жизни</h3></a>
<p>Существует ещё одно особенное врем жизни - 'static`. Оно описывает всё врем жизни
программы. Все строковые литералы имеют этот тип времени жизни, которое мы можем
указать явным образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
#}</code></pre></pre>
<p>Содержание этой строки сохраняется внутри бинарного кода вашей программы и всегда
доступно для использования. Поэтому время жизни всех строковых литералов <code>'static</code>.</p>
<!-- How would you add a static lifetime (below)? -->
<!-- Just like you'd specify any lifetime, see above where it shows `&'static str`. /Carol -->
<p>В сообщениях компилятора могут быть сообщении использовать <code>'static</code>. Прежде чем
использовать данный тип переменной времени жизни, пожалуйста, подумайте, должна ли
данная переменна быть доступна во время работы программы. Очень часто такие ссылки
являются источником скрытых ошибок.</p>
<a class="header" href="print.html#aОбобщенные-типы-связывание-с-типажом-и-переменные-времени-жизни" id="aОбобщенные-типы-связывание-с-типажом-и-переменные-времени-жизни"><h3>Обобщенные типы, связывание с типажом и переменные времени жизни</h3></a>
<p>Теперь когда мы узнали о синтаксисе переменных времени жизни настала пора
объединить эти знания с другими концепциями языка Rust. Рассмотрим пример определения
обобщенных параметров, типажа и переменных времени жизни вместе:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>Это видоизмененный пример функции <code>longest</code> (код прогрммы 10-23). Программа
возвращает наибольшую строку. Обратите внимание на дополнительный аргумент обобщенного
типа <code>ann: T</code>! Он может быть любым, реализующим типаж <code>Display</code>. Содержание данной
переменной будет напечатано прежде, чем будет произведено сравнение строк. Т.к. переменные
времени жизни - это разновидность обобщенного типа параметров, они располагаются
вместе.</p>
<a class="header" href="print.html#aИтоги-6" id="aИтоги-6"><h2>Итоги</h2></a>
<p>В этой главе мы рассмотрели много важного материала для понимания работы переменных
времени жизни. Вы уже знаете достаточно, чтобы писать код программы и не дублировать
создаваемый вами код. Обобщенные параметры помогаю использовать код для различных
типов данных. Типажи и связывании с типажами помогает соблюсти конвенции и контракты
чтобы иметь предсказуемое поведение. Также у нас есть эффективных способ борьбы с
недействительными ссылками. Вся эта подготовительная работа проводиться в момент
компиляции. Есть ещё тему которые дополнят эту картину. В Главе 17 вы изучите
типажные объекты (это ещё один способ использовать типажи). В Главе 19 будет говориться
о сложных сценариях использования переменных времени жизни. В Главе 20 будет рассмотрена
система опций. В следующей главе будут рассказано, как написать тесты в Rust.</p>
<a class="header" href="print.html#aНаписание-автоматических-тестов" id="aНаписание-автоматических-тестов"><h1>Написание автоматических тестов</h1></a>
<blockquote>
<p>Тестирование программы может быть весьма эффективных средством проверки на наличие
ошибок, но оно, к сожалению, положительно пройденные тесты не могут говорить об
отсутствии ошибок.
Эдсгер Вибе Дейкстра, “Скромный программист” (1972)</p>
</blockquote>
<p>&quot;Программа работает корректно&quot; означает, что её код выполняет именно то, что мы
от него ожидаем. В языке программирования Rust этому аспекту работы программ уделяется
весьма много внимания. К сожалению, не всегда этого возможно достичь на все 100%.
Система типов Rust способствует упрощению достижения этой цели, но, к сожалению,
не может обеспечить исключения возможных ошибок. Именно поэтому в язык программирования
была включена поддержка тестирования.</p>
<p>Например, мы написали функцию <code>add_two</code>, которая добавляет два к любому введённому в
данную функцию числи и возвращает результат. После реализации и в момент компиляции
данной функции, Rust проверит типы и владение, для того чтобы исключить возможные
ошибки. К сожалению, компилятор <em>не сможет</em> проверить, что функция выполняет именно
то, что от неё требуется (т.е. не будет возвращаться иное значение, нежели то, что
было задумано программистом). Решить эту задачу поможет тестирование.</p>
<p>Мы можем написать тесты, которые проверять, например, что когда мы введём в функцию
число <code>3</code>, то будет возвращено число <code>5</code>. Мы можем выполнять эти тесты после внесения
изменений в код, чтобы убедиться, что всё работает корректно.</p>
<p>Тестирования - весьма сложная и многоаспектная тема для обсуждения. Поэтому в этой
главе будет разъеснена только механизмы тестирования в Rust. Мы расскажем об описаниях
и макросах доступных вам для написания тестов, о поведениях по умолчанию и возможностях
запуска тестов, об способах организации тестов в группы и об интеграционном тестировании.</p>
<a class="header" href="print.html#aКак-писать-тесты" id="aКак-писать-тесты"><h2>Как писать тесты</h2></a>
<p>Тесты в Rust - это функции специального вида, которые проверяют работу отдельных
частей программы. Тело функции-теста состоит из нескольких частей: установки входных
данных, тестирования исследуемой функции на ожидаемое поведение. Далее, будут рассмотрен
состав возможностей, который предлагается в Rust для этого: атрибуты, макросы, и
специальный атрибут <code>should_panic</code>.</p>
<a class="header" href="print.html#aСтруктура-функции-теста" id="aСтруктура-функции-теста"><h3>Структура функции-теста</h3></a>
<p>Простейшая функция-тест - это функция аннотируемая атрибутом <code>test</code>. Атрибуты -
это метаданные (мы их уже встречали в примерах кода (Глава 5)). Чтобы функция превратилась
в тест для этого необходимо добавить <code>#[test]</code> перед ключевым словом <code>fn</code>.
Далее, с помощью команды <code>cargo test</code> будут выполнены тесты и в строках вывода
будут информационные сообщения о ходе проведения тестирования.</p>
<p>При создании библиотеки кода в Главе 7 мы обращали внимание на то, что создаётся
специальный модуль и тестовая функция. Этот код создаётся для ускорения написания
тестов. Далее, мы можем добавить необходимое количество тестовых функций в наш проект.</p>
<p>Мы рассмотрим аспекты работы шаблонных тестов, а потом напишем тесты, которые
будут проверять корректность поведения написанного нами кода.</p>
<p>Создадим проект <code>adder</code>:</p>
<pre><code class="language-text">$ cargo new adder
     Created library `adder` project
$ cd adder
</code></pre>
<p>Содержание файла <code>src/lib.rs</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p><span class="caption">Пример кода 11-1: Тестовый модуль и функция генерируемая при
создании проекта библиотеки кода с помощью команды <code>cargo new</code></span></p>
<p>Сейчас проигнорируем первый две строчки кода и сфокусируемся на функции для того,
чтобы увидеть её работу. Обратите внимание на синтаксис описания <code>#[test]</code> перед
ключевым словом <code>fn</code>. Это атрибут сообщает компилятору, что далее будет заголовок
функции-теста. Функционал запускающий тесты на выполнение теперь знает, что это
особая функция - функция-тест. Также в составе модуля-тестов у нас могут бы вспомогательные
функции, не являющиеся тестами. Поэтому специальная аннотация (описание) так важна
для явного объявления функций - тестами.</p>
<p>Пока, функция не имеет содержания, что означает, что нет кода, который мог бы повлиять
на работу теста. Такой тест считается корректным.</p>
<p>Команда <code>cargo test</code> выполнить все тесты в выбранном проекте и сообщит о результатах 11-2:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><span class="caption">Результат работы программы 11-2: Вывод информации о работе
тестов</span></p>
<p>Cargo скомпилировал и выполнил тест. После строк <code>Compiling</code>, <code>Finished</code> и
<code>Running</code> мы видим строку <code>running 1 test</code>. Следующая строка показывает имя функции-теста.
Её имя  <code>it_works</code>. Результат её работы - <code>ok</code>. Далее вы видите обобщенную информации
о работе всех тестов: <code>test result: ok.</code> Это означает, что все тесты пройдены успешно.</p>
<p>Мы не должны отмечать тесты быть игнорированы, поэтому написано <code>0 ignored</code>.
Мы поговорим об игнорировании тестов в следующей секции.<code>0 measured</code> - это информация
об измерения производительности.</p>
<p>Следующая часть информации <code>Doc-tests adder</code> - это информация о тестировании документации.
У нас пока нет тестов документации, но Rust может компилировать любые примеры кодов,
которые находятся в API документации. Такая возможность помогает поддерживать документацию
в актуальном состоянии. Мы поговорим о тестировании документации в Главе 14. Пока
просто не будем обращать на эту информацию нашего внимания.</p>
<p>Давайте поменяем название нашего теста и посмотрим что же измениться в строке вывода.
Назовём нашу функцию <code>it_works</code> другим именем - <code>exploration</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
    }
}
#}</code></pre></pre>
<p>Снова выполним команду <code>cargo test</code>. В строке вывода мы увидим новое наименование
нашей функции-теста - <code>exploration</code> вместо <code>it_works</code>:</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Отлично! Добавим ещё один тест. Сделаем так, чтобы этот наш новый тест не срабатывал
специально. Используем для этого уже известный на макрос <em>panics</em>. Хочу обратить
ваше внимание на то, что каждый тест выполняет в новом потоке. Поэтому когда главный
поток выполнения тестов видит, что какой-либо тест не срабатывает - этот тест отмечается
как непройденный. Мы поговорим об особенностях использования макроса <em>panic</em> в Главе 9.
После написания нового тесты код будет выглядеть так (11-3):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
#}</code></pre></pre>
<p><span class="caption">Описание 11-3: Добавление второго теста. Второй тест вызывает
макрос <code>panic!</code></span></p>
<p>Запустим команду <code>cargo test</code>. Вывод результатов 11-4, которое сообщает, что тест
<code>exploration</code> пройден, а <code>another</code> нет:</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
    thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured

error: test failed
</code></pre>
<p><span class="caption">Описание 11-4: Описание результаты выполнения тестов</span></p>
<p>Вместо <code>ok</code>, строка <code>test tests::another</code> сообщает <code>FAILED</code>. У нас есть две новых
секции между результатами и итогами. Первая секция показывает детальную причину
ошибки теста. В данном случае тест <code>another</code> не сработал, т.к.  <code>panicked at 'Make this test fail'</code>,
в строке 9 файла <em>src/lib.rs</em>. В следующей секции находятся имена всех непройденных тестов.
Это удобно, когда тестов очень много. Мы можем использовать имя непройденного
теста для отладки. Это обсудим в следующей секции.</p>
<p>Далее следуют итоговые данные. У нас один тест пройден, а 1 непройден.</p>
<p>Теперь мы знаем как выглядят описания при различных ситуациях работы системы тестирования
в Rust. Далее мы расширим наши знания о тестировании и познакомимся с макросами для
тестирования.</p>
<a class="header" href="print.html#aПроверка-результатов-с-помощью-макроса-assert" id="aПроверка-результатов-с-помощью-макроса-assert"><h3>Проверка результатов с помощью макроса <code>assert!</code></h3></a>
<p>Макрос <code>assert!</code> доступен в стандартной библиотеке. Он удобен, когда вы хотите проверить
какое-либо условие. Внутри входных данных данного макроса вычисляет логическое
значение. Если результат <code>true</code>, <code>assert!</code> ничего не делает и тест считается пройденным.
Если же значение входного параметра макроса <code>assert!</code> <code>false</code> вызывается макрос
<code>panic!</code> и данный тест считается непройденным.</p>
<p>Вспомним пример кода из Главы 5 (5-9), где у нас была структура <code>Rectangle</code>
и метод <code>can_hold</code>. Повторим здесь код примера. Добавим код примера в файл <em>src/lib.rs</em>
и напишем тесты используя макрос <code>assert!</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &gt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 11-5: Структура <code>Rectangle</code> и его метод <code>can_hold</code></span></p>
<p>Метод <code>can_hold</code> возвращает булево (логическое) значение. Такой метод удобен для
тестирование. Сейчас напишим тест (11-6), который будет проверять результат работы
метода <code>can_hold</code> экземпляра структуры <code>Rectangle</code>. С помощью теста проверим может
ли прямоугольник шириной 8 и длинной 7 содержать прямоугольник другого размера
(длинной 5 и шириной 1):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
#}</code></pre></pre>
<p><span class="caption">Пример кода 11-6: Код теста для метода структуры Rectangle
<code>can_hold</code>, который проверяет корректность его работы</span></p>
<p>Если вы пишите тесты, которые мы описываем в один и тот же проект и файл, вы, наверное,
обратили внимание на работу с модулями. Описание модуля - это иерархическая синтаксическая
конструкция, которые может быть только в одном экземпляре в тексте программы.
Не может быть несколько объявлений модуля <em>tests</em> в файле тестируемой библиотеки.</p>
<p>Также обратите внимание на сроку кода <code>use super::*;</code>. Модуль <code>tests</code> подчиняется
тем же правилам видимости, что и все остальные модули (всё то, что мы обсуждали
в Главе 7). Т.к. этот модуль внутренний, ему нужно дать доступ на верхний уровень,
чтобы можно было бы создать экземпляр структуры и вызвать его метод (или получить
доступ к чему-либо ещё на этом уровне).</p>
<p>Обратите на реализацию нашего нового теста. Его название <code>larger_can_hold_smaller</code>.
В теле теста мы создаём два экземпляра структуры <code>Rectangle</code>. Далее, мы вызываем
метод из одно из экземпляров (в данном случае из переменной <code>larger</code>) и передаём в
метод ссылку  на вторую переменную <code>larger.can_hold(&amp;smaller)</code>. Это выражение мы
помещаем, как аргумент в макрос <code>assert!</code>. Т.к. метод возвращает логическое значение,
а макрос <code>assert!</code> принимает в качестве аргумента логическое значение, синтаксически
всё верно. Далее проверяем работу теста.</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Всё в порядке. Тест пройдёт. Теперь проверим, сообщит ли макрос об ошибке, если
мы попытаемся поместить большой прямоугольник в маленький:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { length: 8, width: 7 };
        let smaller = Rectangle { length: 5, width: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
#}</code></pre></pre>
<p>Т.к. правильный входной параметр данного макроса должен возвращать отрицательное значение,
с помощью логического &quot;не&quot; (<em>!</em>) мы корректно организовали проверку:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Отлично! Тесты работают. Теперь проверим, как отреагируют тесты, если мы добавим
ошибку в код метода <code>can_hold</code> - изменим знак сравнения в одной из логических выражений
на противоположное:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.length &lt; other.length &amp;&amp; self.width &gt; other.width
    }
}
#}</code></pre></pre>
<p>Строки вывода:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
    thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
    larger.can_hold(&amp;smaller)', src/lib.rs:22
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Наши тесты нашли ошибки! В тесте  <code>larger.length</code> равно 8 и <code>smaller.length</code> равно 5.
Выражения сравнения в методе <code>can_hold</code> дают результат <code>false</code>, т.к. 8 больше 5.</p>
<a class="header" href="print.html#aПроверка-на-равенство-с-помощью-макросов-assert_eq-и-assert_ne" id="aПроверка-на-равенство-с-помощью-макросов-assert_eq-и-assert_ne"><h3>Проверка на равенство с помощью макросов <code>assert_eq!</code> и <code>assert_ne!</code></h3></a>
<p>Весьма часто для проверки работы методов и функций используется сравнение выходного
результата и предполагаемого значения. Для этого мы можем использовать макрос <code>assert!</code>
и оператор <code>==</code>. Важно также знать, что кроме этого макроса стандартная библиотека
предлагает использовать макросы <code>assert_eq!</code> и <code>assert_ne!</code>. Использование этих
макросов повышает читабельность кода. Кроме собственно проверки на равенство,
эти макросы также печатают значения входных параметров, если тест завершился ошибкой.
Эти макросы также более информативны, чем предыдущий, т.к. мы увидим ошибочные
входные данные.</p>
<p>В примере кода 11-7, мы создадим функции <code>add_two</code>, которая прибавляет к входному
параметру 2 и возвращает значение. Then let’s test this function using the
<code>assert_eq!</code> macro:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 11-7: Тестирование функции <code>add_two</code> используя макрос
<code>assert_eq!</code> macro</span></p>
<p>Проверим! Запустим тесты снова.</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Всё в порядке. Функция работает как и предполагалось.</p>
<p>Теперь проверим, как будет выявлена ошибка. Изменим реализацию функции <code>add_two</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
#}</code></pre></pre>
<p>Попробуем выполнить данный тест ещё раз:</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
    thread 'tests::it_adds_two' panicked at 'assertion failed: `(left ==
    right)` (left: `4`, right: `5`)', src/lib.rs:11
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Наш тест нашел ошибку. Мест <code>it_adds_two</code> не сработал и сообщил важную информацию
для начала поиска ошибки в коде программы.</p>
<p>Обратите внимание, что в некоторых языках (таких как Java) в библиотеках кода
для тестирования принято именовать входные параметры проверочных функций &quot;предполагаемое&quot;
(<code>expected</code>) и &quot;фактическое&quot; (<code>actual</code>). В Rust приняты следующие обозначения
<code>left</code> и <code>right</code>, соответственно. Кроме того макросам тестирования совершенно не важно,
где находится предполагаемое (слева или справа), а где фактическое. Информационные
сообщения будут достаточно информативны:
<code>assertion failed: `(left == right)` (left: `5`, right: `4`)</code>.</p>
<p>Макрос <code>assert_ne!</code> сработает успешно, если входные параметры не равны друг другу.
Этот макрос будет полезен в тех случаях, когда вы не знаете, какое точно может быть
значение, то знаете точно, каким оно быть не может. К примеру, если у вас есть
функция, которая изменяет входные данные определённым образом. Лучший способ проверить
правильность работы такой функции - сравнить входное и выходное значения. Они не
должны быть равными.</p>
<p>С своей работе макросы <code>assert_eq!</code> и <code>assert_ne!</code> неявным образом используют
операторы <code>==</code> и <code>!=</code>. Когда тест не сработает, макросы напечатают значения аргументов
с помощь отладочного форматирования (что в свою очередь значит, что значения аргументов
должны реализовать типажи <code>PartialEq</code> и <code>Debug</code>). Все примитивные типы стандартной
библиотеки Rust реализовали эти типажи. Для структур и перечислений, которые вы
сами реализуете вы должны реализовать типаж <code>PartialEq</code> для сравнения значений.
Для печати отладочной информации в виде сообщений в строку вывода консоли необходимо
реализовать типаж <code>Debug</code>. Эти типажи можно реализовать добавив аннотацию
<code>#[derive(PartialEq, Debug)]</code>на определение структуры или перечисления.</p>
<a class="header" href="print.html#aСоздание-сообщений-об-ошибках" id="aСоздание-сообщений-об-ошибках"><h3>Создание сообщений об ошибках</h3></a>
<p>Продолжим изучать работу с макросами для тестирования. Конечно, было бы удобно,
если была бы возможность добавить дополнительную информацию при выводе ошибки.
И такая возможность есть. Это опциональный текстовый аргумент, которые обрабатывается
макросом <code>format!</code>. Такие сообщения удобны для более детального раскрытия информации
о состоянии теста, ожидаемых результатах, возможных причинах ошибки и способах её
устранения.</p>
<p>Например, создадим функцию, которая приветствует человека по имени. Протестируем
эту функцию. Мы хотим чтобы вводимое имя выводилось на консоль:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
#}</code></pre></pre>
<p>Теперь внесём ошибку в функцию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
#}</code></pre></pre>
<p>Running this test produces:</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'assertion failed:
    result.contains(&quot;Carol&quot;)', src/lib.rs:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>Сообщение содержит лишь информацию о том что сравнение не было успешным. Сообщение
было бы более информативным, если бы выводило также выходные данные. Изменим
тестовую функцию для того, чтобы выводились форматированное сообщение:</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>После того, как выполним тест ещё раз мы получим подробное ожидаемое сообщение:</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'Greeting did not contain
    name, value was `Hello`', src/lib.rs:12
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Это сообщение поможет нам в отладке (получим то, что есть, вместо того что должно быть).</p>
<a class="header" href="print.html#aПроверка-с-помощью-макроса-should_panic" id="aПроверка-с-помощью-макроса-should_panic"><h3>Проверка с помощью макроса <code>should_panic</code></h3></a>
<p>Кроме проверок выходных данных также важно, проверить условия при которых могу быть
ошибки. Например, рассмотрим инициализацию структуры <code>Guess</code>, которую мы создали в
Главе 9 (9-8). При создании экземпляра структуры проверяется входной параметр (он
должен быть между 1 и 100). Мы можем написать тест, который проверит реакцию кода
инициализации на неправильные входные данные.</p>
<p>Реализуем это с помощью атрибута функции теста <code>#[should_panic]</code>. Этот атрибут
сообщает системе тестирования, что этот метод должен генерировать ошибку. Если ошибка
не генерируется - тест считается непройденым.</p>
<p>Код программы 11-8 показывает, как надо написать такой тест:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 11-8: Тестирование генерации <code>panic!</code></span></p>
<p>Атрибут <code>#[should_panic]</code> следует после <code>#[test]</code> и до объявления текстовой функции.
Строка вывода может выглядеть следующим образом:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Отлично! Теперь внесём ошибку:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Guess {
#     value: u32,
# }
#
impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
#}</code></pre></pre>
<p>Вид обновлённой строки вывода:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Обратите внимание, что сообщение не очень информативное.
Мы можем улучшить взаимодействие с атрибутом <code>should_panic</code> добавив параметр - ожидаемую
подстрку выводимого при генерации ошибки сообщения:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 11-9: Тестирования случая вызова макроса
<code>panic!</code> содержащего предполагаемую ошибку</span></p>
<p>Этот тест сработает, т.к. соблюдены все условия.</p>
<p>Изменим код (внесём ошибку и посмотрим на результат):</p>
<pre><code class="language-rust ignore">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>Ошибка:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
    thread 'tests::greater_than_100' panicked at 'Guess value must be greater
    than or equal to 1, got 200.', src/lib.rs:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Эта ошибка говорит нам о том, что параметр атрибута не содержиться в генерируемом
макросом <code>panic!</code> сообщении. Также приводится тестовый параметр атрибута <code>should_panic</code>,
что, возможно, поможет найти ошибку в коде.</p>
<p>Теперь, когда вы научились писать тесты, в следующей секции мы приступим к детальной
настройке запуска тестов с помощью команды <code>cargo test</code>.</p>
<a class="header" href="print.html#aКонтролирование-хода-выполнение-тестов" id="aКонтролирование-хода-выполнение-тестов"><h2>Контролирование хода выполнение тестов</h2></a>
<p>Также как команда <code>cargo run</code> компилирует и затем выполняет созданный бинарный файл,
команда <code>cargo test</code> компилирует его в тестовом режиме а затем выполнят его.
Для изменения поведения команды по умолчанию существуют параметры, на которые можно
влиять при запуске тестирования. Например, по умолчанию, система управлением запуска
тестов (СУЗТ) выполняет тесты параллельно (т.е. создаётся поток для каждого теста, чтобы
обеспечить изолированное выполнение каждого теста). Кроме того СУЗТ собирает консольные
сообщения каждого теста и форматирует их и выводит по своим правилам. Есть возможность
менять это поведение с помощь опций командной строки при запуске команды <code>cargo test</code>.</p>
<p>Опции команды <code>cargo test</code>  могут быть добавлены после,
опции для тестов должны устанавливаться дополнительно (следовать далее). Для разделения
этих двух типов аргументов используется разделитель <code>--</code>. Чтобы узнать подробнее об
доступных опциях команды <code>cargo test</code> - используйте опцию <code>--help</code>. Для того, чтобы узнать
об опциях доступных для непосредственно для тестов используйте команду <code>cargo test -- --help</code>.
Обратите внимание, что данную команду необходимо запускать внутри cargo-проекта
(пакета).</p>
<a class="header" href="print.html#aВыполнение-тестов-параллельно-или-последовательно" id="aВыполнение-тестов-параллельно-или-последовательно"><h3>Выполнение тестов параллельно или последовательно</h3></a>
<p>Когда выполняется несколько тестов они выполняются параллельно (по умолчанию).
Это значит, что тесты завершат свою работу быстрее, т.е. мы быстрее узнаем успешно
работают тесты или нет. Важно соблюдать независимость работы тестов.</p>
<p>Например, когда тесты создают в одном и том же месте  на диске файл с одним и тем же
названием, читают из него данные, записывают их - вероятность ошибки в работе таких
тестов (из-за конкурирования доступа к ресурсу, некорректных данных в файле) весьма
высока. Решением будет использование уникальных имён создаваемых и используемых каждым
тестом в отдельности, либо выполнение таких тестов последовательно.</p>
<p>Для выполнения тестов последовательно, пожалуйста запустите следующую команду в
папке проекта с тестами:</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<p>В данной команде мы сообщили количество потоков, которое будет использовано системой
тестирования для запуска всех тестов (т.к. количество 1, то все тесты будут работать
последовательно).</p>
<a class="header" href="print.html#aДемонстрация-результатов-работы-функции" id="aДемонстрация-результатов-работы-функции"><h3>Демонстрация результатов работы функции</h3></a>
<p>По умолчанию, если тест пройден, СУЗТ блокирует вывод на печать, т.е. если вы вызовете
макрос <code>println!</code> внутри кода теста и тест будет пройден, вы не увидите вывода
на консоль результатов вызова <code>println!</code>. Если же тест не был пройден, все информационные
сообщение, а также описание ошибки будет выведено на консоль.</p>
<p>Например, в коде (11-10) функция выводить значение параметра с поясняющим текстовым
сообщением, а также возвращает целочисленное константное значение <code>10</code>. Далее,
следуют тест, который имеет правильный входной параметр и тест, который имеет ошибочный
входной параметр:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
#}</code></pre></pre>
<p><span class="caption">Listing 11-10: Тест функции, которая использует макрос <code>println!</code>
<code>println!</code></span></p>
<p>Результат вывода на консоль команды <code>cargo test</code>:</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
    I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left ==
right)` (left: `5`, right: `10`)', src/lib.rs:19
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Обратите внимание, что мы не увидели вывода на консоль работы корректно сработавшего
теста <code>I got the value 4</code>. Этот вывод был проигнорирован. А вот результат работы
программы, при неработающем тесте был показан (для лучшего понимания ошибки).</p>
<p>Для того, чтобы всегда видеть вывод на консоль и корректно работающих программ,
используйте флаг <code>--nocapture</code>:</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<p>Выполним тесты ещё раз с этим флагом:</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left ==
right)` (left: `5`, right: `10`)', src/lib.rs:19
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Обратите внимание, что есть какая-то неразбериха в косольном выводе. Всё это из-за
того, что тесты выполняются параллельно. Этого можно избежать с помощью опции
<code>--test-threads=1</code>. Пожалуйста, проверьте работу команды с флагом <code>--nocapture</code> ещё
раз с последовательном выводом данных на экран.</p>
<a class="header" href="print.html#aЗапуск-теста-по-имени-running-a-subset-of-tests-by-name" id="aЗапуск-теста-по-имени-running-a-subset-of-tests-by-name"><h3>Запуск теста по имени Running a Subset of Tests by Name</h3></a>
<p>Бывают случаи, когда в запуске всех тестов нет необходимости и нужно запустить
только несколько тестов. Если вы работаете на над функцией и хотите запустить
тесты, которые исследуют её работу - это было бы удобно. Вы можете это сделать,
используя команду <code>cargo test</code>.</p>
<p>Для демонстрации как запустить группу тестов мы создадим группу тестов для функции
<code>add_two</code> (код программы 11-11) и постараемся выбрать интересующие нас тесты при
их запуске:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 11-11: Три теста с различными именами</span></p>
<p>Если вы выполните команду <code>cargo test</code> без уточняющих аргументов, все тесты выполнятся
параллельно:</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<a class="header" href="print.html#aЗапуск-одного-теста" id="aЗапуск-одного-теста"><h4>Запуск одного теста</h4></a>
<p>Мы можем запустить один тест с помощью указания его имени в команде <code>cargo test</code>:</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>К сожалению, таким простым образом (списком тестов) мы не можем запустить несколько тестов.
Только первый тест из списка будет запущен. Пожалуйста, проверьте как это работает
(точнее, убедитесь, что это не работает).</p>
<a class="header" href="print.html#aИспользование-фильтров-для-запуска-нескольких-тестов" id="aИспользование-фильтров-для-запуска-нескольких-тестов"><h4>Использование фильтров для запуска нескольких тестов</h4></a>
<p>Существует возможность по имени (с использованием фильтров) запустить несколько тестов.
Например, мы знаем, что несколько тестов содержат <code>add</code>. Для того, чтобы запустить
вполне достаточно этих знаний:</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Обратите внимание, что у нас получилось выполнили тесты с именем <code>add</code>. Также
обратите внимание, что имя модуля включено в имя теста. Таким образом мы можем
запустить тесты используя имя модуля, в котором он находятся.</p>
<a class="header" href="print.html#aИгнорирование-тестов" id="aИгнорирование-тестов"><h3>Игнорирование тестов</h3></a>
<p>Бывают случаи, когда выполнение тестов может занимать продолжительное время и
нет необходимости в их постоянном запуске. Для этих случаев существует
атрибут <code>ignore</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert!(true);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
#}</code></pre></pre>
<p>Мы добавили атрибут <code>#[ignore]</code> для того, чтобы описать исключаемую функцию из списка тестов.
Теперь, когда мы запустим команду <code>cargo test</code>, данный тест будет проигнорировал,
о чём будет сообщено в описании результатов тестирования:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Выполнение теста <code>expensive_test</code> было проигнорировано. Если же вы хотите выполнить
только проигнорированные тесты, вы можете сообщить это с помощью команды
<code>cargo test -- --ignored</code>:</p>
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Подведём итоги. Вы можете фильтровать тесты по имени при запуске. Вы также можете указать
какие тесты должны быть проигнорированы, а также отдельно запускать проигнорированные
тесты.</p>
<a class="header" href="print.html#aОрганизация-процесса-тестирования" id="aОрганизация-процесса-тестирования"><h2>Организация процесса тестирования</h2></a>
<p>Как мы уже упоминали в начале главы, тестирование - довольно-таки обширная тема,
в которой существует несогласованность в терминологии и методологии. В Rust-сообществе
принято говорить о тестировании в как модульном (<em>unit tests</em>) и интеграционном
(<em>integration tests</em>). Модульные тесты - это короткие, изолированные по среде выполнения
и времени тесты. Данные тесты могут проверять работу внутренний (private) частей
модулей. Интеграционные тесты - это тестирование функционала вашей библиотеки при
взаимодействии с другими, внешними контейнерами. В данных тестах можно использовать
только открытие (pub) функционал, чтобы проверить его работу, как внешний компонент.</p>
<p>Реализация всех этих типов тестов важна для понимания надежности работы компонент,
как изолировано, так и совместно с внешними контейнерами.</p>
<a class="header" href="print.html#aМодульные-тесты" id="aМодульные-тесты"><h3>Модульные тесты</h3></a>
<p>Целью модульного тестирования является изолированное от остального функционала
проекта малой части программы, чтобы можно было быстро понять, что не работает корректно.
Мы сохраняем такие тесты в папку <em>src</em>, там же где и тестируемый функционал.
В Rust принято называть тестирующий модуль <code>tests</code> и его код сохранять в тот же
файл, что предстоит тестировать. Также необходимо добавить аннотацию <code>cfg(test)</code>
к этому модулю.</p>
<a class="header" href="print.html#aИспользование-аннотации-cfgtest" id="aИспользование-аннотации-cfgtest"><h4>Использование аннотации <code>#[cfg(test)]</code></h4></a>
<p>Аннотация <code>#[cfg(test)]</code> тестирующего модуля сообщает компилятору, что необходимо
компилировать и тестировать по команде <code>cargo test</code>. Это позволяет экономить время
на компиляцию, когда необходимо только лишь компиляция (без тестирования). При обычной
компиляции код тестирующего модуля не входит в компилируемый код.
Т.к. интеграционные тесты не входят в состав файла тестируемого функционала код
таких тестов не нуждается в этой специальной аннотации.</p>
<p>Как вы, конечно, помните при создание нового проекта библиотеки в файл исходного
кода добавляется код тестирующего модуля:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p>Атрибут <code>cfg</code> - это сокращение от слова конфигурация (<em>configuration</em>). Он сообщает
компилятору, что аннотируемый модуль необходимо включать в только лишь при соблюдении
определенных в конфигурации условий (в данном случае - это условие <code>test</code>). Т.е.
если <code>carogo</code> будет запущен с опцией <code>test</code> компилятор будет работать с этой частью
кода.</p>
<a class="header" href="print.html#aТестирования-функций-с-ограниченной-областью-видимости-private" id="aТестирования-функций-с-ограниченной-областью-видимости-private"><h4>Тестирования функций с ограниченной областью видимости (private)</h4></a>
<p>Сообщество программистов не имеет однозначного мнения по поводу способа тестирования
закрытых (private) функций. В некоторых языках весьма сложно или даже невозможно
тестировать такие функции. В Rust закрытые функции. Рассмотрим пример (11-12)
тестирования закрытой функции:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 11-12: Тестирование закрытых функций</span></p>
<p>Обратите внимание, что функция <code>internal_adder</code> не объявлена открытой (<code>pub</code>), но
так как тестирующий модуль имеет возможность импортировать код <code>use super::*;</code>
тест скомпилируется и выполниться без каких-либо проблем. Если же вы считает, что
закрытые функции не должны быть тестируемы - Rust также не будет вас в этом ограничивать,
сопровождая предупреждениями компиляцию кода.</p>
<a class="header" href="print.html#aИнтеграционные-тесты" id="aИнтеграционные-тесты"><h3>Интеграционные тесты</h3></a>
<p>Интеграционные тесты в Rust должны быть внешними относительно тестируемой библиотеки.
Тесты моделируют различные сценарии использования библиотеки. Идет взаимодействие
с помощью открытых интерфейсов. Целью данного тестировать проверить слаженность выполнения
сценариев работы функционалом библиотеки в целом. Коды интеграционных тестов храниться
в папке проекта <em>tests</em>.</p>
<a class="header" href="print.html#aСодержание-папки-tests" id="aСодержание-папки-tests"><h4>Содержание папки <em>tests</em></h4></a>
<p>Для создания интеграционных тестов вам понадобиться создать папку <em>tests</em> в корневой
папке вашего проекта (в той же, где находится папка <em>src</em>). По условиям конвенций
Cargo интеграционные файлы с тестами будут храниться в этой директории. Каждый такой
файл будет компилироваться в отдельный контейнер (crate).</p>
<p>Начнем практику. В корневой папке проекта <code>adder</code> создадим папку <em>tests</em>.
Далее создадим файл <em>tests/integration_test.rs</em> и в него внесём следующий код (11-13):</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Код программы 11-13: Интеграционный тест контейнера <code>adder</code></span></p>
<p>Обратите внимание, что мы добавили дополнительную информацию для компилятора в для
теста <code>extern crate adder</code>, которая для модульного теста не нужна. Т.к. при тестировании
происходит моделирование изоляции при доступе к тестируемому функционалу, а физически
кода тестов и исходные коды разделены по разным папкам, описания тестируемого контейнера
необходимо.</p>
<p>Также обратите внимание, что нам не нужно добавлять конфигурационный атрибут в
аннотацию тестов. Cargo считает директорию <code>tests</code> специальной и данные тесты будут
компилироваться, только в случае запуска команды тестирования <code>cargo test</code>.
Убедимся на практике:</p>
<pre><code class="language-text">cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Обратите внимание, что интеграционные тесты будут запускаться только если модульные
тесты успешно сработали. Если в них будут ошибки. Интеграционные тесты не будут
запущены.</p>
<p>Подведем промежуточные итоги. При запуске команды тестирования, по умолчанию,
у нас есть три секции вывода: секция модульных тестов, секция интеграционных тестов
и секция тестов документации. В первой секции описание прохождения модульных тестов
следуют один за одним.</p>
<p>В секции интеграционных тестов мы видим, что воздаются файлы для каждого теста
и мы видим их названия. Далее идёт сводное описание работы интеграционных тестов.</p>
<p>Каждый интеграционный тест имеет свою секцию описания. Т.е. чем больше будет интеграционных
тестов, тем больше будет секций описания.</p>
<p>Мы также можем запускать интеграционные тесты по имени. Для запуска всех тестов
в выбранном файле интеграционных тестов, используйте аргумент <code>--test</code> команды
<code>cargo test</code>. Например:</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Эта команда запускает только те тесты, которые содержаться в файле
<code>integration_test.rs</code> в папке <em>tests</em>.</p>
<a class="header" href="print.html#aПодмодули-в-интеграционных-тестах" id="aПодмодули-в-интеграционных-тестах"><h4>Подмодули в интеграционных тестах</h4></a>
<p>При росте числа интеграционных тестов, естественным путём оптимизации будет разделение
тесты на отдельные файлы.</p>
<p>Реализация каждого интеграционного теста, как одного модуля оправдано с точки зрения
реализации изоляции. Недостатком такого разделения является наложение ограничений
на возможности общего доступа к функциям, структурам и пр. между файлами тестов.
К примеру, если вы создадите файл <em>tests/common.rs</em> и создадите в ней функцию
<code>setup</code>, то чтобы иметь доступ к этой функции из другого файла интеграционных тестов,
то вам придётся разместить кода данной функции в других файлах (копированием и
вставкой):</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn setup() {
    // setup code specific to your library's tests would go here
}
#}</code></pre></pre>
<p>Если вы запустите команду запуска тестирования снова, то вы увидите новую секцию
для файла <em>common.rs</em>, даже если файла не содержать тестов:</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Наличие секции <code>common</code> и текстов типа <code>running 0 tests</code> не то, чтобы мы хотели.
Необходимо иметь доступ всем интеграционным файлам к этой функции.</p>
<p>Для этой цели можно создать модуль <em>tests/common/mod.rs</em>. Когда вы перенесёте
функцию <code>setup</code> это файл, секцию, которую мы видели при предыдущем запуске
тестирования (<em>common...</em>) не будет показана. Файлы в поддиректории папки <em>tests</em>
не компилируются, как отдельные контейнеры.</p>
<p>После того, как вы создали модуль <em>tests/common/mod.rs</em> мы можем использовать
содержание его функций в любых интеграционный файлах. Создадим тест и испльзуем
функцию <code>setup</code> в файле <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Обратите внимание на ссылку на модуль  <code>mod common;</code>. Далее, в коде теста
вы можете получить доступ к функции <code>common::setup()</code>.</p>
<a class="header" href="print.html#aИнтеграционные-тесты-для-бинарных-контейнеров" id="aИнтеграционные-тесты-для-бинарных-контейнеров"><h4>Интеграционные тесты для бинарных контейнеров</h4></a>
<p>Если наши проект является бинарным контейнером и содержать только <em>src/main.rs</em>
и не содержит <em>src/lib.rs</em> мы не можем создать интеграционные тесты в папке
<em>tests</em> и использовать <code>extern crate</code> для импорта функций объявленных в файле
<em>src/main.rs</em>. Только библиотечные контейнеры могут быть использованы для хранения
кода, к которому можно получить доступ. Бинарные контейнеры могу запущены на выполнение.</p>
<p>Поэтому, основной код программной логики контейнера удобно хранить в файле <em>src/lib.rs</em>.
Код в файле <em>src/main.rs</em> содержать только запускающие функции и минимальную логику,
которую не надо тестировать ввиду её очевидной простоты</p>
<a class="header" href="print.html#aИтоги-7" id="aИтоги-7"><h2>Итоги</h2></a>
<p>Возможности тестирования в Rust предполагают определенный стиль написания тестов для
создаваемых модулей. Существуют два типа тестирования, которые имеют разные задачи
и поэтому реализуются различным образом. Тестирования является важным элементом
жизненного цикла программного обеспечения и разработчика Cargo знают об этом и предлагают
рациональные решения этой задачи.</p>
<p>Пожалуйста, объедините полученные знания и приступайте. В следующей главе и будете
использовать знания и навыки накопленные за время учёбы Rust.</p>
<a class="header" href="print.html#aРабота-с-файловой-системой-io-Создание-консольного-приложения" id="aРабота-с-файловой-системой-io-Создание-консольного-приложения"><h1>Работа с файловой системой (I/O). Создание консольного приложения</h1></a>
<p>В этой главе вы примените все знания полученные в предыдущих, а также познакомитесь
с ещё не изученными API стандартной библиотеки. Мы будем создавать консольное приложение,
которое будет использовать файл для чтения и записи. Также вы будете использовать
возможности командной строки.</p>
<p>Скорость, безопасность, компиляция для множество платформ делает язык Rust удобным
для создания консольных приложений. Создадим на Rust аналог приложения <code>grep</code>.
Акроним greap расшифровывается, как глобальное средство писка и печати
“<strong>G</strong>lobally search a <strong>R</strong>egular <strong>E</strong>xpression and <strong>P</strong>rint.”. Часто <code>grep</code>
используется для поиска файлов содержащих определенный текст. Для этого программа
получает имя файла и строку как аргументы командной строки, далее читает файл и ищёт
строки в этом файле, которые содержат искомый текст. Результатом работы программы
являются строки, в которых были найдены этот текст.</p>
<p>Попутно, мы покажем как применять широко используемые возможности командной строки.
Мы будет считывать значения переменной среды для настройки приложения. Также мы
будем печатать в поток ошибок (<code>stderr</code>) вместо стандартного потока (<code>stdout</code>).
Это удобно в тех случаях, когда пользователь может выбрать направления вывода данных
(в файл - при безошибочной работе и на консоль ошибок при каких-либо сложностях в
работе программы).</p>
<p>Один из участников Rust-сообщества, Эндрю Галлант (Andrew Gallant) уже реализовал
полнофункциональную, очень быстрый аналог программы <code>grep</code> и назвал её
<a href="https://github.com/BurntSushi/ripgrep"><code>ripgrep</code></a><!-- ignore -->. Создаваемая же
нами программы будет намного проще, но в тоже время вы получите знания для понимания
этапов создания подобных проектов.</p>
<p>Создаваемый проект будет использовать ранее изученные концепции:</p>
<ul>
<li>Организация кода в виде модулей (Глава 7)</li>
<li>Использование векторов и строк (коллекции, Глава 8)</li>
<li>Обработка ошибок (Глава 9)</li>
<li>Использование типажей и переменных времени жизни (Глава 10)</li>
<li>Написание тестов (Глава 11)</li>
</ul>
<p>Также мы сообщим о замыканиях, итераторах, объектах-типажах, которые будут подробнее
описаны в главах 13 и 17.</p>
<a class="header" href="print.html#aПринятие-аргументов-командной-строки-в-консольном-приложении" id="aПринятие-аргументов-командной-строки-в-консольном-приложении"><h2>Принятие аргументов командной строки в консольном приложении</h2></a>
<p>Создадим новый проект консольного приложения с помощью команды <code>cargo new --bin minigrep</code>
для того, чтобы различать наше приложение от <code>grep</code>:</p>
<pre><code class="language-text">$ cargo new --bin minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>Первой задачей для реализации в нашем приложении будет принятие двух переменных командной
строки: имени файла и строки для поиска. Мы будем запускать нашу программ у с помощью
команды <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Пока наша программа не может обработать входные параметры командной строки. Для
этой цели существует специальная библиотека в <em>crates.io</em>, которая может помощь решить
данную задачу.</p>
<a class="header" href="print.html#aЧтение-значений-аргументов" id="aЧтение-значений-аргументов"><h3>Чтение значений аргументов</h3></a>
<p>Для того чтобы быть уверенным, что программа может получать значения аргументов
командной строки, первое что нужно сделать, это подключить функционал стандартной
библиотеки: <code>std::env</code>. Эта функция возвращает итератор (<em>iterator</em>) аргументов
командной строки. Мы сейчас не будем вдаваться в подробности работы итераторов.
Разберём эту тему в Главе 13. Сейчас нужно лишь понять, что итераторы создают
последовательность значений и мы можем вызвать метод <code>std::env::args().collect()</code>
для того, чтобы передать их в коллекцию. Например, в вектор.</p>
<p>Рассмотрим пример (12-1), в котором программа будет считывать значения командной
строки и сохранять их в вектор.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p>Listing 12-1: Считывание аргументов командной строки в вектор и печать этих данных
на консоль</p>
<p>Разберем код этой программы. В первой строке мы добавляем импорт модуля <code>std::env</code>.
После импорта модуля в коде программы становятся доступна функция <code>args</code>. Обратите
внимания на модульную вложенность этой функции <code>std::env::args</code>. Для того чтобы
сократить длину пути к вложенной функции мы заранее объявляем доступ к содержанию
модуля командой <code>use</code>. Для предотвращения возможных недоразумений в принято, что
функция модуля вызывается с префиксом родительского модуля <code>env::args()</code>. Это предотвращает
возможные конфликты названий функций в текущем модуле и импортируемом модуле.
Пожалуйста, разберите работу этого кода программы, посмотрите что возвращает функция
<code>arg()</code>, каково содержание вектора. Запускайте программу с разными аргументами
и смотрите как она работает.</p>
<blockquote>
<a class="header" href="print.html#aФункция-args-и-недействительный-символы-Юникода-unicode" id="aФункция-args-и-недействительный-символы-Юникода-unicode"><h3>Функция <code>args</code> и недействительный символы Юникода (Unicode)</h3></a>
<p>Возможно вы не обратили внимания, но функция <code>std::env::args</code> не является универсальной.
Если в качестве аргументов будут выступать недействильены символы юникода сработает
макрос <code>panic</code>. Если же нужно принимать подобные аргументы, то необходимо использовать
функция <code>std::env::args_os</code>. Эта функция возвращает <code>std::ffi::OsString</code>.</p>
</blockquote>
<p>Метод <code>args</code> возвращает итератор. Вызов метода итератора <code>collect</code> возвращает
вектор содержащий все переданные в командрую строку данные. Функция <code>collect</code>
универсальная и может возвращать различные коллекции данных. Для того, чтобы для
компиляции кода было достаточно информации, необходимо сообщить какой тип данных
мы ожидаем в описание декларации переменной <code>let args:</code>.</p>
<p>Последняя строка нашего кода печатает содержимое вектора. Формат описания данные -
отладка <code>:?</code>. Надеюсь, что дочитав до этой строки вы уже неоднократно запускали
созданный код на выполнение:</p>
<pre><code class="language-text">$ cargo run
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
...snip...
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Вы, конечно же, обратили внимание на первый элемент в коллекции - это <code>&quot;target/debug/minigrep&quot;</code>.
Это, как вы поняли, имя бинарного файла. Работа обработки строк командной напоминает
работу c-компилятора. Весьма удобно иметь доступ к имени программы, для написания
сообщений или изменять поведение программы на основании вводимых данных. Для целей
данной главы мы будем обращать внимание только на необходимые для решения поставленной
задачи аргументы.</p>
<a class="header" href="print.html#aСохранения-значений-аргументов-в-переменные" id="aСохранения-значений-аргументов-в-переменные"><h3>Сохранения значений аргументов в переменные</h3></a>
<p>Вывода на печать значений аргументов командной строки  - это простой тест возможности
программы иметь доступа к аргументам командной строки. Далее, нам надо сохранить
значение аргументов в переменные, чтобы иметь возможность их использования далее в
программе. Пример реализации (Код 12-2):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p>Listing 12-2: Создание переменных для хранения шаблона поиска и имени файла</p>
<p>Как мы уже знаем из наших предыдущих упражнений, первый аргумент вектора хранит
полное имя бинарного файла в ячейке вектора <code>args[0]</code>. Далее идут вводимые в командной
строке аргументы. По условию задачи первым аргументом должен быть шаблон поискового
запроса, а второй имя текстового файла, в котором будет осуществлён поиск.</p>
<p>Для проверки корректности работы нашей программы значения переменных были выведены
на консоль. Далее запустим нашу программ со следующими аргументами: <code>test</code> и <code>sample.txt</code>:</p>
<pre><code class="language-text">$ cargo run test sample.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Отлично! Всё работает корректно. Для простоты изложения материала мы пока не будет
вводить функционал отслеживающие неправильный ввод данных.</p>
<a class="header" href="print.html#aЧтение-файла" id="aЧтение-файла"><h2>Чтение файла</h2></a>
<p>Далее, мы дополним функционал нашей программы, чтобы иметь возможность читать
содержимое файла. Для начала создадим файл в корне нашего проекта с текстовыми данными <code>poem.txt</code> и добавим
в него следующее содержание стихотворение “I’m nobody! Who are you?”:</p>
<p><span class="filename">Filename: poem.txt</span></p>
<pre><code class="language-text">I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Тест 12-3: Стихотворение Эмили Дикинсон “I’m nobody! Who are you?”</span></p>
<p>Далее, рассмотрим код решающий поставленную задачу  <em>src/main.rs</em>  12-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
#     let args: Vec&lt;String&gt; = env::args().collect();
#
#     let query = &amp;args[1];
#     let filename = &amp;args[2];
#
#     println!(&quot;Searching for {}&quot;, query);
    // ...snip...
    println!(&quot;In file {}&quot;, filename);

    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">Код 12-4: Чтение содержания файла</span></p>
<p>Изучим содержание исходного кода. Прежде всего, мы добавили импорт необходимых
модулей и структуры. Для чтения файла нам необходимо:</p>
<ol>
<li>Модуль <code>std::env</code>.</li>
<li>Структура <code>std::fs::File</code>.</li>
<li>Всё содержимое модуля <code>std::io::prelude::*</code>. В этом модуле есть множество типажей для работы с файлами.</li>
</ol>
<p>Коде функции <code>main</code> мы добавили вызов функции <code>File::open</code>, входным параметром, которой
является содержание переменной <code>filename</code>. Далее мы создали переменную <code>contents</code>,
установив атрибут изменяемости  и присвоив экземпляр структуры данных <code>String</code>.
Данная переменная будет содержащийся текст в открытом файле. Далее, используя метод
экземпляра структуры <code>File</code> <code>read_to_string</code> производим считывание текста в переменную
и выводим её содержание на консоль.</p>
<p>Пожалуйста, проверьте работу нашей программы. Введите какой-либо текст в качестве
первого аргумента и название файла вторым аргументом:</p>
<pre><code class="language-text">$ cargo run the poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us — don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Отлично! Наша программа может читать текстовые данные файла. Хотя наша программа
решает поставленную задачу, она не лишена недостатков. Прежде всего функция <code>main</code>
решает множество задач. Такую функцию неудобно тестировать. Далее, не отслеживаются
возможные ошибки ввода данных. Пока наша программа небольшая - данными недочётами
можно пренебречь. При увеличении размеров программы такую программу будет всё сложнее
и сложнее поддерживать. Хорошей практикой программирования является трансформация,
перестройка кода (refactoring) по мере её усложнения. Поэтому далее мы улучшим наш
код с помощью улучшения его структуры.</p>
<a class="header" href="print.html#aРеструктуризация-рефакторинг-refactoring-кода-для-улучшения-его-модульности-и-получение-возможности-отслеживания-возможных-ошибок-в-работе-программы" id="aРеструктуризация-рефакторинг-refactoring-кода-для-улучшения-его-модульности-и-получение-возможности-отслеживания-возможных-ошибок-в-работе-программы"><h2>Реструктуризация (рефакторинг, refactoring) кода для улучшения его модульности и получение возможности отслеживания возможных ошибок в работе программы</h2></a>
<p>Наше текущее решение имеет 4 проблемы, которые мы будем устранять. Решать эти
задачи будем путём реструктуризации кода.</p>
<p>Во-первых, функция <code>main</code> на данный момент решает две задачи - анализирует переменные
командной строки и открывает файлы. Для нашей небольшой программы это не является
проблемой, но при увеличении функционала её будет всё труднее и труднее читать и
отлаживать. Наилучшим решением будет разделение функционала на несколько частей.</p>
<p>Вторая проблема - это переменные которые хранят данные командной строки. Наилучшим
решением было бы сгруппировать их в структуру.</p>
<p>Третья проблема - это отслеживание возможных ошибок. Метод <code>expect</code> сообщает одну
из возможных причин проблем при открытии файла, а их может быть намного больше.</p>
<p>Четвёртая проблема связана с распределенностью кода, отслеживающий ошибки и отсутствия
такового в тех местах, где потенциальная ошибка может быть. Необходима централизовано
отслеживать ошибки и корректно реагировать, сообщая пользователем достоверную информацию
о причинах ошибки.</p>
<p>Приступим к рефакторинг!</p>
<a class="header" href="print.html#aРекомендации-по-распределению-исходного-кода" id="aРекомендации-по-распределению-исходного-кода"><h3>Рекомендации по распределению исходного кода</h3></a>
<p>Накопленные сообществом Rust опыт позволил составить рекомендации по распределению
исходного кода в бинарных проектах. Рекомендации представляются в виде последовательности
шагов:</p>
<ul>
<li>Резделите код программы на два файла <em>main.rs</em> и <em>lib.rs</em>. Перенесите всю логику работы
программы в файл <em>lib.rs</em>.</li>
<li>Т.к. код необходимый для анализа переменных командной строки достаточно мал, его
можно оставть в функции <em>main.rs</em>.</li>
<li>Если же код анализа переменной командной строки усложняется - можно перенести его
в файл <em>lib.rs</em>.</li>
<li>Содержание функционала в <code>main</code> можно ограничить следующими задачами:
<ul>
<li>анализ переменных командной строки,</li>
<li>установка конфигурационных настроек приложения,</li>
<li>вызов функции <code>run</code> из файла<em>lib.rs</em>,</li>
<li>Если функция <code>run</code> возвращает ошибку - обработать данную ошибку.</li>
</ul>
</li>
</ul>
<p>Данные рекомендации - логичное типовое решения по разделению функционала:
в файле <em>main.rs</em> содержит код запуска программы, в файле <em>lib.rs</em> содержится
вся логика работы программы. Т.к. в силу конвенция проекта Cargo нельзя производить
тестирование функции <code>main</code>, весь код, который необходимо протестировать перенести
в библиотечные файлы исходного кода (в функцию <em>lib.rs</em> и модули (при необходимости)).
Код, который находится в функции <code>main</code> файла <em>main.rs</em> должен быть максимально компактным
и понятным, не требующей специального тестирования для проверки своей корректности.
Далее, мы реализуем рефакторинг, следуя этим рекомендациям.</p>
<a class="header" href="print.html#aГруппировка-функционала-анализа-переменных-командной-строки" id="aГруппировка-функционала-анализа-переменных-командной-строки"><h4>Группировка функционала анализа переменных командной строки</h4></a>
<p>Прежде всего, мы сгруппируем функционал анализа переменных командной строки и
будем хранить его в файле <em>src/lib.rs</em>. Код 12-5 Демонстрирует первое приближение
решение поставленной задачи. Код анализа функционала анализа переменных командной
строки перенесён в функцию <code>parse_config</code> внутри файла <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // ...snip...
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Код 12-5: Создание функции <code>parse_config</code> для чтения данных
из косоли в переменные (в кортеж) и её вызов в функции <code>main</code></span></p>
<p>Мы всё ещё храним данные из командной строке в векторе, наш код стал более осмысленным
(вместо неинформативного индекса массива мы уже используем переменную <code>query</code>,
название которой описывает содержание данных. Переменная <code>filename</code> также описывает
свое содержание. Функция <code>parse_config</code> получает на вход вектор, содержащий все
переменные командной строки. Функция <code>parse_config</code> содержит логику выборки данных
из вектора, сопоставляя ячейки вектора с переменными.</p>
<p>Эта функция кажется избыточное для нашей маленькой программки, но такова уж особенность
рефакторинга. Рефакторинг - это постепенное, многоэтапное улучшение структуры кода.</p>
<a class="header" href="print.html#aГруппировка-конфигурационных-переменных" id="aГруппировка-конфигурационных-переменных"><h4>Группировка конфигурационных переменных</h4></a>
<p>Далее, мы продолжим наши улучшения. На данные момент мы создали функцию возвращающую
кортеж, но далее он превращается в переменные.</p>
<p>Следующий индикатор улучшений для рефакторинга  - группа связанных переменных.
Было бы удобно использовать структуру для группировки.</p>
<blockquote>
<p>Обратите внимание: некоторые разработчики называют это решение (одержимостью
примитивными данными <em>primitive obsession</em>) - это анти-шаблон использования
примитивных значений, в то время как использование структур было бы более информативным
решением.</p>
</blockquote>
<p>Код (12-6) показывает код нашего очередного улучшения. Создаём структуру <code>Config</code>.
Внутри создаём поля <code>query</code> и <code>filename</code> соответственно. Мы также изменяем содержание
и тип выходных данные метода <code>parse_config</code>. Связи с этими изменениями места хранения
переменных, переписываем код обращения к данным этих переменных:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs::File;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // ...snip...
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Код 12-6: Рефакторинг функции <code>parse_config</code>. Теперь функция
возвращает экземпляр структуры <code>Config</code></span></p>
<p>Мы изменили описание функции <code>parse_config</code>. Теперь она возвращает экземпляр
структуры <code>Config</code>. Обратите внимание, что типы полей структуры - это экземпляры
<code>String</code>. Таким образом мы разорвали связь между входными данными и данными хранящимися
в экземпляре структуры <code>Config</code>. Такое решение оправдано правилами заимствования.
Чтобы их не нарушать - для экземпляра <code>Config</code> нужны свои контейнеры текстовых данных.</p>
<p>Операция клонирование считается не эффективной с точки зрения использования памяти.
В тоже время у неё есть ясные плюсы так как отсутствие необходимости следить за
временем жизни переменных. Клонирование также делает код более понятным для чтения.</p>
<blockquote>
<a class="header" href="print.html#aКомпромиссы-при-использовании-метода-clone" id="aКомпромиссы-при-использовании-метода-clone"><h3>Компромиссы при использовании метода <code>clone</code></h3></a>
<p>Существует тенденция в среде программистов Rust отказа от использования <code>clone</code>,
т.к. это понижает эффективность работы кода. В Главе 13, в той части которая посвящена
итераторам, вы изучите более эффективные методы, которые могут подойти в подобной
ситуации. Сейчас же использование метода удобно и оправдано <code>clone</code>.
Намного важнее иметь рабочую программу, пусть даже с немного неэффективна. program
Становясь всё более опытным программистом Rust вам будет всё проще и проще выбрать
наилучшее решение.</p>
</blockquote>
<p>Мы обновили код метода <code>main</code>. Мы добавили создание нового экземпляра структуры
<code>Config</code>, как возвращаемое значение функции <code>parse_config</code> в переменную <code>config</code>.
Теперь переменные <code>query</code> и <code>filename</code> являются полями структуры <code>Config</code> и имеют
тип данных <code>String</code>.</p>
<p>Мы реализовали логическое объединение переменных <code>query</code> и <code>filename</code>. Теперь
код стал более понятным и удобным в использовании.</p>
<a class="header" href="print.html#aСоздание-конструктора-для-структуры-config" id="aСоздание-конструктора-для-структуры-config"><h4>Создание конструктора для структуры <code>Config</code></h4></a>
<p>Мы провели рефакторинг кода, перенеся функционал считывания переменных в функцию
<code>parse_config</code> и реализовали группировку переменных в экземпляр структуры <code>Config</code>.
Главная задача функции этой функции стало создание экземпляра структуры <code>Config</code>.
Осозав это мы можем переименовать функцияю в <code>new</code> и связать её с создаваемой
структурой. Реализовав это мы сделаем ещё один шаг в сторону улучшения нашего кода.
Такой подход будет соответствовать принятым в стандартной библиотеки конвенциям
создания экземпляра структуры, такой как, например, <code>String</code>. С помощью функции
<code>String::new</code> создаётся новый экземпляр этой структуры. Реализовал этот рефакторинг
мы сможем вызвать переименованную написав <code>Config::new</code>.Код 12-7 демонстрирует, как
это можно сделать:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"> use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // ...snip...
}

 struct Config {
     query: String,
     filename: String,
 }

// ...snip...

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 12-7: Трансформация функции <code>parse_config</code> в функцию
структуры <code>Config::new</code></span></p>
<p>Мы изменили код в инициализации переменной <code>config</code>. Вместо функции <code>parse_config</code>
вызываем функция структуру <code>Config::new</code>. Обратите внимание на местонахождение функции
<code>new</code>. Она находится в блоке <code>impl</code>. Пожалуйста, проверьте, как работаёт новая версия
нашей программы!</p>
<a class="header" href="print.html#aПроблема-обработки-ошибок-и-пути-её-решения" id="aПроблема-обработки-ошибок-и-пути-её-решения"><h3>Проблема обработки ошибок и пути её решения</h3></a>
<p>Вы наверное обратили внимание, что пока корректность работы нашей программы очень
сильно зависит от количества введённых входных данных. Если сделать ошибку при вводе
данных (например, не ввести ничего или ввести недостаточно данных) программа
завершиться ошибкой:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', /stable-dist-rustc/build/src/libcollections/vec.rs:1307
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Хуже того, описание ошибки не будет понятно пользователю программы, не знающего
особенностей её реализации. Приступим к улучшению нашей программы в этой её части!</p>
<a class="header" href="print.html#aРеализация-корректного-сообщение-об-ошибке" id="aРеализация-корректного-сообщение-об-ошибке"><h4>Реализация корректного сообщение об ошибке</h4></a>
<p>В коде программы 12-8 мы добавим проверку входных данных в функцию <code>new</code>. Если
длинна среза меньше 3, произойдет генерация контролируемой ошибки с помощью макроса
<code>panic!</code>, который сообщит причину ошибки. Описание будет достаточно информативным
для пользователей программы:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// ...snip...
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // ...snip...
</code></pre>
<p><span class="caption">Код программы 12-8: Добавление проверки количества аргументов
входных даных программы</span></p>
<p>Это решение мы уже использовали в коде программы 9-8, где в функции <code>Guess::new</code>
производили проверку значения аргумента <code>value</code> и вызывали макрос <code>panic!</code>, если
он не соответствовал критериям проверки. В этом коде мы решили проверить длину
среза. Если это значение меньше 3, то условие проверки будет выполнено и ошибка
будет найдена, программа в этом месте остановит ход своего выполнения.</p>
<p>Пожалуйста, проверьте как срабатывает ошибка при вводе недостаточного количества
аргументов командной строки!</p>
<pre><code class="language-bash">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:29
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Такое сообщение об ошибке будет ясно для пользователя программы не знакомым с
исходным кодом. Всё же данное решение не совсем корректно, т.к. <code>panic!</code> лучше
применять по назначению - для обработки программных ошибок нежели ошибок ввода.
Лучшим решением было бы использование перечисления <code>Result</code>, которое мы изучали в
Главе 9 - возврат результата или ошибки и её описание.</p>
<a class="header" href="print.html#aЗамена-возвращаемого-типа-данных-функции-new-Использование-перечисления-result" id="aЗамена-возвращаемого-типа-данных-функции-new-Использование-перечисления-result"><h4>Замена возвращаемого типа данных функции <code>new</code>. Использование перечисления <code>Result</code></h4></a>
<p>Продолжим наши улучшения. Реализуем возврат значения перечисления <code>Result</code> в методе
<code>new</code>. Теперь при вызове из метода <code>main</code> функции <code>Config::new</code> мы может получить
различную информацию - результат успешной работы или описание ошибки. Имея эти данные
мы можем, например, преобразовать значение <code>Err</code> в удобное для использования в
логике нашей программы действие (без использования макроса <code>panic!</code>).</p>
<p>Код программы 12-9 показывает изменённый код:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Код 12-9: возврат значения перечисления<code>Result</code> из функции
<code>Config::new</code></span></p>
<p>Функция <code>new</code> теперь возвращает <code>Result</code> с экземпляром структуры <code>Config</code> при
корректном количестве входных данных или <code>Err</code> c <code>&amp;'static str</code>. Пожалуйста,
обратитесь ещё к информации в Главе 10, рассказывающей о статической переменной
времени жизни - таков тип строковых литералов. И этот тип данные будет находится,
как значение внутри <code>Err</code>.</p>
<p>Итак, мы сделали два изменения в коде функции <code>new</code>: вместо вызова макроса <code>panic!</code>
мы возвращаем значение <code>Err</code> и мы возвращаем <code>Config</code> внутри <code>Ok</code>. Все эти изменения
подготавливают нас к изменению типа данных выходного значения функции <code>new</code>.</p>
<p>Обратите внимание, что возвращение из функции описания ошибки <code>Err</code> даёт возможность
реализовать логику программы таким образом, чтобы не завершать работы всей программы.</p>
<a class="header" href="print.html#aВызов-функции-confignew-и-обработка-возвращаемых-значений" id="aВызов-функции-confignew-и-обработка-возвращаемых-значений"><h4>Вызов функции <code>Config::new</code> и обработка возвращаемых значений</h4></a>
<p>Для обработки возвращаемого значения обновлённой функции <code>new</code> в коде функции <code>main</code>
необходимо сделать изменения. Код программы 12-10 демонстрирует эти изменения.
Обратите внимание, что в мы реализовали завершение программы специальным образом,
для того чтобы передать процессу вызвавшей нашу программ, что произошла ошибка.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // ...snip...
</code></pre>
<p><span class="caption">Код программы 12-10: Завершение программы с кодом ошибки, если
при создании вызове функции <code>Config::new</code> произошла ошибка</span></p>
<p>Обратите, пожалуйста, внимание, что в этом коде программы мы использовали метод,
который мы ещё Вам не объясняли: <code>unwrap_or_else</code>, который определён в перечислении
<code>Result&lt;T, E&gt;</code> стандартной библиотеки. Использование <code>unwrap_or_else</code> позволяет
удобное решение обработки ошибки без использования макроса <code>panic!</code> (non-<code>panic!</code> error
handling). Если значение перечисления <code>Result</code> будет <code>Ok</code>, то этот метод ведёт себя
также как и <code>unwrap</code> - он возвращает внутреннее значение <code>Ok</code>. Если же значением
перечисления является <code>Err</code>, срабатывает код замыкания <em>closure</em>, которое является
анонимной функцией (мы поговорим об этом аспекте языка Rust в Главе 13). Сейчас
вам нужно знать, что внутреннее значение <code>Err</code> передаётся в аргумент <code>err</code>, который
расположен между вертикальными линиями. Анонимная функция может иметь доступ
к данной переменной она используется внутри блока.</p>
<p>Также обратите внимание, что мы импортировали модуль <code>process</code> из стандартной
библиотеки. Код внутри анонимной функции состоит из двух строк: печать на консоль
описания ошибки и вызов функции <code>process::exit</code>. Функция <code>process::exit</code> прекращает
работу программы и возвращает номер ошибки (в данном случае <code>1</code>). Это решение напоминает
вызов макроса <code>panic!</code>, но отличается от него возвращение значения кода ошибки.
Пожалуйста, проверьте работу программы после данного рефакторинга!</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Превосходно! Такая работа программы наиболее дружелюбна для пользователей и достаточно
информативна.</p>
<a class="header" href="print.html#aПродолжаем-рефакторинг-функции-main" id="aПродолжаем-рефакторинг-функции-main"><h3>Продолжаем рефакторинг функции <code>main</code></h3></a>
<p>После того, как мы реализовали обработку входных данных, преступим к улучшению
логики нашей программы. Целью нашего улучшения кода будет перенесение кода отвечающего
за логику работы нашей программы в функцию <code>run</code> (Как было описана в секции этой
главы &quot;Концепция разделения кода&quot;). После реализации данного рефакторинга функция
<code>main</code> станет проще для проверок корректности работы и у нас появится возможность
тестирования функционала нашей программы.</p>
<p>Код 12-11 демонстрирует перенос логики программы в функцию  <code>run</code>. Пока мы сделали
первое приближение к поставленной цели, т.к. код всё ещё сосредоточен в файле
<em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // ...snip...

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// ...snip...
</code></pre>
<p><span class="caption">Код программы 12-11: Перенос в функцию <code>run</code> логику программы</span></p>
<p>Теперь функция <code>run</code> содержит всю логику программы, начиная с чтения файла кончая
выводом результата. Обратите внимание, что функция 'run' имеет входной аргумент
экземпляр структуры <code>Config</code>.</p>
<a class="header" href="print.html#aРеакторинг-функции-run-Добавление-возвращаемого-значения" id="aРеакторинг-функции-run-Добавление-возвращаемого-значения"><h4>Реакторинг функции <code>run</code>. Добавление возвращаемого значения.</h4></a>
<p>Как мы уже знаем по опыты реализации функции <code>new</code>, весьма удобно, когда функция
возвращает информацию о своей работе и не запускает макрос <code>panic!</code>. Реализуем тот
же подход и в случае с функцией <code>run</code>, реализуем возврат значения перечисления
<code>Result&lt;T, E&gt;</code>. Это позволит реализовать в вызывающей функции подходящую обработку
выходных данных. Код улучшения 12-12 нашей функции <code>run</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// ...snip...

fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Код программы12-12: Внесения изменений в функцию <code>run</code>. Теперь
она возвращает значение перечисления  function to return <code>Result&lt;T, E&gt;</code></span></p>
<p>Обратите внимание, какие мы сделали изменения в функции. Перовое, мы описали
тип возвращаемого значения данной функцией - <code>Result&lt;(), Box&lt;Error&gt;&gt;</code>. Ранее
функция просто возвращала неявным образом пустой кортеж <code>()</code>. Сейчас же мы указали
это явно, а также описали формат сообщения об ошибке Box<Error>.</p>
<p>Для описания ошибки мы используем т.н. объект типажа (<em>trait object</em>) <code>Box&lt;Error&gt;</code>.
Для использования в коде типажа <code>std::error::Error</code> мы должны явным образом указать
это с помощью декларации <code>use</code>. Подробнее о объектах типажа (<em>trait objects</em>)
мы поговорим в Главе 17. Сейчас важно понять, что <code>Box&lt;Error&gt;</code> - это обозначение
того, что функция возвращает тип, который реализует типаж <code>Error</code>, но в тоже время
на нас не накладываются ограничения на выбор типа его значения. Это возможность даёт
нам право использовать разные типы данных в зависимости от типа ошибки.</p>
<p>Второе изменение, которое мы сделали - это удаление вызова метода <code>expect</code>. Вместо
него мы используем сокращение <code>?</code>, о котором мы говорили в Главе 9. Вместо вызова
макроса <code>panic!</code> при выявлении ошибки, выражение возвращает значение ошибки из той
функции, которую мы вызываем.</p>
<p>Третье изменение - это добавление возвращаемого значения - это значение <code>Ok</code> причисления
<code>Result</code>. В результате значение  <code>Ok</code> будет содержать в себе пустой кортеж <code>()</code>.
Данное решение ещё называют &quot;заглушкой&quot; - синтаксическая конструкция не несущая
в себе каких-либо данных - просто индикатор, соблюдающиеся необходимы конвенции.</p>
<p>Если вы запустите данный код на выполнение, то увидите предупреждающее сообщение:</p>
<pre><code class="language-text">warning: unused result which must be used, #[warn(unused_must_use)] on by
default
  --&gt; src/main.rs:39:5
   |
39 |     run(config);
   |     ^^^^^^^^^^^^
</code></pre>
<p>Данное сообщение говорить об игнорировании результатов работы функции. Такое поведение
трактуется как подозрительное, требующее к себе дополнительного внимания, предпосылка
к ошибке. Мы исправим наш код в следующем разделе на следующем этапе рефакторинга.</p>
<a class="header" href="print.html#aИсправление-замечания-компилятора" id="aИсправление-замечания-компилятора"><h4>Исправление замечания компилятора</h4></a>
<p>Мы решим эту задачу также, как и в случае функции <code>Config::new</code> (12-10), но с
небольшими отличиями:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // ...snip...

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>Мы используем синтаксическую конструкцию <code>if let</code> для проверки возвращаемого значения
функцией <code>run</code>. Т.к. <code>run</code> не возвращает информация для анализ (это может быть только
информации об ошибке) её та мы и будем анализировать.</p>
<p>Содержание блока кода <code>if let</code> такое же как и функции <code>unwrap_or_else</code>: печатаем
информацию об ошибке и заканчиваем работу.</p>
<a class="header" href="print.html#aРазеделение-кода-внутри-библиотечного-пакетаa-library-crate" id="aРазеделение-кода-внутри-библиотечного-пакетаa-library-crate"><h3>Разеделение кода внутри библиотечного пакета(a Library Crate)</h3></a>
<p>Продолжаем наш рефакторинг. Теперь приступим к переносу кода программы в файл
библиотеки нашего пакета (<em>src/lib.rs</em>). Далее будем тестировать наш код.</p>
<p>Итак, что мы переносим в файл <em>src/lib.rs</em>:</p>
<p>Let’s move everything that isn’t the <code>main</code> function from <em>src/main.rs</em> to a
new file, <em>src/lib.rs</em>:</p>
<ul>
<li>Определение функции <code>run</code>.</li>
<li>Необходимый импорт в строки <code>use</code>.</li>
<li>Определение структуры <code>Config</code>.</li>
<li>Определение функции <code>Config::new</code>.</li>
</ul>
<p>Содержание файла <em>src/lib.rs</em> должно иметь следующее содержание (12-13)
(для краткости некоторые строчки кода опущены):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // ...snip...
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // ...snip...
}
</code></pre>
<p><span class="caption">Код программы 12-13: Перемещение определения структуры <code>Config</code>
и функции <code>run</code> в файл <em>src/lib.rs</em></span></p>
<p>Мы добавили спецификатор доступа <code>pub</code> к структуре <code>Config</code>, а также её полям, к
методу <code>new</code> и функции <code>run</code>. Теперь у нас есть API, функционал которой мы сможем
протестировать.</p>
<p>Теперь нам нужно добавить строку <code>extern crate minigrep</code>. Далее мы добавляем
строку <code>use minigrep::Config</code> в область видимость и префикс к функции <code>run</code>. Код
программы 12-14:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // ...snip...
    if let Err(e) = minigrep::run(config) {
        // ...snip...
    }
}
</code></pre>
<p><span class="caption">Код программы 12-14: Подключение пакета <code>minigrep</code> в область
<em>src/main.rs</em></span></p>
<p>Запустим команду <code>cargo run test poem.txt</code> и проверим работу пакета.</p>
<p>Работает! Ура! Мы проделали большую работу. Такую программу легко отлаживать и
сделать код модульным.</p>
<p>Теперь можно приступать к тестированию созданного нами пакета.</p>
<a class="header" href="print.html#aРазработка-функционала-библиотеки-с-помощью-методологии-разработка-через-тестирование" id="aРазработка-функционала-библиотеки-с-помощью-методологии-разработка-через-тестирование"><h2>Разработка функционала библиотеки с помощью методологии &quot;разработка через тестирование&quot;</h2></a>
<p>Test Driven Development (TDD) - &quot;разработка через тестирование&quot;.</p>
<p>Теперь, когда мы перенесли логику работы программы в файл <em>src/lib.rs</em>, оставив
только получение аргументов командной строки и обработку ошибок в файле <em>src/main.rs</em>.
Далее, мы будем тестировать функционал нашего кода. Мы можем вызвать функции
непосредственно с различными аргументами и проверить возвращаемые значения без
вызова приложения из командной строки. Вы можете написать тесты для функции
<code>Config::new</code> и <code>run</code>.</p>
<p>В этой секции Главы 12 мы добавим функционал поиска в пакет <code>minigrep</code> с помощью
TDD. Эта методология имеет несколько шагов:</p>
<ul>
<li>Написать тест, которые не работает. Проверяем это.</li>
<li>Изменить тест, который будет работать. Проверяем это.</li>
<li>Изменяем код, который мы тестировали и проверяем, что он работает.</li>
<li>Повторим.</li>
</ul>
<p>Эта методология одни из возможных методик разработки программ. Отличительной особенностью
TDD является помощь в разработке структуры кода. Написание теста прежде написания
кода даёт возможность реализовать высокую степень покрытия тестами разрабатываемый
функционал. Т.е. помогает проверить возможные режимы её работы.</p>
<p>Мы хотим протестировать реализацию кода, который ищет по запросу текст в файле и
сообщает строки в которых был найден искомый текст. Код данного функционала будет
находится в функции <code>search</code>.</p>
<a class="header" href="print.html#aНаписание-теста-с-ошибкой" id="aНаписание-теста-с-ошибкой"><h3>Написание теста с ошибкой</h3></a>
<p>Первое, удалим макрос <code>println!</code> из файлов <em>src/lib.rs</em> иd <em>src/main.rs</em>. Далее,
добавим в модуль <code>test</code> с функции тестирования (так как мы это делали в Главе 11).
Тестовая функция определяет поведение, наподобие функции <code>search</code>: мы получаем
текст запроса и возвращаем только строки текста, где искомый текст был найден.
Код программы показывает реализацию описанного функционала (12-15)::</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программмы 12-15: Создание теста с ошибкой для функции
<code>search</code></span></p>
<p>В этом тесте мы ищем строку “duct” в строк состоящей из 3-х строк. Только в одной
из них есть текст “duct”. Мы проверяем возвращаемое значение функции <code>search</code> с
ожидаемой строкой.</p>
<p>Пока мы не можем запустить тест и посмотреть на этот ошибочный результат.
Этот код не будет скомпилирован, т.к. функции <code>search</code> ещё не существует.
Добавим определение функции <code>search</code>. Данная функция будет возвращать пустой
вектор (код 12-16). После наш код сможет быть скомпилирован и тест будет выдавать ошибку, т.к. пустой вектор не равен вектору с данными.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
</code></pre>
<p><span class="caption">Код программы 12-16: Реализация описания функции <code>search</code>,
добавления возвращаемого значения для достаточного для безошибочной компиляции
кода</span></p>
<p>Обратите внимание, что нам надо явно указать время жизни переменной <code>'a</code> <code>contents</code>
и возвращаемого значения <code>Vec&lt;&amp;'a str&gt;</code>. Напомним (Глава 10), что время жизни
переменных связывает один из входных параметров с выходным. В нашем случае мы
сообщаем компилятору, что срез текстовых данных переменной <code>contents</code> и данные вектора
выходных данных будут ссылаться на одни и туже строку.</p>
<p>Если вы попытаетесь скомпилировать код программ без использования переменных времени
жизни - вы получите сообщение об ошибке:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:47
  |
5 | fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                               ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Компилятор без указания этих данных не могут быть уверенным в отсутствии некоренных
ссылочных данных. Т.к. аргумент <code>contents</code> содержит текст и мы собираемся возвратить
часть данного текста мы можем установить связь между этим аргументом и выходными
данными.</p>
<p>Другие языки программирования не требуют организовать явную связь подобного рода.
Такое избыточное и подробное описание может показаться странным, но эта избыточность
оправдывается корректностью работы кода.</p>
<p>Проверим наш тест ещё раз:</p>
<pre><code class="language-text">$ cargo test
...warnings...
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
    thread 'test::one_result' panicked at 'assertion failed: `(left == right)`
(left: `[&quot;safe, fast, productive.&quot;]`, right: `[]`)', src/lib.rs:16
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

error: test failed
</code></pre>
<p>Отлично. Наш тест не сработал. Это мы и ожидали получить. Продолжим!</p>
<a class="header" href="print.html#aНаписание-кода-которые-поможет-тесту-добиться-искомого-результата" id="aНаписание-кода-которые-поможет-тесту-добиться-искомого-результата"><h3>Написание кода, которые поможет тесту добиться искомого результата</h3></a>
<p>Сейчас наш тест не срабатывает, т.к. мы всегда возвращаем пустой вектор. Для исправления
этой ошибки необходимо выполнить следующие действия:</p>
<ul>
<li>Проанализировать про всеем строкам текста на наличие нужного текста.</li>
<li>Если он есть, добавить структур в вектор.</li>
<li>Если нет, выбрать новую строку.</li>
<li>Возвратить результат.</li>
</ul>
<p>Проделаем эти действия поэтапно.</p>
<a class="header" href="print.html#aВыборка-строк-с-помощью-метода-lines" id="aВыборка-строк-с-помощью-метода-lines"><h4>Выборка строк с помощью метода <code>lines</code></h4></a>
<p>Стандартная библиотека предоставляет метод выборки строк одна за одной. Код  12-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
</code></pre>
<p><span class="caption">Код 12-17: Построчная выборка строк из <code>contents</code></span></p>
<p>Метод <code>lines</code> возвращает итератор. Мы поговорим об итераторах подробнее в Главе 13.
Мы уже встречались с итераторами в коде (3-6), где использовался цикл <code>for</code>.</p>
<a class="header" href="print.html#aПоиск-текста-в-каждой-строке" id="aПоиск-текста-в-каждой-строке"><h4>Поиск текста в каждой строке</h4></a>
<p>Далее. мы добавим функционал поиска необходимого текста в строке. Есть метод <code>contains</code>,
который делает всё работу. Добавим вызов этого метода (12-18):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">Код 12-18: Добавление функционала проверки наличия подстроки
в тексте</span></p>
<a class="header" href="print.html#aСохранение-найденной-строки" id="aСохранение-найденной-строки"><h4>Сохранение найденной строки</h4></a>
<p>Далее, нам нужно сохранить строку, если она соответствует условиям поиска.
Для этого сделаем наш вектор изменяемым и вызовем метод <code>push</code> для сохранения данных
в переменной <code>line</code> в вектор. После обработки всех строк функция вернёт заполненный
данными вектор. Код программы (12-19):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Код 12-19: Сохранение строк  в вектор</span></p>
<p>Теперь функция <code>search</code> может возвратить искомые данные и тест может быть пройден:</p>
<pre><code class="language-text">$ cargo test
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Отличная работа! Тест пройден.</p>
<p>Теперь мы можем приступить к рефакторингу кода. В нем мы пока не использовали
возможности итераторов. Мы вернёмся к этому коду в Главе 13 и внесём исправления.</p>
<a class="header" href="print.html#aИспользование-функции-search-в-функции-run" id="aИспользование-функции-search-в-функции-run"><h4>Использование функции <code>search</code> в функции <code>run</code></h4></a>
<p>Теперь мы можем использовать нашу функцию  в логической цепочки нашей программы.
Нам необходимо использовать поле <code>config.query</code> в качестве искомой подстроки и
текст, который функция <code>run</code> считывает из файла. Далее функция <code>run</code> печатает
каждую строку полученную в результате работы функции <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>Мы будем использовать цикл <code>for</code> для получения строк из результата работы функции
<code>search</code>.</p>
<p>Проверим работу программы после рефакторинга:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Отлично! Теперь введём другой текст, например, “the”:</p>
<pre><code class="language-text">$ cargo run the poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Then there’s a pair of us — don’t tell!
To tell your name the livelong day
</code></pre>
<p>Теперь проверим отсутствующего слова “monomorphization”:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Отлично! Мы реализовали сокращенную версию функции <code>grep</code> и научились структурировать
приложение. Мы также изучили о чтении данных из файла, повторили использование
переменных времени жизни, тестировали код и использовали команды cargo.</p>
<p>Далее мы рассмотрим, как можнго работать с переменными окружения системы и как
использовать поток ошибок.</p>
<a class="header" href="print.html#aРабота-с-системными-переменными" id="aРабота-с-системными-переменными"><h2>Работа с системными переменными</h2></a>
<p>Мы хотим улучшить наше приложение - добавить дополнительную функцию - установить
опцию для поиска текста без учёта регистра символов. Это опцию пользователь программы
может установить в своё системе с помощью переменных среды. Мы можем установить
опцию такую при запуске программы, что потребует от пользователя при каждом запуске
программы использовать данную опцию. Мы хотим упростить решение такой задачи.
Переменные среды позволяют установить какую-либо опцию один раз.</p>
<a class="header" href="print.html#aНаписание-теста-с-ошибкой-для-решения-задачи-поиск-без-учёта-регистра" id="aНаписание-теста-с-ошибкой-для-решения-задачи-поиск-без-учёта-регистра"><h3>Написание теста с ошибкой для решения задачи поиск без учёта регистра</h3></a>
<p>Добавим новую функцию <code>search_case_insensitive</code>, которую мы будем вызывать для того,
чтобы установить переменную среды.</p>
<p>Напишем тест с ошибкой. Добавим новый тест <code>case_insensitive</code> (12-20):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 12-20: добавление нового тест с ошибок для проверки поиск
без учёта регистра</span></p>
<p>Обратите внимание, что мы также поменяли входные параметры теста <code>case_sensitive</code>.
Мы добавили новую строку “Duct tape”, чтобы была возможность поиска строки “duct”
при установленной опции игнорирования регистра символов. Благодаря этому изменению
мы не нарушим ненароком работу предыдущего теста (он сработает при любом установленном
режиме поиска).</p>
<p>Новый тест будет использовать следующий шаблон для поиска - “rUsT”. В функции
<code>search_case_insensitive</code> функция поиска должна найти текст и в строке содержащей
“Rust:” и в “Trust me.”. Пока наш тест ещё не будет срабатывать, т.к. мы ещё не
реализовали функцию <code>search_case_insensitive</code>. Добавим описание функции так, как
мы это уже делали в функции <code>search</code> (без рабочей реализации, но с соблюдением
всех синтаксических формальностей.).</p>
<a class="header" href="print.html#aРеализация-функции-search_case_insensitive" id="aРеализация-функции-search_case_insensitive"><h3>Реализация функции <code>search_case_insensitive</code></h3></a>
<p>Функция <code>search_case_insensitive</code> показанная в примере кода 12-21 почти нечем не
отличается от функции <code>search</code>. Отличие в том, что производится принудительное
приведение значения переменной <code>line</code> и  в нижний регистр и аргумента <code>query</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
#}</code></pre></pre>
<p><span class="caption">Код программы 12-21: Определение функции <code>search_case_insensitive</code>
и реализация тела этой функции</span></p>
<p>Описание решения. Сначала получили значение аргумента <code>query</code> в нижнем регистре.
Для этого скроим аргумент с помощью одноимённой локальной переменный и используем
метод <code>to_lowercase</code>. Каждый раз при её использовании создаётся новый экземпляр
<code>String</code>. Метод <code>contains</code> требует предоставить срез в качестве входных данных.</p>
<p>Т.к. мы приводим сравниваемые значение в один регистр неважно в каком регистре они
были изначально.</p>
<p>Проверим работу тестов:</p>
<pre><code class="language-text">$ cargo test --lib

running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Отлично! Тесты срабатывают. Теперь мы можем использовать нашу новую функцию в <code>run</code>.
Сделаем рефакторинг кода. Добавим поле <code>case_sensitive: bool</code> в структуру <code>Config</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
#}</code></pre></pre>
<p>Дополнительное поле нужно для проверки в функции <code>run</code> для выбора какой функцией
воспользоваться для поиска: <code>case_sensitive</code> или <code>search_case_insensitive</code>. Пример
кода 12-22:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::error::Error;
# use std::fs::File;
# use std::io::prelude::*;
#
# fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
#      vec![]
# }
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt;{
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<p><span class="caption">Код программы 12-22: вызов функции в зависимости от значения
поля <code>config.case_sensitive</code></span></p>
<p>Следующим этапом нашего рефакторинга будет реализации проверки переменной среды в
функции <code>Config::new</code>.</p>
<p>Функции для работы с системными переменными находятся в модуле <code>env</code> стандартной
библиотеки. Добавим импорт данного модуля <code>use std::env;</code> в файле <em>src/lib.rs</em>.
Далее, мы можем использовать функцию <code>var</code> данного модуля для проверки значения
системной переменной <code>CASE_INSENSITIVE</code>. Пример кода 12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }

// ...snip...

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 12-23: проверка системной переменной <code>CASE_INSENSITIVE</code></span></p>
<p>Мы создаём новую переменную <code>case_sensitive</code>. Для установки значения этой переменной
мы получаем значение системной переменной <code>CASE_INSENSITIVE</code>. Функция <code>var</code> возвращает
перечисление <code>Result</code>.</p>
<p>Метод <code>is_err</code> используется для проверки наличия ошибочного значения. Если ошибки
нет, код продолжает свою работу. Нас пока интересует только наличие данной переменой
с списке системных переменных.</p>
<p>Далее значение переменной <code>case_sensitive</code> используется для инициализации экземпляра
структуры  <code>Config</code>.</p>
<p>Сначала проверим работу программы без системной переменной и шаблоном поиска &quot;to&quot;,
который должны подойти только точном совпадении символов:</p>
<pre><code class="language-text">$ cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Код работает. Далее установим системную переменную и попытаемся запустить программу
снова.
Looks like that still works! Now, let’s run the program with <code>CASE_INSENSITIVE</code>
set to 1 but with the same query “to”, and we should get lines that contain
“to” that might have uppercase letters:</p>
<pre><code class="language-text">$ set CASE_INSENSITIVE=1 &amp;&amp; cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Отлично! Теперь мы наши и больше &quot;to&quot;. Теперь вы знаете, как устанавливать системные
переменные с помощью командной строки и как и получать к ним доступ.</p>
<p>Некоторые программы допускают использование обоих решений для установки конфигурации
(установки параметров командной строки и отслеживание значений системных переменных).
В качестве самостоятельной работы, пожалуйста, проверьте работу программы с помощью
аргументов командной строки и системных переменных. Для удаления системной переменной
используйте команду:</p>
<pre><code class="language-text">$ set CASE_INSENSITIVE=

</code></pre>
<p>Модуль <code>std::env</code> содержит множество полезных функций для работы с системными
переменными. Подробнее о них вы можете узнать из документации.</p>
<a class="header" href="print.html#aВывод-сообщений-о-ошибках-в-стандартный-поток-для-ошибок-вместо-стандартного-потока" id="aВывод-сообщений-о-ошибках-в-стандартный-поток-для-ошибок-вместо-стандартного-потока"><h2>Вывод сообщений о ошибках в стандартный поток для ошибок вместо стандартного потока</h2></a>
<p>консольного приложения</p>
<p>Во всех предыдущих примерах книги вы выводили все сообщения в стандартный поток
терминала с помощью макроса <code>println!</code>. Обычно терминалы предоставляют два вида
вывода данных: <em>стандартный</em> для общений информации и <em>для ошибок</em>. Такая особенность
позволяет, например, писать настройки текущего состояния программы в файл, а сообщения
об ошибках на экран.</p>
<p>Для вывода сообщений в поток ошибок нам понадобиться специальный подход, которым
мы опишем далее.</p>
<a class="header" href="print.html#aПроверка-где-записываются-сообщения-об-ошибках" id="aПроверка-где-записываются-сообщения-об-ошибках"><h3>Проверка где записываются сообщения об ошибках</h3></a>
<p>Для начала рассмотрим как сообщения об ошибках выводятся в текущей версии программы.
Далее перенаправил поток вывода сообщений в файл. Удобным способом перенаправления
потока данных в консольном приложение является символ  <code>&gt;</code>. Перенаправим поток
вывода в файл <em>output.txt</em>. Проверим как это работает:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<p>Теперь посмотрим на содержание файла <em>output.txt</em>:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Мы видим, что сообщение об ошибке было напечатано в стандартный поток вывода.
Было бы более удобно, если бы сообщения об ошибках печатались бы в стандартный
поток ошибок. Чтобы только сообщения о успешном выполнении программы печатались в
стандартный поток.</p>
<a class="header" href="print.html#aПечать-ошибок-в-поток-ошибок" id="aПечать-ошибок-в-поток-ошибок"><h3>Печать ошибок в поток ошибок</h3></a>
<p>Рассмотрим способ перенаправления поток с помощью кода программы (12-24).
Так как после проведённого рефакторинга все сообщения сосредоточены в одной функции
<code>main</code> нам будет удобно сделать необходимые изменения. В стандартную библиотеку
входит макрос <code>eprintln!</code>, который печатает сообщения в поток ошибок. Пожалуйста,
познакомьтесь с обновлённым кодом функции <code>main</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Код 12-24: Вывод сообщений об ошибках в поток ошибок с помощью
макроса <code>eprintln!</code></span></p>
<p>Пожалуйста, проверьте работу обновлённой версии программы:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Вы также видите сообщения об ошибке на экране, но в файл <code>output.txt</code> информация
об ошибке не была записана.</p>
<p>Если же вы напишите всё правильно и программа выполниться без ошибок, файл будет
содержать найденный строки:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>Содержание файла <code>output.txt</code> после работы программы:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<a class="header" href="print.html#aИтоги-8" id="aИтоги-8"><h2>Итоги</h2></a>
<p>В этой главе вы использовали наши накопленный опыт и научились работать с файлами.
Мы создали работающее (правильность работы подтверждена модульными тестами)
консольное приложение, которое успешно работает с параметрами командной стоки,
системными переменными, файлами, использует макрос <code>eprintln!</code> для вывода ошибок.</p>
<p>Далее мы рассмотрим уже знакомые вам концепции языка Rust, о которых мы ранее уже
упоминали и использовали в некоторых демонстрационных примерах. Думаю, что у вас
уже есть о них общее представление. Пора углубить ваши знания. Итак, замыкания и
итераторы к вашим услугам!</p>
<a class="header" href="print.html#functional-language-features-in-rust-iterators-and-closures" id="functional-language-features-in-rust-iterators-and-closures"><h1>Functional Language features in Rust: Iterators and Closures</h1></a>
<!-- Are closures unique to Rust? -->
<!-- No, they're from functional languages, which is why they're discussed in
this chapter. Do you have a suggestion on how to make that clearer than the
text in the intro paragraph here? /Carol -->
<p>На язык Rust было оказано влияние многими языкам и технологии, особенно
<em>функциональное программирование</em>.</p>
<p>Программирование в функциональном стиле программирования используют функции, как
значения входных или выходных данных, присвоение переменным функций для последующего
использования и много чего ещё. Мы не будем обсуждать здесь вопрос о том, что,
такое функциональное программирование. Вместо этого мы покажем различные возможности
языка.</p>
<p>Более подробно мы будем говорить о:</p>
<ul>
<li><em>Замыканиях</em>: анонимные функции, ссылку на которые можно сохранять в переменных.</li>
<li><em>Итераторах</em>: способ обработки последовательности элементов.</li>
<li>Как с помощью этих языковых конструкций можно улучшить работы в операциях ввода/вывода (Глава 12)</li>
<li>Производительность этих конструкций. Они быстрее, чем вы думаете. :-)</li>
</ul>
<p>Ещё есть и другие возможности функционального программирования, которые реализованы
в Rust - шаблоны поиска (match), перечисления. Эти темы также будут освящаться в
это главе. Хорошо понять, уметь правильно применять замыкания и итераторы очень
важно при написании быстроработающего кода. Эту главу мы посвящаем рассмотрению
именно этих вопросов.</p>
<a class="header" href="print.html#aЗамыкания-анонимные-функции-которые-могут-имеют-доступ-к-своему-окружению" id="aЗамыкания-анонимные-функции-которые-могут-имеют-доступ-к-своему-окружению"><h2>Замыкания: анонимные функции, которые могут имеют доступ к своему окружению</h2></a>
<!-- Bill's suggested we flesh out some of these subtitles, which I think we
did more with earlier chapters but we (I, included!) have got a bit lax with. I
don't think this is quite right, is there a shorter heading we could use to
capture what a closure is/is for? -->
<!-- I've attempted a more descriptive subtitle, what do you think? /Carol -->
<p>Замыкания в Rust - это анонимные функции, ссылки на которые вы можете сохранять в
переменные или сделать их аргументами других функций. Вы можете создавать в одном
месте, а вызывать и их работы в другом контексте. В отличии от функций, замыканиям
дозволено иметь доступ к переменным той области видимости, в которой они используются.
Далее будут продемонстрировано, как эти опции помогают сократить количество используемого
кода в программе и улучшить её поведение.</p>
<!-- Can you say what sets closures apart from functions, explicitly, above? I
can't see it clearly enough to be confident, after one read through this
chapter. I think it would help to have the closure definition up front, to help
to let the reader know what they are looking out for in the examples. When
would you use a closure, for example, rather than using a function? And is it
the closure that's stored in the variable, or is it the result of applying the
closure to a value passed as an argument? -->
<!-- I've tried reworking the above paragraph and restructuring the examples to
be more motivating. I've also tried to make it clear throughout that storing a
closure is storing the *unevaluated* code, and then you call the closure in
order to get the result. /Carol -->
<a class="header" href="print.html#aСоздание-обобщенного-поведения-используя-замыкания" id="aСоздание-обобщенного-поведения-используя-замыкания"><h3>Создание обобщенного поведения используя замыкания</h3></a>
<p>Рассмотрим пример, демонстрирующий сохранение замыкания для дальнейшего использования.
Мы также рассмотрим синтаксис замыканий, типизированный интерфейс и типажи.</p>
<p>Представим, что мы работаем на в стартапе, где создаём приложение для генерации
планов тренировок. Серверная часть приложения создаётся на Rust. На сервере храниться
множество данных: возраст, индекс тела, предпочтения, последние результаты тренировок
и индекс интенсивности тренировок. При проектировании приложения конкретные алгоритмы
реализаций не важны. Важно, чтобы различные расчёты не занимали много времени.
Мы буде симулировать работу алгоритма расчета параметров с помощью функции
<code>simulated_expensive_calculation</code> (13-1), которая печатает <code>calculating slowly...</code>,
ждёт две секунды и выводит результат расчёта:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: i32) -&gt; i32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
#}</code></pre></pre>
<p><span class="caption">Код программы 13-1: Описания функции, которая моделирует
расчёт различных параметров</span></p>
<p>Далее рассмотрим содержание функции <code>main</code>, которое содержит части нашего приложения.
В примере моделируется вызов кода, который генерирует план занятий. Т.к. взаимодействие
с клиентской частью программы не связано с использованием замыканий, мы также
смоделируем это взаимодействие. Программно будут вводиться данные и печататься результаты.</p>
<p>Описание входных данных:</p>
<ul>
<li>Индекс интенсивности (<code>intensity</code>) - определяет когда запрашивается тренировка.
Этот индекс говорит о предпочтениях (низкая или высокая интенсивность)</li>
<li>Случайный номер, который будет сгенерирован для выбора плана тренировки</li>
</ul>
<p>В результате программа напечатает рекомендованный план занятий.</p>
<p>Код 13-2 показывает содержание функции <code>main</code>. Мы программно ввели вводимые пользователем
показатели для простоты демонстрации работы:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
# fn generate_workout(intensity: i32, random_number: i32) {}
</code></pre></pre>
<p><span class="caption">Код программы 13-2: Функция <code>main</code> содержащая симуляцию
пользовательского ввода данных и вызов функции <code>generate_workout</code></span></p>
<p>Это и есть контекст в котором мы будем работать. Функция <code>generate_workout</code> в
примере кода 13-3 содержит логику работу программы, которую мы будем изучать в
этом примере.</p>
<p>contains the business logic of the app that we’re most concerned
with in this example. Остальные изменения в коде будут сделаны в этой функции:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: i32) -&gt; i32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: i32, random_number: i32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            )
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 13-3: Печать плана тренировки зависит от введенных
данных и вызова функции <code>simulated_expensive_calculation</code> </span></p>
<p>Код 13-3 несколько раз вызывает функцию расчета.</p>
<!-- Will add wingdings in libreoffice /Carol -->
<p>Желаемое поведение функции <code>generate_workout</code> следующее: проверка хочет ли
пользователь низкой интенсивности тренировки (индекс меньше 25) или высокой (25 и более).
Невысокая интенсивность будет рекомендовать количество повторений и подходов на
основании сложного алгоритма, который мы моделируем функцией <code>simulated_expensive_calculation</code>.</p>
<p>Если же пользователь хочет высокую интенсивность тренировок - добавляется опция -
случайный образом выбираемое число. Если оно равно 3, то предлагается сделать перерыв.</p>
<p>Общая логика представлена. Теперь можно заняться рефакторингом кода. Для начала
устраним дублирование кода. Пример первого приближения 13-4:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: i32) -&gt; i32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     num
# }
#
fn generate_workout(intensity: i32, random_number: i32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            )
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Код программы 13-4: Перенос вызова функции
<code>simulated_expensive_calculation</code> в одно место перед блоком <code>if</code> и сохранение
результата в переменную <code>expensive_result</code></span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>Теперь  в любом случае данная функция вызывается. Это не хорошо, т.к. не весь код
метода использует результаты её работы. Для решения этой задачи замыкания подходят
лучше всего.</p>
<a class="header" href="print.html#aЗамыкания-сохраняю-код-который-может-быть-запущен-позднее" id="aЗамыкания-сохраняю-код-который-может-быть-запущен-позднее"><h3>Замыкания сохраняю код, который может быть запущен позднее</h3></a>
<p>Вместо того, чтобы всегда запускать функцию <code>simulated_expensive_calculation</code>
перед блоком <code>if</code>, мы может определить замыкание и сохранить его в переменную.
Пример 13-5:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
# expensive_closure(5);
#}</code></pre></pre>
<p><span class="caption">Код программы 13-5: Инициализация замыкания</span></p>
<!-- Can you elaborate on *how* to define the closure first? I've had a go here
based on what I can see but not sure it's correct. Are we saying that a closure
is function that assigned its result to a variable you can then use? -->
<!-- I've attempted to elaborate on defining a closure in the next few
paragraphs starting here, is this better? /Carol -->
<p>Определения замыкания мы начинаем с пары палочек (vertical pipes (<code>|</code>)). Внутри
этой конструкции мы определяем параметры замыкания. Такой синтаксис был выбран
под влиянием языков Ruby и Smalltalk. Замыкание имеет параметр <code>num</code>. Несколько
параметров разделяются запятыми <code>|param1, param2|</code>.</p>
<p>Далее идёт тело функции-замыкания. Фигурные скобки могут не использоваться, если
код функции состоит только из одной строчки кода. После закрытия фигурных скобок
необходим символ <code>;</code>. Обратите внимание, что после <code>num</code> нет <code>;</code>. Это означает, что
переменная будет возращена функцией.</p>
<p>Также обратите внимание, что <code>let</code>-переменная <code>expensive_closure</code>содержит
определение функции-замыкания, а не результат её работы.</p>
<p>Теперь, после определения замыкания мы можем изменить код в блоках <code>if</code>, вызывая
код замыкания по необходимости. Вызов функции-замыкания очень напоминает вызов
функции.</p>
<p>Вызов замыкания очень похож на вызов функции. Мы определяем имя переменной, которая
содержит определение замыкания и в скобках указываем аргументы, которые мы хотим
использовать для вызова. Пример 13-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
fn generate_workout(intensity: i32, random_number: i32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            )
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Пример 13-6: Вызов замыкания <code>expensive_closure</code></span></p>
<p>Мы решили задачу многократного использования (вызова) одного кода (т.е. кода
объявленного в одном месте). Но мы всё-таки не решили вопрос минимизации количества
вызываемого код (кэширования результата). Код по-прежнему может вызываться дважды.
Этот вопрос может решить локальная переменная, объявленная в блоке <code>if</code>.  Есть ещё
более лучшее решение, к которому мы вернемся чуть позже. А сейчас обсудим почему
у замыканий не может быть аннотаций типов и ещё кое-что о связях типажей и замыканий.</p>
<a class="header" href="print.html#aИнтерфейс-типа-замыкания-и-аннотация-closure-type-inference-and-annotation" id="aИнтерфейс-типа-замыкания-и-аннотация-closure-type-inference-and-annotation"><h3>Интерфейс типа замыкания и аннотация (Closure Type Inference and Annotation)</h3></a>
<p>Замыкания отличаются от функций определяемых с помощью ключевого слова <code>fn</code> в некоторых
аспектах. Замыкания не требуют аннотирования типов параметров или возвращаемого
значения как это могут делать функции <code>fn</code>.</p>
<!-- I've suggested moving this next paragraph up from below, I found this
section difficult to follow with this next paragraph -->
<p>Типизированные аннотации необходимы функциям т.к. они являются частью проявленного
интерфейса с пользователем. Определение этого интерфейса важно для уверенности в
том, что все использующие данную функцию принимают её входные и выходные данные
корректно. Замыкания же не используют явного интерфейса, хотя они сохраняются в
переменных и используются без имени и давая возможность запускать их на выполнение.</p>
<p>Кроме того, описание замыкания может быть более коротким и может быть использовано
только в узком контексте, а не в любом месте программы. Из-за ограничения контекстов,
Благодаря этого ограничению компилятор может правильно подбирать типы данных
параметров и возвращаемого типа.</p>
<!--Can you expand above on what you mean by "stored in bindings and called
directly"? Do you mean stored in a variable? I'm struggling to visualize how
closures are used, and what the important difference is between them and
functions. I think a clearer definition of what they are, what they do, and
what they're used for at the start of the closures section would help clear
this up -->
<!-- Yes, sorry, in Rust terminology "binding" is mostly synonymous to
"variable", but when we started working on the book we decided to be consistent
and more like what people are used to by referring to the concept as "variable"
throughout, but we missed this spot. /Carol -->
<p>Также как и при определении переменных, мы можем добавить описание типа данных
переменных замыкания и типа возвращаемого значения (для большей информативности).
Пример 13-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num: i32| -&gt; i32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
#}</code></pre></pre>
<p><span class="caption">Код 13-7: добавления описания типов данных замыкания</span></p>
<!-- Why might you want to, if you don't need to? In a particular situation? -->
<!-- I've added an explanation /Carol -->
<!-- Below -- Am I right in assuming the closures below are doing the same
thing as the functions? -->
<!-- Yes /Carol -->
<p>Синтаксическое сравнения описания замыкания и функции:</p>
<!-- Prod: can you align this as shown in the text? -->
<!-- I'm confused, does this note mean that production *won't* be aligning all
of our other code examples as shown in the text? That's concerning to me, we're
trying to illustrate idiomatic Rust style in all the code examples, so our
alignment is always intentional... /Carol -->
<pre><code class="language-rust ignore">fn  add_one_v1   (x: i32) -&gt; i32 { x + 1 }
let add_one_v2 = |x: i32| -&gt; i32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<!-- Can you point out where we're looking at here, where the important
differences lie? -->
<!-- The importance isn't the difference but the similarity... I've tried to
clarify /Carol -->
<!-- Will add wingdings and ghosting in libreoffice /Carol -->
<p>Проиллюстрированные описания замыканий развноценны.</p>
<!--Below--I'm not sure I'm following, is the i8 type being inferred? It seems
like we're annotating it. -->
<!-- The types in the function definitions are being inferred, but since Rust's
variable types for numbers defaults to `i32`, in order to illustrate our point
here we're forcing the type of the *variable* to be `i8` by annotating it in
the *variable* declaration. I've changed the example to hopefully be less
confusing and convey our point better. /Carol -->
<p>Определения замыканий будут иметь один конкретный тип данных для каждого из параметров
и выходных данных. Например (код 13-8) показывает определение замыкания и его
использование:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<p><span class="caption">Код 13-8: Попытка использовать замыкание с различными типами
данных</span></p>
<p>The compiler gives us this error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<!-- Will add wingdings in libreoffice /Carol -->
<p>После того, как вы в первый раз вызвали замыкание и использовали переменные типа
данных <code>String</code>, компилятор неявным образом подставит этот тип в замыкание. Этот
тип данных будет неизменным у замыкания на протяжении всего времени жизни.</p>
<a class="header" href="print.html#aИспользование-замыканий-совместно-с-обобщёнными-типами-дженериками-и-типажом-fn" id="aИспользование-замыканий-совместно-с-обобщёнными-типами-дженериками-и-типажом-fn"><h3>Использование замыканий совместно с обобщёнными типами (дженериками) и типажом <code>Fn</code></h3></a>
<p>Возвратимся к нашему приложению для генерации тренировочных программ. В коде 13-6
мы ещё используем неоднократно замыкание. Больше чем это на надо. Решение с кэшированием
данных вычислений в переменной увеличит и усложнит наш код.</p>
<p>Есть ещё одно решение. Мы можем создать структуру, которая будет хранить замыкание
и результат её работы. Структура выполнить код замыкания если только в этом будет
необходимость. Данная структура будет кэшировать результат работы замыкания,
благодаря чему в коде программы не будет необходимости в усложнении кода. Такое
шаблонное решение называется <em>запоминанием</em> (<em>memoization</em>) или <em>ленивой инициализацией</em>
(<em>lazy evaluation</em>).</p>
<p>Для того чтобы структура могла в качестве поля иметь замыкание, мы должны явным
образом указать его тип. Каждое замыкание имеет свой уникальный тип (даже если два
замыкания имеют одни и туже сигнатуру, их типы будут считаться различными). Для
установки типа данных замыкания в структуре, перечислении или функции мы должны
использовать обобщающие типы и определенные типажи.</p>
<!-- So Fn is a trait built into the language, is that right? I wasn't sure if
it was just a placeholder here -->
<!-- Fn is provided by the standard library; I've clarified here. /Carol -->
<p>Типаж <code>Fn</code> входит в состав стандартной библиотеки. Все замыкания реализуют один из
типажей: <code>Fn</code>, <code>FnMut</code> или <code>FnOnce</code>. Мы поговорим о различиях между ним в следующей
секции. В данном примере мы можем использовать типаж <code>Fn</code>.</p>
<p>Мы добавим типы в типаж <code>Fn</code> для описания типов параметров и возвращаемого значения,
которое замыкания должны иметь для того, чтобы соответствовать данному типажу. В данном
случае, наше замыкание имеет тип параметр <code>i32</code> и возвращает <code>i32</code>. Сигнатура типажа
имеет вид: <code>Fn(i32) -&gt; i32</code>.</p>
<p>Код 13-9 показывает определение структуры <code>Cacher</code> содержащей замыкание:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Cacher&lt;T&gt;
    where T: Fn(i32) -&gt; i32
{
    calculation: T,
    value: Option&lt;i32&gt;,
}
#}</code></pre></pre>
<p><span class="caption">Код 13-9: определение структуры <code>Cacher</code> содержащей замыкание
<code>calculation</code> и результат в <code>value</code></span></p>
<p>Структура <code>Cacher</code> имеет поле <code>calculation</code> типа <code>T</code>. Тип данных замыкания <code>T</code>
описывается сигнатурой типажа <code>Fn</code>. Любые замыкания, которые может содержать поле
<code>calculation</code> в экземпляре <code>Cacher</code> должно иметь один параметр типа <code>i32</code> и возвращать
<code>i32</code> (определено после <code>-&gt;</code>).</p>
<p>Поле <code>value</code> имеет тип <code>Option&lt;i32&gt;</code>. Перед выполнением замыкания <code>value</code> будет <code>None</code>.
Если код использует структуру <code>Cacher</code> хочет получить результат замыкания, мы
выполним замыкания и сохраним результат в значении перечисления <code>Some</code>. Если же код
программы запросит значение замыкания ещё раз будет возвращено значение из <code>Some</code>.</p>
<p>Описанная логика реализована в примере кода 13-10:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Cacher&lt;T&gt;
#     where T: Fn(i32) -&gt; i32
# {
#     calculation: T,
#     value: Option&lt;i32&gt;,
# }
#
impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(i32) -&gt; i32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: i32) -&gt; i32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
#}</code></pre></pre>
<!-- Liz: the `new` function is using the "struct init shorthand" by just
saying `calculation` instead of `calculation: calculation`, since the parameter
matches the struct field name. This was recently added to stable Rust and we've
added an introduction of it in Chapter 5. Just adding an explanation here for
you in case you read this chapter before the changes we've made to Chapter 5!
/Carol -->
<p><span class="caption">Код 13-10: Реализация структуры <code>Cacher</code>, метода <code>new</code> и
метода <code>value</code>, который управляет логикой кэширования</span></p>
<p>Поля структуры <code>Cacher</code> закрытые, т.к. мы хотим, чтобы экземпляр структуры управлял
содержание полей и не было возможности извне каким-либо образом на это влиять. Функция
<code>Cacher::new</code> получает обобщенный параметр <code>T</code>. Данная функция возвращает экземпляр
структуры <code>Cacher</code> содержащая замыкание в поле <code>calculation</code> и <code>None</code> в поле <code>value</code>.</p>
<p>Когда вызывающий код хочет получить результат работы замыкания, вместо того чтобы
вызывать замыкание непосредственно, он вызывает метод <code>value</code>. Этот метод проверяет
есть ли уже результат работы замыкания в поле <code>self.value</code> внутри значения перечисления
<code>Option::Some</code>. Если там есть значение, это значение возвращается вызывающему коду.
При этом замыкание больше не используется для получения результата.</p>
<p>Если же поле <code>self.value</code> имеет значение <code>None</code>, то вызывается замыкание из поля
<code>self.calculation</code> и результат работы записывается в поле <code>self.value</code> для будущего
использования и, далее, полученное значение также возвращается вызывающему коду.</p>
<p>Пример кода 13-11 демонстрирует использование структуры <code>Cacher</code> в функции
<code>generate_workout</code> из примера 13-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# struct Cacher&lt;T&gt;
#     where T: Fn(i32) -&gt; i32
# {
#     calculation: T,
#     value: Option&lt;i32&gt;,
# }
#
# impl&lt;T&gt; Cacher&lt;T&gt;
#     where T: Fn(i32) -&gt; i32
# {
#     fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
#
#     fn value(&amp;mut self, arg: i32) -&gt; i32 {
#         match self.value {
#             Some(v) =&gt; v,
#             None =&gt; {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             },
#         }
#     }
# }
#
fn generate_workout(intensity: i32, random_number: i32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            )
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 13-11: Использование экземпляра структуры <code>Cacher</code> в
функции <code>generate_workout</code> для реализации кэширования</span></p>
<!-- Will add ghosting and wingdings in libreoffice /Carol -->
<p>Вместо сохранения замыкания в переменную, мы создаём новый экземпляр структуры
<code>Cacher</code> для хранения замыкания. Далее, в каждом месте, где необходим результат
работы замыкания мы вызываем метод <code>value</code>. Мы может вызывать этот метод сколько
угодно или вообще не вызывать. При любом количестве вызовов функции <code>value</code> (один
раз или более) замыкание будет использовано только один раз. Пожалуйста, проверьте
работу кода с использованием функции <code>main</code>.</p>
<p>Хотя экземпляр структуры <code>Cacher</code> прекрасно справляется со своими обязанностями
и в функции <code>generate_workout</code> можно без каких-либо дополнительных затрат описать
логику работы, у текущей реализации <code>Cacher</code> есть всё же ограничения с контекстом
использования замыкания.</p>
<p>Первое ограничение - предполагается, что параметр <code>arg</code> всегда будет одинаковым.
Изменение этого условия приводит к ошибке:</p>
<pre><code class="language-rust ignore">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<p>Этот тест создаёт новый экземпляр <code>Cacher</code> с замыканием и возвращает значение.
Мы вызываем метод <code>value</code> с параметром <code>arg</code> со значением <code>1</code>, а потом с <code>2</code>.
Предполагаем, что когда мы введём значение <code>2</code>, то и должны получить это значение.</p>
<p>Тест не будет пройден:</p>
<pre><code class="language-text">thread 'call_with_different_arg_values' panicked at 'assertion failed:
`(left == right)` (left: `1`, right: `2`)', src/main.rs
</code></pre>
<p>Проблема в том, что при первом вызове <code>c.value</code> с аргументом 1 экземпляр <code>Cacher</code>
сохранит значение <code>Some(1)</code> в <code>self.value</code>. После этого, неважно какие будут входные
параметры. Функция всегда будет возвращать 1.</p>
<p>Решением будет использования хэш-таблицы вместо одного значения. Ключи будут значениями
входных данных <code>arg</code>, а значениями будут результаты работы замыкания. Вместо того,
чтобы изучения значений перечислений функция <code>value</code> должна произвести поиск в
хэш-таблице и возвратить значение, если оно там находится. При необходимости будет
вызван код замыкания и будут произведены соответствующие вычисления.</p>
<pre><code class="language-rust ignore">fn value(&amp;mut self, arg: i32) -&gt; i32 {
        match self.value.get(&amp;arg) {
            Some(&amp;v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value.insert(arg,v);
                v
            },
        }
}
</code></pre>
<p>Ещё одним ограничением является тип данных. На данным момент ими могут быть
только целочисленные значения типа <code>i32</code>. Мы бы хотели иметь возможность использовать
различные типы данных (срезы строки, <code>usize</code> и другие). Попытаемся решить этот
вопросы с использованием обобщенных параметров.</p>
<a class="header" href="print.html#aЗамыкания-могут-получать-доступ-переменным-области-видимости" id="aЗамыкания-могут-получать-доступ-переменным-области-видимости"><h3>Замыкания могут получать доступ переменным области видимости</h3></a>
<p>В рассматриваемом нами примере генератора учебных планов мы использовали замыкания
только как встроенные анонимные функции. Возможности же замыкание шире.</p>
<!-- To clarify, by enclosing scope, do you mean the scope that the closure is
inside? Can you expand on that?-->
<!-- Yes, I've tried here to clarify that it's the scope in which the closure
is defined /Carol -->
<p>Код 13-12 демонстрирует пример переменной замыкания <code>equal_to_x</code>, содержание которой
использует переменные в облсти видимости (переменная <code>x</code>):</p>
<!-- To clarify how we talk about a closure, does the closure include the
variable name, or are we referring to the closure as the functionality that is
on the right side of the = and so not including to variable name? I thought it
was the former, but it seems like the latter above. If it's the former, would
"an example of a closure with the variable `equal_to_x`" make more sense? -->
<!-- No, the closure does not include the variable name in which it's stored;
storing a closure in a variable is optional. It should always be the latter,
and I hope the reworking of the example used throughout the closure section
and making the wording consistent has cleared this confusion up by this point.
/Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
    println!(&quot;{}&quot;,equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Код 13-12: пример замыкания, которое использует внешнюю
переменную</span></p>
<p>В этом примере показано, что замыканию позволена использовать переменную <code>x</code>,
которая определена в той же области видимости, что и переменная <code>equal_to_x</code>.</p>
<!-- So *why* is this allowed with closures and not functions, what about
closures makes this safe? -->
<!-- It's not really about safety; capturing the environment is the defining
functionality a closure has. The reason functions *don't* capture their
environment is mostly around storage overhead; I've added an explanation of
that aspect. Can you elaborate on what led to the conclusion that allowing
captures with functions wouldn't be safe and what you mean by "safe" here?
/Carol -->
<p>Такой функциональной возможности функции не имеют:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ... }
closure form instead
 --&gt;
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<p>Рассмотрим внутреннюю организацию работы с внешними переменными у замыканий. Для
хранения данных о внешних переменных у замыканий предусмотрена хранилище (кэш).
Использование данной возможности накладывает дополнительную нагрузку на ресурсы
системы (память). Для большей безопасности и устойчивой работы системы было принято
решение отключить у функций такою возможность.</p>
<!-- Why didn't this work, is there a reason ingrained in the language? Or is
that not really relevant? -->
<!-- I've added an explanation /Carol -->
<p>Замыкания могут получить доступ к переменным среды выполнения несколькими (тремя)
способами (которые соответствуют возможностям функций при работе с своими аргументами):
владение, заимствование, изменяемое (нефиксированное) заимствование. Все эти возможности
описаны в типажах, которые замыкания могут следовать:</p>
<ul>
<li><code>FnOnce</code> получает значения из области видимости (<em>environment</em>). Для получения
доступа к переменным замыкание должно получить во владения используемые переменные.
Замыкание не может получить во владение одну и туже переменную несколько раз.</li>
<li><code>Fn</code> заимствует значения из среды (не изменяя при этом их значений).</li>
<li><code>FnMut</code> может изменять значения переменных.</li>
</ul>
<p>Когда мы создаём замыкание, компилятор делает выводы о целях использования переменных
среды на основании используемых значений. В примере 13-12 <code>equal_to_x</code> получает
доступ к  <code>x</code> (readonly), т.е. замыкания реализует <code>Fn</code>.</p>
<p>Для получения владения переменными используется ключевое слово <code>move</code> перед списком
параметров. Это удобно, когда замакание перемещается в другой поток. Мы рассмотрим
примеры использования <code>move</code> в Главе 16, когда будем рассматривать возможности Rust
для разработки многопоточных приложений. В примере 13-12 ключевое слово <code>move</code> добавлено
в определении замыкания и используется вектор вместо целочисленного значения.
Примитивные типы (как мы знаем) могут быть скопированы (а нам надо перемещать):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
    implement the `Copy` trait
</code></pre>
<p>Здесь переменная <code>x</code> перемещена в замыкание её определении. Поэтому в функции
<code>main</code> переменная <code>x</code> большое не может быть использована. Для устранения ошибки
компиляции, устраните эту ошибку (например, удалите строку 6).</p>
<p>В большинстве случаев типаж <code>Fn</code> будет использован. Компилятор сам вам сообщит,
когда лучшем решение было бы использовать <code>FnMut</code> или <code>FnOnce</code> (на основании использования
внешних переменных замыканием).</p>
<p>Иллюстрации использования замыканий в качестве параметров функции мы рассмотрим в
следующей секции, &quot;Итераторы&quot;.</p>
<a class="header" href="print.html#aОбработка-группы-элементов-с-помощью-итераторов" id="aОбработка-группы-элементов-с-помощью-итераторов"><h2>Обработка группы элементов с помощью итераторов</h2></a>
<!-- From reading on, it seems like an iterator is useless without the methods
we use it with --- I think this is an important point to make early, I did find
it difficult to know what an iterator actually was throughout, and how it
depends on these other methods. Can you add something to this effect? -->
<!-- Reiterating the need for a clear definition of an iterator here--it seems
like an item that's used in iteration rather than something that performs the
process of iteration itself, is that right? Like a counter passed from element
to element? Can we define this at the begin of the iterator section? -->
<!-- I've added an explanation along these lines, does this help? /Carol -->
<p>Шаблонное решение &quot;итератор&quot; позволяет вам работать с сгруппированными элементами
по отдельности. В задачу итератора входит последовательное получение доступа к элементам
и определения конца последовательности. При использовании итераторов вы не должны
нарушать (пересоздавать) логику работы этого шаблонного решения.</p>
<p>В Rust итераторы имею особенность - инициализация по запросу (т.е. <em>lazy</em>). Например,
в коде 13-13 создаётся итератор значений вектора <code>v1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
#}</code></pre></pre>
<p><span class="caption">Код 13-13: Создание итератора</span></p>
<p>После создания итератора, мы можем выбрать различные варианты его использования.
В примере 3-6 мы уже использовали итераторы для цикла <code>for</code>. Пример 13-14 подробно
явно показывает порядок работы с итераторов в цикле <code>for</code>. Итератор сохраняется в
переменной <code>v1_iter</code>, а далее цикл последовательно получает значения, которые печатаются
на консоль.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
#}</code></pre></pre>
<p><span class="caption">Код 13-14: использование итератора в цикле <code>for</code></span></p>
<p>В языках программирования, в которых не предоставляется подобное программное решение,
пишутся подобные решения. Производится перебор значений начиная с индекса 0, увеличивая
индекс на единицу и отслеживание текущего индекса и размера группы данных.
Всё это итераторы отслеживает без нашего участия. Итераторы позволяют использовать
логику своей работы при работе с любыми типами данных. Далее рассмотрим как это работает
на примерах.</p>
<a class="header" href="print.html#aТипаж-iterator-и-метод-next" id="aТипаж-iterator-и-метод-next"><h3>Типаж <code>Iterator</code> и метод <code>next</code></h3></a>
<p>Все итераторы реализуют типаж стандартной библиотеки <code>Iterator</code>. Так выглядит
его исходный код:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
#}</code></pre></pre>
<p>Обратите внимание на элементы синтаксиса, которые мы ещё не рассматривали.
<code>type Item</code> и <code>Self::Item</code>, которые определяют <em>ассоциированный тип</em> (<em>associated type</em>)
с этим типажом. Мы подробнее поговорим о них в Главе 19. Сейчас вам нужно знать,
что этот код требует от реализаций этого типажа определить тип <code>Item</code>. Этот тип
используется в методе <code>next</code>. Другими словами, тип <code>Item</code> будет являться типом
элемента, который возвращает итератор.</p>
<p>Метод <code>next</code> необходимо реализовать. Возвращаемое значение находится внутри <code>Some</code>.
Когда перебор элементов завершен, возвращается  <code>None</code>. Мы можем вызвать метод
<code>next</code> непосредственно. Пример 13-15:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Код 13-15: Вызов метода итератора <code>next</code></span></p>
<p>Обратите внимание на необходимость сделать переменную-итератор изменяемой (mut).
Вызовом метода <code>next</code> изменяет состояние итератора. Каждый вызов метода выдаёт следующее
значения последовательности.</p>
<a class="header" href="print.html#aМетоды-типажа-iterator" id="aМетоды-типажа-iterator"><h3>Методы типажа <code>Iterator</code></h3></a>
<!-- Can you explain what it is you mean by "consumes" an iterator here? It
doesn't look like we do in this section, I think that's important to lay that
out clearly -->
<!-- This next paragraph doesn't give much away to me I'm afraid, not being
clear what we mean by *consume* at this point. Is a consuming adaptor like a
catalyst? -->
<!-- I hope this section addresses these comments you had /Carol -->
<p>Типаж <code>Iterator</code> имеет несколько различных методов с реализацией по умолчанию.</p>
<!-- Is there somewhere they can learn about all the methods and what they do,
how to use them? This seems like a good sample example, and if we can broaden
it out that would be really helpful -->
<!-- I've moved this comment here since you made this comment on the last
version of this chapter right after a spot where we mentioned looking at the
standard library API documentation for the iterator trait, like we're now doing
in the above paragraph. That's where the reader should go to learn about
all the methods and what they do and how to use them. Can you elaborate on why
that wasn't clear in the previous version of the chapter? Is there a reason why
the standard library API documentation didn't sound like that place to go?
/Carol -->
<p>Методы, которые вызывают метод <code>next</code> называют пользователя итератора (<em>consuming adaptors</em>).
Пример такого потребителя является метод <code>sum</code>. Этот метод получат владение итератором
и перебирает элементы с помощью метода <code>next</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
#}</code></pre></pre>
<p><span class="caption">Код 13-16: Вызов метода <code>sum</code> для получения суммы всех
элементов вектора</span></p>
<p>Переменную <code>v1_iter</code> после вызова метода <code>sum</code> уже использовать нельзя.</p>
<a class="header" href="print.html#aМетоды-типажа-iterator-для-создания-других-итераторов" id="aМетоды-типажа-iterator-для-создания-других-итераторов"><h3>Методы типажа <code>Iterator</code> для создания других итераторов</h3></a>
<p>Другим типом методов в типаже <code>Iterator</code> являются методы создающие другие итераторы.
Эти методы называют адаптерами (<em>iterator adaptors</em>) и позволяют нам изменять
итераторы в различные типы итераторов. Мы можем использовать цепочки вызовов
таких адаптеров. Т.к. итераторы инициируются по запросу.
Пример использования метода <code>map</code>, который получает в качестве параметра замыкание.
Это замыкание вызывается для каждого элемента. Результатом работы функции будет
новый итератор и измененный вектор.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
#}</code></pre></pre>
<p><span class="caption">Код 13-17: Вызов итератора-адаптера <code>map</code> для создания
нового итератора</span></p>
<p>Предупреждение:</p>
<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and do
nothing unless consumed
 --&gt; src/main.rs:4:1
  |
4 | v1.iter().map(|x| x + 1);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Код программы 13-17 ничего не делает, пока не будет вызвано другим элементом цепочки
вызовов. Об этом сообщается компилятором при вызове этого кода: т.к. адаптеры итераторов
работают только при внешнем использовании.</p>
<p>Для того чтобы исправить код и последовать рекомендациям компилятора, будем использовать
метод <code>collect</code> (который мы кратко представили в Главе 12). Этот метод использует
итератор для группировки результатов работы предыдущего метода в вектор. В примере
кода 13-18 мы группируем результаты работы метода <code>map</code> в вектор, который содержит
все элементы первоначального вектора при этом значение каждого числового элементам
увеличено на 1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
#}</code></pre></pre>
<p><span class="caption">Код 13-18: вызов метода <code>map</code> для создания нового итератора,
далее вызов метода <code>collect</code> для создания и использования нового итератора, чтобы
создать новый вектор с данными</span></p>
<p>Т.к. <code>map</code> получает замыкание мы можем применить любую операцию над содержимым.
Это прекрасный пример того, как использование замыканий позволяет улучшить поведение
итераторов (упростить обработку данных).</p>
<!-- I'm not clear from this last sentence which part is iterating through each
element, iter or map? What is map actually doing?-->
<!--Ah, I'm afraid I completely failed to follow this. What is the second
iterator for? I'm still not clear on what map does, can you expand on this? It
seems crucial to using iterators. Map applies the iterator to each element,
which applies the closure?
<p>Also, to generalize this discussion a bit, would you ever use iter without map?
--&gt;</p>
<!-- I hope this new breakdown/rearranging has cleared up these comments you
had on the last version of this chapter about the difference between
iter and map. I hope the added examples where we've used iter without map have
cleared up the last question. /Carol -->
<a class="header" href="print.html#aИспользование-замыканий-для-получения-доступа-к-переменным-среды-при-работе-итераторов" id="aИспользование-замыканий-для-получения-доступа-к-переменным-среды-при-работе-итераторов"><h3>Использование замыканий для получения доступа к переменным среды при работе итераторов</h3></a>
<p>Продолжим расширение наших знаний об совместном использовании замыканий и итераторов.
Рассмотрим пример использования замыканий для получения доступа к переменным
внешней среды и использования адаптера итераторов <code>filter</code>. Этот метод получает в
качестве параметра замыкание, применяет замыкание к каждому элементу и возвращается
булево значение. Если в результае работы кода замыкание возвращается значение <code>false</code>,
то данный элемент игнорируется при создание нового итератора. Код 13-19 демонстрирует
использование <code>filter</code> и замыкания, которое получает доступ к переменной <code>shoe_size</code>
при обрадотки коллекции данных структур <code>Shoe</code> для того, чтобы выбрать только те,
которые подходят под определенный размер:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust test_harness">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: i32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: i32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
#}</code></pre></pre>
<p><span class="caption">Код 13-19: использование метода <code>filter</code>, замыкания и переменной
функции <code>shoe_size</code></span></p>
<!-- Will add wingdings in libreoffice /Carol -->
<p>Функция <code>shoes_in_my_size</code> получает во владение вектор структур данных и числовое
значение. Данная функция возвращает вектор содержащий только структуры подходящие
под определенные критерии (в данном случае описания обуви определенного размера).
В теле функции мы вызываем метод <code>into_iter</code> для создания итератора, который получит
владение вектором. Далее вызываем метод <code>filter</code>, который применит к каждому элементу
вектора замыкание. Данное замыкание возвращает логическое значение результат сравнения
поля структуры с аргументом функции. В результате, метод <code>collect</code> объединит полученные
данные в вектор, который будет возвращен функцией в качестве выходных данных.</p>
<p>Тест наглядно демонстрирует результат работы функции.</p>
<a class="header" href="print.html#aРеализация-типажа-iterator-для-создания-нового-итератора" id="aРеализация-типажа-iterator-для-создания-нового-итератора"><h3>Реализация типажа <code>Iterator</code> для создания нового итератора</h3></a>
<!-- So it seems like we are creating a program with an iterator inside, is
that right? I assumed the whole thing we were making was an iterator at first,
which lead to a few confusions, can you lay it out up front? -->
<!-- I'm not sure what you mean here, can you elaborate on what the distinction
is to you between "a program with an iterator inside" and "whole thing we were
making was an iterator"? I don't understand what you mean by these terms so I'm
not sure how to clear this up. /Carol -->
<p>Вы уже видели в примерах, как можно создать итератор вектора (с помощью вызовов
функций <code>iter</code>, <code>into_iter</code> или <code>iter_mut</code>). Мы также можем создать итераторы из
других типов коллекций стандартной библиотеки (например, <code>map</code>). Помимо этого мы
можем реализовать <code>Iterator</code> для обработки любых данных. Для этого необходимо
реализовать метод <code>next</code>. После этого мы можем использовать все методы типажа
<code>Iterator</code> (используя реализации самого типажа).</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Реализуемый нами итератор будет считать от одного до пяти. Для начала создадим
структуры для хранения значений. Далее напишем реализацию типажа <code>Iterator</code></p>
<p>В коде 13-20 определение структуры <code>Counter</code> и реализации функции <code>new</code> для
создания экземпляра структуры <code>Counter</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 13-20: определения структуры <code>Counter</code> и функции <code>new</code>,
которая создаёт экземпляр структуры <code>Counter</code> с инициализированным значением <code>0</code> поля
<code>count</code></span></p>
<!-- Could you add a filename here? I think that will help the reader keep
track of what they're working on. Can you also just sum up in a line what this
code has accomplished so far? I moved this down from above the code, if this
will do? -->
<!-- Done /Carol -->
<!-- Why define the new method, if it isn't necessary? Or is that what this
next line is telling us? -->
<!-- So does this code just initialize it with 0? Is that jat { count: 0 }
does?-->
<!-- I've rearranged to make this clearer /Carol -->
<p>Далее мы реализуем метод <code>next</code> (код 13-21):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 13-21: реализация типажа <code>Iterator</code> в структуре <code>Counter</code></span></p>
<!-- I will add wingdings in libreoffice /Carol -->
<p>Рассмотрим содержание кода реализации типажа подробнее. Мы установили тип <code>Item</code>
(тип выходных данных метода <code>next</code>) <code>u32</code>. Более подробно о ассоциированных типах
мы поговорим в Главе 19. Обратим теперь внимание на содержание реализации метода.
Мы хотим чтобы наш итератор добавлял единицу к текущему значению. Поэтому мы инициировали
поле <code>count</code> 0. Если значение этого поля меньше 6, функция <code>next</code> возвращает текущее
значение внутри <code>Some</code>. Если же это поле равно 6 или больше итератор вернёт <code>None</code>.</p>
<a class="header" href="print.html#aПример-использования-итератора-counter" id="aПример-использования-итератора-counter"><h4>Пример использования итератора <code>Counter</code></h4></a>
<p>После того как метод <code>next</code> реализован, т.е. соблюдены все ограничения типажа
<code>Iterator</code> - мы получили реализацию итератора. Код 13-22 демонстрирует проверку
работы нашей реализации:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Iterator for Counter {
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         self.count += 1;
#
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
#}</code></pre></pre>
<p><span class="caption">Код 13-22: тестирования реализации метода <code>next</code></span></p>
<p>В этом тесте создаётся экземпляр структуры <code>Counter</code> - переменная <code>counter</code>.
Далее вызывается метод <code>next</code> и проверяется его выходные данные. Как и предполагалось,
метод возвращает числа от 1 до 5, а при последующих вызовах возвращает <code>None</code>.</p>
<!-- So if I have this right, the first line creates a new Counter called
counter, and the rest of them merely call counter with next, store it in x, and
then print x? And we have to do that 5 times to get the 1-5 count? Phew, could
you wrap that up if indeed it is correct!) and sum up here? -->
<!-- I decided to change this into a test rather than printing out values, and
I added some summary text about what the test is doing. Is this clearer? /Carol
-->
<a class="header" href="print.html#aИспользование-других-методов-типажа-iterator" id="aИспользование-других-методов-типажа-iterator"><h4>Использование других методов типажа <code>Iterator</code></h4></a>
<p>Т.к. мы реализовали типаж <code>Iterator</code>, мы можем использовать все его доступные
методы.</p>
<!-- So we can't just use these methods anyway? It seems like we did earlier,
but here we have to use next first, before we cam access these methods? -->
<!-- No, we don't have to *use* `next` before we can use the other methods, we
have to *define* `next` before we can use the other methods. I hope the various
rewordings and reworkings have made this clearer by this point. /Carol -->
<!-- below: once you've done what, defined a default implementation? Only then
can you use other adapters, is that what we're saying? And I'm still not clear
on what an adapter does/means, as opposed to a method, or consumer, at this
point. -->
<!-- I hope this comment has been cleared up too /Carol -->
<p>Пример использования методов типажа, доступных её реализации (13-23):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Counter {
#     count: u32,
# }
#
# impl Counter {
#     fn new() -&gt; Counter {
#         Counter { count: 0 }
#     }
# }
#
# impl Iterator for Counter {
#     // Our iterator will produce u32s
#     type Item = u32;
#
#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
#         // increment our count. This is why we started at zero.
#         self.count += 1;
#
#         // check to see if we've finished counting or not.
#         if self.count &lt; 6 {
#             Some(self.count)
#         } else {
#             None
#         }
#     }
# }
#
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
#}</code></pre></pre>
<p><span class="caption">Listing 13-23: Использование множества методов типажа <code>Iterator</code>
</span></p>
<p>Вызов всех методов доступен, т.к. были соблюдены все формальные условия реализации
типажа <code>Iterator</code>.</p>
<a class="header" href="print.html#aУлучшение-нашего-проекта-работы-с-системой-ввода-вывода-io-project" id="aУлучшение-нашего-проекта-работы-с-системой-ввода-вывода-io-project"><h2>Улучшение нашего проекта работы с системой ввода вывода (I/O Project)</h2></a>
<p>Теперь, когда мы изучили возможности замыканий и итераторов мы можем улучшить
код проекта, который мы реализовывали в Главе 12. Мы сделаем код более кратким и
ясным. Мы улучшим код функций <code>Config::new</code> и <code>search</code>.</p>
<a class="header" href="print.html#aЗамена-функции-clone-с-помощью-итератора" id="aЗамена-функции-clone-с-помощью-итератора"><h3>Замена функции <code>clone</code> с помощью итератора</h3></a>
<p>В коде (12-6) мы, получив срез строк и создав экземпляр структуры <code>Config</code>, мы
клонировали значения, чтобы передать их в поля структуры. Продемонстрируем этот код::</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre>
<p><span class="caption">Код 13-24: вид реализации функции <code>Config::new</code> из Главы 12</span></p>
<!--Is this why we didn't want to use clone calls, they were inefficient, or
was it that stacking clone calls can become confusing/is bad practice? -->
<!-- Yep, it's for performance reasons /Carol -->
<p>К сожалению использование метода <code>clone</code> не является эффективным решением. Далее
мы покажем альтернативное решение.</p>
<p>Причина использования метода <code>clone</code> является необходимость получить возможность
полям экземпляра структуры владеть данными (в данном случае строковыми значениями).</p>
<p>Используя полученные знания об итераторах мы можем изменить содержание функции
<code>new</code>.</p>
<!-- use the iterator functionality to what? How will iterating allow us to do
the same thing, can you briefly lay that out? -->
<!-- It's mostly for clarity and using a good abstraction, I've tried fixing
/Carol -->
<p>Т.к.<code>Config::new</code> получает во владение итератор и не использует доступ по индексу.
Мы можем переместить знанчения <code>String</code> из итератора в <code>Config</code>.</p>
<!-- below: which file are we in, can you specify here? -->
<!-- done /Carol -->
<a class="header" href="print.html#aИспользование-итератора-возвращаемого-функцией-envargs" id="aИспользование-итератора-возвращаемого-функцией-envargs"><h4>Использование итератора возвращаемого функцией <code>env::args</code></h4></a>
<p>В файле <em>src/main.rs</em> проекта Главы 12 изменим содержание функции <code>main</code>:</p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // ...snip...
}
</code></pre>
<p>На код примера  13-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // ...snip...
}
</code></pre>
<p><span class="caption">Код 13-25: удаление переменной <code>args</code> и направление результата
вызова функции <code>env::args</code> непосредственно в функцию <code>Config::new</code></span></p>
<!-- I think, if we're going to be building this up bit by bit, it might be
worth adding listing numbers and file names to each, can you add those? Don't
worry about being accurate with the numbers, we can update them more easily
later -->
<!-- That's nice of you to offer, but since we're maintaining an online version
that we're keeping in sync with each round of edits, we need to keep the
listing numbers making sense as well. We'll just take care of them. /Carol -->
<p>Обратите внимание, что функция <code>env::args</code> возвращает итератор! Вместо того, чтобы
преобразовывать значения итератора в вектор и затем направлять его в функцию
<code>Config::new</code>, мы передаём владение итератором из функции <code>env::args</code> непосредственно
в <code>Config::new</code>.</p>
<p>Далее, нам необходимо внести изменения в функцию <code>Config::new</code> в файле <em>src/lib.rs</em>:</p>
<!-- can you give the filename here too? -->
<!-- done /Carol -->
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // ...snip...
</code></pre>
<p><span class="caption">Код 13-26: изменение описания функции <code>Config::new</code></span></p>
<p>Т.к. функция <code>env::args</code> возвращает итератор <code>std::env::Args</code>, мы используем его
для в описании входных данных.</p>
<a class="header" href="print.html#aИспользование-методов-типажа-iterator-вместо-индексов" id="aИспользование-методов-типажа-iterator-вместо-индексов"><h4>Использование методов типажа <code>Iterator</code> вместо индексов</h4></a>
<p>Далее мы вносим изменения в содержание функции <code>Config::new</code>. Т.к. <code>std::env::Args</code>
является итератором, т.е. реализует типаж <code>Iterator</code>, то он может использовать
все методы данного типажа:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::env;
#
# struct Config {
#     query: String,
#     filename: String,
#     case_sensitive: bool,
# }
#
impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query, filename, case_sensitive
        })
    }
}
#}</code></pre></pre>
<p><span class="caption">Код 13-27: Новое содержание функции <code>Config::new</code></span></p>
<!-- is this the *full* new lib.rs code? Worth noting for ghosting purposes -->
<!-- No, this is just the `Config::new` function, which I thought would be
clear by saying "Next, we'll fix the body of `Config::new`.", can you elaborate
on why that's not clear enough? I would expect programmers to be able to
understand where a function starts and ends. /Carol -->
<p>Обратите внимание, что первым элементом аргументов является имя программы, поэтому,
в данном случае, оно должно быть проигнорировано с помощью функции <code>next</code>. Следующий
вызов функции <code>next</code> вернет значение <code>query</code>, а последующий <code>filename</code>.</p>
<!-- Hm, if ? would not work anyway, I'm not clear on why we mention, why it's
a shame we cant use it on Option? -->
<!-- We've taken this out, it's something that a portion of the readers might
be wondering and something that Rust might let you do someday, but yeah, it's
probably just distracting to most people /Carol -->
<a class="header" href="print.html#aУпрощаем-код-с-помощью-итераторов-адаптеров-iterator-adaptors" id="aУпрощаем-код-с-помощью-итераторов-адаптеров-iterator-adaptors"><h3>Упрощаем код с помощью итераторов-адаптеров (Iterator Adaptors)</h3></a>
<p>Следующая функция, которую мы можем улучшиться в нашем проекте - это <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Код 13-28: реализация функции <code>search</code> в Главе 12</span></p>
<p>Мы можем сократить код этой функции благодаря использованию итераторов-адаптеров.
Также дополнительным плюсом этого решения станет удаление промежуточной переменной
<code>results</code>. Функциональный стиль программирования рекомендует минимизацию количества
изменяемых состояний. Это делает код устойчивым от ошибок. Удаление возможности
изменять вектор даст нам в будущем возможность реализовать параллельный поиск.
Код с изменениями 13-29 демонстрирует изменения:</p>
<!-- Remind us why we want to avoid the mutable results vector? -->
<!-- done /Carol -->
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<p><span class="caption">Код 13-29: использование методов итератора-адаптера</span></p>
<p>Напомним, что целью функции <code>search</code> является возвращение всех строк из текста
<code>contents</code>, в которой содержится <code>query</code>. Функция <code>filter</code> решает задачу поиска,
а <code>collect</code> формирование вектора. Код стал проще, не правда ли?! Пожалуйста,
самостоятельно реализуйте подобное улучшение в функции <code>search_case_insensitive</code>.</p>
<!-- what is that, here, only lines that contain a matching string? A bit more
context would help out, we probably can't rely on readers remembering all the
details I'm afraid -->
<!-- done /Carol -->
<p>При наличии выбора стиля программирования, какой же лучше выбрать (13-28 или 13-29)?
Большинство программистов Rust выбирают второй вариант. Хотя, конечно, новичку
может этот стиль показаться сложнее для понимания, но чем больше у Вас будет опыта
работы с итераторами-адапторами, тем легче будет их использовать. Вместо циклов и
промежуточных переменных лучше использовать итераторы-адаптеры.</p>
<p>Но действительно ли эти конструкции равнозначны. Это вызывает сомнение. Рассуждения
по поводу производительности мы продолжим в следующей секции этой главы.</p>
<a class="header" href="print.html#aСравнение-производительности-циклов-и-итераторов" id="aСравнение-производительности-циклов-и-итераторов"><h2>Сравнение производительности циклов и итераторов</h2></a>
<p>Для определения какую реализацию лучше всего использовать, нам необходимо знать
скорость работы каждой и этих реализаций функции <code>search</code> (использование цикла <code>for</code>
или итераторов).</p>
<p>Запустить тест производительности, введя текст книги &quot;Приключения Шерлока Хомса&quot;
А. Конан Дойля (“The Adventures of Sherlock Holmes” by Sir Arthur Conan Doyle)
в качетвое входных данных содержания и поищем количество определенного артикля
(“the”) в данном тексте. Получим следующий результ:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>Версия с использованием итераторов была немного быстрее. Мы не будем приводить код
проверочного теста производительности. Целью данной демонстрации показ работы
концепции нулевой цены за использование абстракций. Использование абстракций не
несёт каких-либо дополнительных расходов, это т.к.требуют каких-либо
дополнительных накладных расходов.</p>
<p>Зная об отсутствии дополнительных накладных расходов на итерации вы можете безбоязненно
использовать итераторы и замыкания. Это высокоуровневые конструкции языка делают
код более понятными без ущерба производительности.</p>
<a class="header" href="print.html#aИтоги-9" id="aИтоги-9"><h2>Итоги</h2></a>
<p>Замыкания и итераторы - это элементы функционального программирования реализованные
в языке Rust. Они предоставляют инструмент для простого и понятного описания рутинных
операций, скрывая код, где программисты потенциально могут сделать ошибки. Важно, что
использование абстрактный конструкций не влияет на производительность конечного
решения.</p>
<!-- Are we going to cover which other elements of rust are zero-cost
abstractions, somewhere? Might be good to cross ref or, if we've already
covered, give a brief list or a way to identify them -->
<!-- Zero-cost abstraction in Rust is more about a design philosophy and a goal
we keep in mind; ёall abstractions in Rust strive to be zero-cost abstractions,
and if they aren't, it's considered a bug. There will always be some bugs. I've
reworded a bit to not make it sound as much like something we could list.
/Carol -->
<p>Теперь, когда мы улучшили представление кода в нашем проекте, рассмотрим некоторые
опции, которые нам предоставляет <code>cargo</code> для публикации нашего кода в репозитории.</p>
<a class="header" href="print.html#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio"><h1>More about Cargo and Crates.io</h1></a>
<p>So far we’ve used only the most basic features of Cargo to build, run, and test
our code, but it can do a lot more. Here we’ll go over some of its other, more
advanced features to show you how to:</p>
<ul>
<li>Customize your build through release profiles</li>
<li>Publish libraries on crates.io</li>
<li>Organize larger projects with workspaces</li>
<li>Install binaries from crates.io</li>
<li>Extend Cargo with your own custom commands</li>
</ul>
<p>Cargo can do even more than what we can cover in this chapter too, so for a
full explanation, see <a href="http://doc.rust-lang.org/cargo/">its documentation</a>.</p>
<!--can you give a link to the documentation?-->
<!-- done /Carol -->
<a class="header" href="print.html#customizing-builds-with-release-profiles" id="customizing-builds-with-release-profiles"><h2>Customizing Builds with Release Profiles</h2></a>
<p>In Rust <em>release profiles</em> are pre-defined, and customizable, profiles with
different configurations, to allow the programmer more control over various
options for compiling your code. Each profile is configured independently of
the others.</p>
<!-- To be clear, are these release profiles pre-defined profiles that you use
for different things? Can you lay that out more explicitly, give a more
detailed definition? That seems super useful, but I'm not sure I'm following
what they actually are. -->
<!-- They are pre-defined, we've tried to clarify /Carol -->
<p>Cargo has four profiles defined with good default configurations for each use
case. Cargo uses the different profiles based on which command you’re running.
The commands correspond to the profiles as shown in Table 14-1:</p>
<!-- Hm, so these profiles aren't built-in, just supported? and used for what
for cargo build? How do you use a particular profile in a build, is it chosen
by default? Do you have to specify? -->
<!-- They are built in with defaults. We've tried to clarify by changing this
to a table and adding some more explanation, is this better? /Carol -->
<table><thead><tr><th> Command                 </th><th> Profile   </th></tr></thead><tbody>
<tr><td> <code>cargo build</code>           </td><td> <code>dev</code>     </td></tr>
<tr><td> <code>cargo build --release</code> </td><td> <code>release</code> </td></tr>
<tr><td> <code>cargo test</code>            </td><td> <code>test</code>    </td></tr>
<tr><td> <code>cargo doc</code>             </td><td> <code>doc</code>     </td></tr>
</tbody></table>
<p><span class="caption">Table 14-1: Which profile is used when you run different
Cargo commands</span></p>
<p>This may be familiar from the output of your builds, which shows the profile
used in the build:</p>
<!-- Above-is that what you meant here? -->
<!-- Yep! /Carol -->
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<p>The “dev” and “release” notifications here indicate that the compiler is
using different profiles.</p>
<!-- which profile is "debug" associated with? As you can probably tell, I'm
not confident in my interpretation here, I think we need more info -->
<!-- Sorry, this was an inconsistency in cargo that we actually noticed while
writing this section and has since been fixed, but then I think we missed
updating this spot. `debug` should be gone. /Carol -->
<a class="header" href="print.html#customizing-release-profiles" id="customizing-release-profiles"><h3>Customizing Release Profiles</h3></a>
<!-- Do we mean that the profiles are all already stored in Cargo.toml, or you
have to add the entire code to cargo.toml? It seems like the former from the
writing, but looking through toml files I've made the latter seems to be true.
If you have multiple profiles in the toml, how do you choose which one to use?
-->
<!-- We've tried to clarify below. Please let me know if this is still unclear,
I'm confused about how you're drawing your conclusions. /Carol -->
<p>Cargo has default settings for each of the profiles that apply when there
aren’t any <code>[profile.*]</code> sections in the project’s <em>Cargo.toml</em> file. By adding
<code>[profile.*]</code> sections for any profile we want to customize, we can choose to
override any subset of the default settings. For example, here are the default
values for the <code>opt-level</code> setting for the <code>dev</code> and <code>release</code> profiles:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>The <code>opt-level</code> setting controls how many optimizations Rust will apply to your
code, with a range of zero to three. Applying more optimizations makes
compilation take longer, so if you’re in development and compiling very often,
you’d want compiling to be fast at the expense of the resulting code running
slower. That’s why the default <code>opt-level</code> for <code>dev</code> is <code>0</code>. When you’re ready
to release, it’s better to spend more time compiling. You’ll only be compiling
in release mode once, and running the compiled program many times, so release
mode trades longer compile time for code that runs faster. That’s why the
default <code>opt-level</code> for the <code>release</code> profile is <code>3</code>.</p>
<p>We can choose to override any default setting by adding a different value for
them in <em>Cargo.toml</em>. If we wanted to use optimization level 1 in the
development profile, for example, we can add these two lines to our project’s
<em>Cargo.toml</em>:</p>
<!-- So do we choose which profile to use when? How do we do that? Or is that
determined automatically by Rust, and if so, how? I think we need to show that
somewhere around here -->
<!-- Which profile is used is determined by which command you're running, which
we tried to show above. I hope the table added above has clarified this, if
not, please suggest further wording above, but the reader should understand
which profile gets used when by this point and I don't think we should repeat
it again here. /Carol -->
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>This overrides the default setting of <code>0</code>. Now when we run <code>cargo build</code>, Cargo
will use the defaults for the <code>dev</code> profile plus our customization to
<code>opt-level</code>. Because we set <code>opt-level</code> to <code>1</code>, Cargo will apply more
optimizations than the default, but not as many as a release build.</p>
<p>For the full list of configuration options and defaults for each profile, see
<a href="http://doc.rust-lang.org/cargo/">Cargo’s documentation</a>.</p>
<a class="header" href="print.html#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio"><h2>Publishing a Crate to Crates.io</h2></a>
<p>We’ve used packages from crates.io as dependencies of our project, but you can
also share your code for other people to use by publishing your own packages.
Crates.io distributes the source code of your packages, so it primarily hosts
code that’s open source.</p>
<p>Rust and Cargo have features that help make your published package easier for
people to find and use. We’ll talk about some of those features, then cover how
to publish a package.</p>
<a class="header" href="print.html#making-useful-documentation-comments" id="making-useful-documentation-comments"><h3>Making Useful Documentation Comments</h3></a>
<p>Accurately documenting your packages will help other users know how and when to
use them, so it’s worth spending some time to write documentation. In Chapter
3, we discussed how to comment Rust code with <code>//</code>. Rust also has particular
kind of comment for documentation, known conveniently as <em>documentation
comments</em>, that will generate HTML documentation. The HTML displays the
contents of documentation comments for public API items, intended for
programmers interested in knowing how to <em>use</em> your crate, as opposed to how
your crate is <em>implemented</em>.</p>
<!-- Doc comments support markdown but don’t require markdown, is that right?
Just wanted to make that distinction -->
<!-- yes -->
<p>Documentation comments use <code>///</code> instead of <code>//</code> and support Markdown notation
for formatting the text if you’d like. You place documentation comments just
before the item they are documenting. Listing 14-2 shows documentation comments
for an <code>add_one</code> function in a crate named <code>my_crate</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, my_crate::add_one(5));
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">Listing 14-2: A documentation comment for a function</span></p>
<!-- At some point, a screenshot of how this is rendered in HTML could be really
useful here, what you do think? -->
<!-- Yup! /Carol -->
<p>Here, we give a description of what the <code>add_one</code> function does, then start a
section with the heading “Examples”, and code that demonstrates how to use the
<code>add_one</code> function. We can generate the HTML documentation from this
documentation comment by running <code>cargo doc</code>. This command runs the <code>rustdoc</code>
tool distributed with Rust and puts the generated HTML documentation in the
<em>target/doc</em> directory.</p>
<p>For convenience, running <code>cargo doc --open</code> will build the HTML for your
current crate’s documentation (as well as the documentation for all of your
crate’s dependencies) and open the result in a web browser. Navigate to the
<code>add_one</code> function and you’ll see how the text in the documentation comments
gets rendered, shown here in Figure 14-3:</p>
<p><img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-03.png" class="center" /></p>
<p><span class="caption">Figure 14-3: HTML documentation for the <code>add_one</code>
function</span></p>
<!--Above - I added this line to describe what we're doing, encourage good
practice, can you add/edit where necessary? These will generate as HTML when
the code is run, is that how it works? -->
<!-- Not when the code is run, when the programmer runs `cargo doc`. That
doesn't run the programmer's code, really, not in the way `cargo run` runs it
anyway. We've tried clarifying as well as adding a screenshot. /Carol -->
<a class="header" href="print.html#commonly-used-sections" id="commonly-used-sections"><h4>Commonly Used Sections</h4></a>
<p>We used the <code># Examples</code> markdown heading in Listing 14-2 to create a section
in the HTML with the title “Examples”. Some other sections that crate authors
commonly use in their documentation include:</p>
<ul>
<li>Panics: The scenarios in which this function could <code>panic!</code>. Callers of this
function who don’t want their programs to panic should make sure that they
don’t call this function in these situations.</li>
<li>Errors: If this function returns a <code>Result</code>, describing the kinds of errors
that might occur and what conditions might cause those errors to be returned
can be helpful to callers so that they can write code to handle the different
kinds of errors in different ways.</li>
<li>Safety: If this function uses <code>unsafe</code> code (which we will discuss in Chapter
19), there should be a section covering the invariants that this function
expects callers to uphold in order for the code in <code>unsafe</code> blocks to
function correctly.</li>
</ul>
<p>Most documentation comment sections don’t need all of these sections, but this
is a good list to check to remind you of the kinds of things that people
calling your code will be interested in knowing about.</p>
<a class="header" href="print.html#documentation-comments-as-tests" id="documentation-comments-as-tests"><h4>Documentation Comments as Tests</h4></a>
<p>Adding examples in code blocks in your documentation comments is a way to
clearly demonstrate how to use your library, but it has an additional bonus:
running <code>cargo test</code> will run the code examples in your documentation as tests!
Nothing is better than documentation with examples. Nothing is worse than
examples that don’t actually work because the code has changed since the
documentation has been written. Try running <code>cargo test</code> with the documentation
for the <code>add_one</code> function like in Listing 14-2; you should see a section in
the test results like this:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Now try changing either the function or the example so that the <code>assert_eq!</code> in
the example will panic. Run <code>cargo test</code> again, and you’ll see that the doc
tests catch that the example and the code are out of sync from one another!</p>
<a class="header" href="print.html#commenting-contained-items" id="commenting-contained-items"><h4>Commenting Contained Items</h4></a>
<!-- I'm not clear what this comment does that's different, what do you mean by
"comment containing items"? The lingo might just be going over my head here -->
<!-- we've tried to reword and we've changed the example, is this clearer?
/Carol -->
<p>There’s another style of doc comment, <code>//!</code>, that adds documentation to the
item that contains the comments, rather than adding documentation to the items
following the comments. These are typically used inside the crate root file
(<em>src/lib.rs</em>) or inside a module’s root (<em>mod.rs</em>) to document the crate or
the module as a whole.</p>
<p>For example, if we wanted to add documentation that described the purpose of
the <code>my_crate</code> crate that contains the <code>add_one</code> function, we can add
documentation comments that start with <code>//!</code> to the beginning of <em>src/lib.rs</em>
as shown in Listing 14-4:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// ...snip...
</code></pre>
<p><span class="caption">Listing 14-4: Documentation for the <code>my_crate</code> crate as a
whole</span></p>
<p>Notice there isn’t any code after the last line that begins with <code>//!</code>. Because
we started the comments with <code>//!</code> instead of <code>///</code>, we’re documenting the item
that contains this comment rather than an item that follows this comment. In
this case, the item that contains this comment is the <em>src/lib.rs</em> file, which
is the crate root. These comments describe the entire crate.</p>
<p>If we run <code>cargo doc --open</code>, we’ll see these comments displayed on the front
page of the documentation for <code>my_crate</code> above the list of public items in the
crate, as shown in Figure 14-5:</p>
<p><img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-05.png" class="center" /></p>
<p><span class="caption">Figure 14-5: Rendered documentation for <code>my_crate</code>
including the comment describing the crate as a whole</span></p>
<!-- I'm not sure what we're looking at here, that's different from just using
///, can you point it out, talk about it? -->
<!-- Does the screenshot help? /Carol -->
<p>Documentation comments within items are useful for describing crates and
modules especially. Use them to talk about the purpose of the container overall
to help users of your crate understand your organization.</p>
<a class="header" href="print.html#exporting-a-convenient-public-api-with-pub-use" id="exporting-a-convenient-public-api-with-pub-use"><h3>Exporting a Convenient Public API with <code>pub use</code></h3></a>
<p>In Chapter 7, we covered how to organize our code into modules with the <code>mod</code>
keyword, how to make items public with the <code>pub</code> keyword, and how to bring
items into a scope with the <code>use</code> keyword. The structure that makes sense to
you while you’re developing a crate may not be very convenient for your users,
however. You may wish to organize your structs in a hierarchy containing
multiple levels, but people that want to use a type you’ve defined deep in the
hierarchy might have trouble finding out that those types exist. They might
also be annoyed at having to type <code>use my_crate::some_module::another_module::UsefulType;</code> rather than <code>use my_crate::UsefulType;</code>.</p>
<!-- Can you outline why, briefly, here? Reading on, is it something like:
because some useful functions might be buried within modules that the user is
unaware of -->
<!-- Yes, that's pretty much it. We've clarified above. /Carol -->
<p>The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are, and might have trouble finding the pieces they want to use if the module
hierarchy is large.</p>
<p>The good news is that, if the structure <em>isn’t</em> convenient for others to use
from another library, you don’t have to rearrange your internal organization:
you can choose to re-export items to make a public structure that’s different
to your private structure, using <code>pub use</code>. Re-exporting takes a public item in
one location and makes it public in another location as if it was defined in
the other location instead.</p>
<!-- Can you give a quick definition of "re-export" here? -->
<!-- Yup! /Carol -->
<p>For example, say we made a library named <code>art</code> for modeling artistic concepts.
Within this library is a <code>kinds</code> module containing two enums named
<code>PrimaryColor</code> and <code>SecondaryColor</code> and a <code>utils</code> module containing a function
named <code>mix</code> as shown in Listing 14-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // ...snip...
#        SecondaryColor::Green
    }
}
</code></pre>
<p><span class="caption">Listing 14-6: An <code>art</code> library with items organized into
<code>kinds</code> and <code>utils</code> modules</span></p>
<p>The front page of the documentation for this crate generated by <code>cargo doc</code>
would look like Figure 14-7:</p>
<p><img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-07.png" class="center" /></p>
<p><span class="caption">Figure 14-7: Front page of the documentation for <code>art</code>
that lists the <code>kinds</code> and <code>utils</code> modules</span></p>
<p>Note that the <code>PrimaryColor</code> and <code>SecondaryColor</code> types aren’t listed on the
front page, nor is the <code>mix</code> function. We have to click on <code>kinds</code> and <code>utils</code>
in order to see them.</p>
<p>Another crate depending on this library would need <code>use</code> statements that import
the items from <code>art</code> including specifying the module structure that’s currently
defined. Listing 14-8 shows an example of a crate that uses the <code>PrimaryColor</code>
and <code>mix</code> items from the <code>art</code> crate:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">Listing 14-8: A crate using the <code>art</code> crate’s items with
its internal structure exported</span></p>
<!--Below -- just to clarify, the "users of this crate" refers to people using
the crate in 14-8 that `uses` art, is that right? I want to make sure I'm
following accurately! -->
<!-- No, it refers to the users of the `art` crate. I've tried to clarify
/Carol -->
<p>The author of the code in Listing 14-8 that uses the <code>art</code> crate had to figure
out that <code>PrimaryColor</code> is in the <code>kinds</code> module and <code>mix</code> is in the <code>utils</code>
module. The module structure of the <code>art</code> crate is more relevant to developers
working on the <code>art</code> crate than developers using the <code>art</code> crate. The internal
structure that organizes parts of the crate into the <code>kinds</code> module and the
<code>utils</code> module doesn’t add any useful information to someone trying to
understand how to use the <code>art</code> crate. The <code>art</code> crate’s module structure adds
confusion in having to figure out where to look and inconvenience in having to
specify the module names in the <code>use</code> statements.</p>
<p>To remove the internal organization from the public API, we can take the <code>art</code>
crate code from Listing 14-6 and add <code>pub use</code> statements to re-export the
items at the top level, as shown in Listing 14-9:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use kinds::PrimaryColor;
pub use kinds::SecondaryColor;
pub use utils::mix;

pub mod kinds {
    // ...snip...
}

pub mod utils {
    // ...snip...
}
</code></pre>
<p><span class="caption">Listing 14-9: Adding <code>pub use</code> statements to re-export
items</span></p>
<!-- Will add ghosting in libreoffice /Carol -->
<p>The API documentation generated with <code>cargo doc</code> for this crate will now list
and link re-exports on the front page as shown in Figure 14-10, which makes
these types easier to find.</p>
<p><img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-10.png" class="center" /></p>
<p><span class="caption">Figure 14-10: Front page of the documentation for <code>art</code>
that lists the re-exports</span></p>
<p>Users of the <code>art</code> crate can still see and choose to use the internal structure
as in Listing 14-8, or they can use the more convenient structure from Listing
14-9, as shown in Listing 14-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::PrimaryColor;
use art::mix;

fn main() {
    // ...snip...
}
</code></pre>
<p><span class="caption">Listing 14-11: A program using the re-exported items from
the <code>art</code> crate</span></p>
<!-- Will add ghosting in libreoffice /Carol -->
<p>In cases where there are many nested modules, re-exporting the types at the top
level with <code>pub use</code> can make a big difference in the experience of people who
use the crate.</p>
<p>Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing <code>pub use</code> gives you flexibility in how you structure your crate internally, and
decouples that internal structure with what you present to your users. Take a
look at some of the code of crates you’ve installed to see if their internal
structure differs from their public API.</p>
<a class="header" href="print.html#setting-up-a-cratesio-account" id="setting-up-a-cratesio-account"><h3>Setting up a Crates.io Account</h3></a>
<p>Before you can publish any crates, you need to create an account on crates.io
and get an API token. To do so, visit the home page at <em>https://crates.io</em> and
log in via a GitHub account---the GitHub account is a requirement for now, but
the site may support other ways of creating an account in the future. Once
you’re logged in, visit your account settings at <em>https://crates.io/me</em> and
retrieve your API key. Then run the <code>cargo login</code> command with your API key,
like this:</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in
<em>~/.cargo/credentials</em>. Note that this token is a <strong>secret</strong> and should not be
shared with anyone else. If it is shared with anyone for any reason, you should
revoke it and generate a new token on Crates.io.</p>
<a class="header" href="print.html#before-publishing-a-new-crate" id="before-publishing-a-new-crate"><h3>Before Publishing a New Crate</h3></a>
<p>Now you have an account, and let’s say you already have a crate you want to
publish. Before publishing, you’ll need to add some metadata to your crate by
adding it to the <code>[package]</code> section of the crate’s <em>Cargo.toml</em>.</p>
<!-- Is this right, everything here is relevant to cargo.toml?-->
<!-- Yep /Carol -->
<p>Your crate will first need a unique name. While you’re working on a crate
locally, you may name a crate whatever you’d like. However, crate names on
Crates.io are allocated on a first-come-first-serve basis. Once a crate name is
taken, no one else may publish a crate with that name. Search for the name
you’d like to use on the site to find out if it has been taken. If it hasn’t,
edit the name in <em>Cargo.toml</em> under <code>[package]</code> to have the name you want to
use for publishing like so:</p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Even if you’ve chosen a unique name, if you try to run <code>cargo publish</code> to
publish the crate at this point, you’ll get a warning and then an error:</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
...snip...
error: api errors: missing or empty metadata fields: description, license.
</code></pre>
<p>This is because we’re missing some crucial information: a description and
license are required so that people will know what your crate does and under
what terms they may use it. To rectify this error, we need to include this
information in <em>Cargo.toml</em>.</p>
<p>Make a description that’s just a sentence or two, as it will appear with your
crate in search results and on your crate’s page. For the <code>license</code> field, you
need to give a <em>license identifier value</em>. The Linux Foundation’s Software
Package Data Exchange (SPDX) at <em>http://spdx.org/licenses/</em> lists the
identifiers you can use for this value. For example, to specify that you’ve
licensed your crate using the MIT License, add the <code>MIT</code> identifier:</p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<!-- Can you give an example of what a license identifier value looks like? It
is a alphanumerical code? -->
<!-- Mostly, yeah. /Carol -->
<p>If you want to use a license that doesn’t appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, then use
<code>license-file</code> to specify the name of that file instead of using the <code>license</code>
key.</p>
<p>Guidance on which license is right for your project is out of scope for this
book. Many people in the Rust community choose to license their projects in the
same way as Rust itself, with a dual license of <code>MIT/Apache-2.0</code>---this
demonstrates that you can also specify multiple license identifiers separated
by a slash.</p>
<p>So, with a unique name, the version, and author details that <code>cargo new</code> added
when you created the crate, your description, and the license you chose added,
the <em>Cargo.toml</em> for a project that’s ready to publish might look like this:</p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT/Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="http://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describes other
metadata you can specify to ensure your crate can be discovered and used more
easily!</p>
<a class="header" href="print.html#publishing-to-cratesio" id="publishing-to-cratesio"><h3>Publishing to Crates.io</h3></a>
<p>Now that you’ve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, you’re ready to publish!
Publishing a crate uploads a specific version to crates.io for others to use.</p>
<p>Take care when publishing a crate, because a publish is <em>permanent</em>. The
version can never be overwritten, and the code cannot be deleted. One major
goal of Crates.io is to act as a permanent archive of code so that builds of
all projects that depend on crates from Crates.io will continue to work.
Allowing deletion of versions would make fulfilling that goal impossible.
However, there is no limit to the number of versions of a crate you can publish.</p>
<p>Let’s run the <code>cargo publish</code> command again. It should succeed now:</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Congratulations! You’ve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.</p>
<a class="header" href="print.html#publishing-a-new-version-of-an-existing-crate" id="publishing-a-new-version-of-an-existing-crate"><h3>Publishing a New Version of an Existing Crate</h3></a>
<p>When you’ve made changes to your crate and are ready to release a new version,
you change the <code>version</code> value specified in your <em>Cargo.toml</em> and republish.
Use the <a href="http://semver.org/">Semantic Versioning rules</a> to decide what an appropriate next
version number is based on the kinds of changes you’ve made. Then run <code>cargo publish</code> to upload the new version.</p>
<a class="header" href="print.html#removing-versions-from-cratesio-with-cargo-yank" id="removing-versions-from-cratesio-with-cargo-yank"><h3>Removing Versions from Crates.io with <code>cargo yank</code></h3></a>
<p>While you can’t remove previous versions of a crate, you can prevent any future
projects from adding them as a new dependency. This is useful when a version of
a crate ends up being broken for one reason or another. For situations such as
this, Cargo supports <em>yanking</em> a version of a crate.</p>
<p>Yanking a version prevents new projects from starting to depend on that
version while allowing all existing projects that depend on it to continue to
download and depend on that version. Essentially, a yank means that all
projects with a <em>Cargo.lock</em> will not break, while any future <em>Cargo.lock</em>
files generated will not use the yanked version.</p>
<p>To yank a version of a crate, run <code>cargo yank</code> and specify which version you
want to yank:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<p>You can also undo a yank, and allow projects to start depending on a version
again, by adding <code>--undo</code> to the command:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>A yank <em>does not</em> delete any code. The yank feature is not intended for
deleting accidentally uploaded secrets, for example. If that happens, you must
reset those secrets immediately.</p>
<a class="header" href="print.html#aРабочая-среда-cargo" id="aРабочая-среда-cargo"><h2>Рабочая среда Cargo</h2></a>
<p>В Главе 12 вы создавали проект, который включал в себе как бинарный, так
и библиотечный контейнеры. Возможно, вы заметили, что при увеличении проекта
вполне естественно разделение кода на логически связанные составные части. Для
упрощения работы над логически связанными контейнерами Cargo предоставляет инфраструктуру
называемую <em>рабочим пространством</em> (<em>workspaces</em>).</p>
<p><em>Рабочее пространство</em> является способом группировки пакетов, которые совместно
используют файл <em>Cargo.lock</em> и папку для хранения конечных программных продуктов
(будь то бинарные файлы или библиотеки). Далее бы будем создавать проект используя
возможности данного функционала. Это будет простой проект. В нём бы уделим внимание
организации рабочего пространства.
Итак, описание структуры. У нас есть бинарный проект, который использует библиотеки:
одна библиотека предоставляет функцию <code>add_one</code>, а другая предоставляет функцию
<code>add_two</code>. Эти три контейнера являются частью неявного рабочего пространства.
Реализуем эти связи явным образом! Первое, создадим новый бинарный контейнер <code>adder</code>:</p>
<pre><code class="language-text">$ cargo new --bin adder
     Created binary (application) `adder` project
$ cd adder
</code></pre>
<p>Добавим в файл описания секцию <code>[workspace]</code> для того, чтобы сообщить Cargo, пакет
является рабочим пространством:</p>
<pre><code class="language-toml">[workspace]
</code></pre>
<p>Как и многие другие опции Cargo, рабочее пространство поддерживает соглашения по
конфигурации. Поэтому для того, чтобы проект стал рабочим пространством на достаточно
просто добавить в файл конфигурации данную информацию.</p>
<!-- Below -- any crates what depends on, specifically? The program? -->
<!-- They're all programs. We mean the top-level crate in the workspace here,
I've tried to clarify. /Carol -->
<a class="header" href="print.html#aОпределение-взаимосвязей-в-рабочем-пространстве" id="aОпределение-взаимосвязей-в-рабочем-пространстве"><h3>Определение взаимосвязей в рабочем пространстве</h3></a>
<p>Все контейнеры в поддиректориях от которых зависит контейнер верхнего уровня являются
частью рабочего пространства. Любые контейнеры, независимо от их места хранения,
могут добавлять в зависимости от других контейнеров находящихся в локальных директориях
с помощью атрибута <code>path</code> в файле <em>Cargo.toml</em>. Если описание контейнера содержит
ключ <code>[workspace]</code> и имеет описания зависимостей, где пути к зависящим контейнерам
являются поддиректориями, все эти контейнеры являются частью <em>рабочего пространства</em>.
Давайте определим в файле <em>Cargo.toml</em> контейнера <code>adder</code>, что он имеет зависимость
от контейнера <code>add-one</code>, которых расположен в поддиректории:</p>
<!-- Above, what is the path dependency actually doing here, can you fill out
the paragraph above? -->
<!-- done /Carol -->
<pre><code class="language-toml">[dependencies]
add-one = { path = &quot;add-one&quot; }
</code></pre>
<p>Если же мы добавим описание зависимости в файл <em>Cargo.toml</em>, которое не будет
содержать <code>path</code>, такая зависимость будет считаться внешней зависимостью, данные о
которой будут запрашиваться из репозитория Crates.io.</p>
<a class="header" href="print.html#aДобавление-второго-контейнера-в-рабочую-среду" id="aДобавление-второго-контейнера-в-рабочую-среду"><h3>Добавление второго контейнера в рабочую среду</h3></a>
<!-- You can see I'm adding headings, here, trying to add some more navigable
structure -- can you improve these? I'm not sure mine are accurate -->
<!-- Yep! /Carol -->
<p>Далее, после того как мы описали путь к контейнеру, мы создадим его с помощью
команды:</p>
<pre><code class="language-text">$ cargo new add-one
     Created library `add-one` project
</code></pre>
<p>Файловая структура папки <code>adder</code> теперь будет иметь следующий вид:</p>
<pre><code class="language-text">├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
└── src
    └── main.rs
</code></pre>
<p>В код библиотеки <em>add-one/src/lib.rs</em> добавим описание функции <code>add_one</code>:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<!-- below -- Where are we adding the extern crate line? -->
<!-- at the top, where all the extern crate lines go and as illustrated by the listing /Carol -->
<p>Далее, откроем файл <em>src/main.rs</em> контейнера <code>adder</code> и добавим строку кода <code>extern crate</code>
в верхней строчке файла исходного кода для того, чтобы добавить возможность использовать
функционал контейнера <code>add-one</code> в исходном коде. Далее, изменим код функции <code>main</code>.
Будем использовать функцию импортированного контейнера (14-12):</p>
<pre><code class="language-rust ignore">extern crate add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<p><span class="caption">код 14-12: использование функционала библиотечного контейнера
<code>add-one</code> в исходном коде контейнера <code>adder</code></span></p>
<p>Создадим объектный код контейнера <code>adder</code> с помощью команды <code>cargo build</code> внутри
папки <em>adder</em>.</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/adder/add-one)
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<p>С помощью данной команды мы создали объектный код контейнеров <code>adder</code> и <code>add-one</code>.
Теперь структура каталога <code>adder</code> выглядит следующим образом:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── src
│   └── main.rs
└── target
</code></pre>
<p>Рабочее пространство имеет одну директорию для хранения объектных файлов (<em>target</em>
directory). Обратите внимание, что контейнер <em>add-one</em> не имеет своей собственной
директории для хранения объектных файлов (<em>target</em> directory). Даже если вы перейдёте
в папку <em>adder/add-one/target</em> и запустим команду <code>cargo build</code>, то данный пакет
будем всё равно скомпилирован в директорию <em>adder/target</em>. Контейнеры в рабочем
пространстве могут быть связаны между собой. Если, по какой-то причине, подчиненному
контейнеру необходимо иметь свою директорию для хранения объектных файлов, каждый
то контейнеры, которые зависят от него также будут перекомпилированы. Это источник
ошибок и множества проблем. Поэтому для упрощения в рабочем пространстве есть только
одна одна директория для хранения объектных файлов.</p>
<!-- Above -- I have no idea what this means for our project here, can you put
it in more practical terms, or otherwise maybe just explain what this means for
the user? -->
<!-- I added more explanation for the target directory in this section and
added more explanation for the Cargo.lock in the next section, since the
Cargo.lock advantages aren't as visible until you start adding dependencies on
external crates. What do you think? /Carol -->
<a class="header" href="print.html#aЗависимость-от-внешних-контейнеров-в-рабочей-среде" id="aЗависимость-от-внешних-контейнеров-в-рабочей-среде"><h4>Зависимость от внешних контейнеров в рабочей среде</h4></a>
<p>Обратите внимание, что рабочая в рабочей среде есть только один файл <em>Cargo.lock</em>
на все имеющиеся контейнеры. В данном примере мы предполагаем, что все контейнеры
используют одни и те же зависимости, которые описаны в файле <em>Cargo.toml</em>. Также
такой способ обеспечивает совместимость всем зависимых контейнеров.</p>
<p>Добавим зависимость <code>rand</code> в секцию <code>[dependencies]</code> файла <em>add-one/Cargo.toml</em>::</p>
<p><span class="filename">Filename: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>Далее, мы добавим код <code>extern crate rand;</code> в файл <em>add-one/src/lib.rs</em> и соберем
объектные файлы с помощью команды <code>cargo build</code> в директории <em>adder</em>. Обратите
внимание, что в этой директории будет скомпилирован контейнер <code>rand</code>:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   ...snip...
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/adder/add-one)
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<p>Файл <em>Cargo.lock</em> теперь содержит информацию о зависимости контейнера <code>add-one</code>
от <code>rand</code>. Хотя <code>rand</code> используется рабочем пространстве, вы не можете его
использовать без явного указания на него в зависимостях контейнера. Например,
если вы добавите строку кода <code>extern crate rand;</code> в файл исходного кода контейнера
<code>adder</code>, то код перестанет компилироваться:</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/adder)
error[E0463]: can't find crate for `rand`
 --&gt; src/main.rs:1:1
  |
1 | extern crate rand;
  | ^^^^^^^^^^^^^^^^^^^ can't find crate
</code></pre>
<p>Для исправления этой ошибки добавте ссылку на него в файл <em>Cargo.toml</em>. После
запустите команду <code>cargo build</code> ещё раз. Описание зависимостей изменится в файле
<em>Cargo.lock</em>, но дополнительных копий контейнера <code>rand</code> не будет скачано. Использование
одной и той же копии зависимости внутри рабочего пространства экономит и упрощает
хранение контейнеров-зависимостей.</p>
<a class="header" href="print.html#aДобавление-теста-в-рабочее-пространство" id="aДобавление-теста-в-рабочее-пространство"><h4>Добавление теста в рабочее пространство</h4></a>
<p>В целях дальнейших улучшений нашего проекта, добавим тест функции <code>add_one::add_one</code>
в контейнере <code>add_one</code>:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
#}</code></pre></pre>
<p>Выполните команду <code>cargo test</code> в рабочем пространстве <em>adder</em>:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/adder-f0253159197f7841

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Как же так? Нет тестов? Но у нас же есть один? Обратите внимание, что тесты были
выполнены только дня проекта модуля рабочего пространства. Для того, чтобы выполнить
все тесты используйте опцию (флаг) <code>--all</code>:</p>
<pre><code class="language-text">$ cargo test --all
    Finished dev [unoptimized + debuginfo] target(s) in 0.37 secs
     Running target/debug/deps/add_one-abcabcabc

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-abcabcabc

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Для того, чтобы запустить тесты определённого контейнера необходимо использовать
флаг <code>-p</code> и имя контейнера:</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Этот вывод информации сообщил только о тестах в контейнере <code>add-one</code>.</p>
<p>Если вы захотите публиковать контейнеры из данной рабочей среды на сайте crates.io,
каждый контейнер будет публиковаться отдельно. Команда <code>cargo publish</code> не имеет
уточняющих флагов, поэтому должна использоваться только в том контейнере, который
нужно опубликовать.</p>
<!-- What does that mean, we have to publish them all one at a time?-->
<!-- Yep, we've tried to clarify /Carol -->
<p>Сейчас создаёте ещё один контейнер в рабочей среде - <code>add-two</code>.</p>
<p>Использование рабочей среды упрощает разработку многокомпонентных контейнеров.</p>
<a class="header" href="print.html#aУстановка-бинарных-контейнеров-из-cratesio-cargo-install" id="aУстановка-бинарных-контейнеров-из-cratesio-cargo-install"><h2>Установка бинарных контейнеров из Crates.io <code>cargo install</code></h2></a>
<p>Команда <code>cargo install</code> позволяет устанавливать и использовать бинарные контейнеры
локально. Это, конечно, же не заменяет систему пакетов. Это реализовано для удобства
разработчиков. Только те пакеты, которые имеют в своём составе файл <em>src/main.rs</em>
или другие файлы, определенные в конфигурации, как бинарные. Обычно информацию о
содержании контейнер (это библиотека или бинарный файл или оба вместе) находится
в файле <em>README</em>.</p>
<!-- What is a binary target, and how do you know if a package has one? -->
<!-- Added /Carol -->
<p>После использования команды <code>cargo install</code> бинарный файл помещается в папку <em>bin</em>.
Если вы установили Rust используя файл <em>rustup.rs</em> и не делали никаких дополнительных
настроек, то все бинарные файлы Rust будут находится в папке <code>$HOME/.cargo/bin</code>.
Т.к. ссылка на эту папку находится в системной переменой <code>$PATH</code>, то все инсталлированные
программы также могут быть использованы.</p>
<p>Например, упомянутая в Главе 12 программа (реализация <code>grep</code>) <code>ripgrep</code> может быть
использована:</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 ...snip...
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<p>Последняя строка вывода сообщает путь к месту установки бинарной программы. В
данном случае программа будет называться <code>rg</code>. Далее вы можете просмотреть документацию
к этой программе с помощью команды <code>rg --help</code>. Ок. Теперь вы готовы использовать
быструю реализацию  <code>grep</code> реализованную на Rust для поиска файлов.</p>
<a class="header" href="print.html#aРасширение-cargo-с-помощью-разработки-дополнительных-команд" id="aРасширение-cargo-с-помощью-разработки-дополнительных-команд"><h2>Расширение Cargo с помощью разработки дополнительных команд</h2></a>
<p>Функционал Cargo можно расширять дополнительными командами без изменения кода программы.
Если название вашего бинарный файл выглядитпримерно как <code>cargo-something</code>, вы можете
запускать его с помощью команды <code>cargo something</code>. Эта же команда будет видна в
списке доступных (<code>cargo --list</code>). Наличие возможности устанавливать расширения
и запускать их, как дополнительный инструмент - весьма удобно. Спасибо дизайнерам
Cargo!</p>
<a class="header" href="print.html#aИтоги-10" id="aИтоги-10"><h2>Итоги</h2></a>
<p>Общий репозиторий программных решений с помощью Cargo и crates.io создаёт удобную
экосистему Rust. Стандартная библиотека небольшая, но стабильная. Дополнительные
компоненты легко доступны. Пожалуйста, не стесняйтесь делиться удобными и интересными
программными решениями! Возможно, они будут полезны для членов сообщества.</p>
<a class="header" href="print.html#aУмные-указатели-smart-pointers" id="aУмные-указатели-smart-pointers"><h1>Умные указатели (Smart Pointers)</h1></a>
<p>Указатели (<em>Pointer</em>) - это обобщенный термин в программировании, который обозначает
что-то что ссылается на место, где хранятся какие-то данные. Мы уже изучали ссылки
в Главе 4. Это было что-то похожее на ссылки, индикатором которого был <code>&amp;</code> символ
и это опция осуществляла заимствование. Умные указатели - это структуры данных,
которые ведут себя также как и указатели, но дополнительно к этому имеют метаданные
и способности (такие как счётчик ссылок). Шаблон &quot;умные указатели&quot; бы заимствован
из С++. В Rust, ссылки это подобие указателей, которые заимствуют данные. Умные
указатели в свою очередь <em>владеют</em> данными, на которые они ссылаются.</p>
<p>Хотя мы не упоминали об этом, вы уже работали с некоторыми умными указателями в
Rust. До этой главы (мы не хотели перегружать изложение материла терминами) мы
умалчивали о их истинной природе. К примеру, в определенном смысле <code>String</code> и
<code>Vec&lt;T&gt;</code> из Главы 8 это всё умные указатели. Они владеют памятью и позволяют
манипулировать ей, они имеют метаданные (ёмкость) и дополнительные возможности и
предоставляют гарантии (например всегда содержать действительные UTF-8 данные).
Характеристиками, по которым отличают умные указатели от структур является то,
что умные указатели реализуют типажи <code>Deref</code> и <code>Drop</code>. В этой главе мы расскажем о
этих типажах и почему они важны для умных указателей.</p>
<p>Несмотря на то, что шаблон &quot;умные указатели&quot; это часто используемый шаблон в Rust,
в этой главе не будем рассказывать о всех существующих в стандартной библиотеке
подобных конструкциях. Множество библиотек имеют свои умные указатели и вы также
сможете создать свои. Мы только остановимся на самых часто используемых:</p>
<ul>
<li><code>Box&lt;T&gt;</code> для получения простраства для данных в куче (памяти)</li>
<li><code>Rc&lt;T&gt;</code> тип счётчик ссылок, такой что данные могу иметь несколько владельцев</li>
<li><code>RefCell&lt;T&gt;</code> этот тип не является умным указателем как таковым, но он управляет
доступом к умным указателям <code>Ref</code> и <code>RefMut</code> для того, чтобы применить правила
владения в момент работы, а не в момент компиляции</li>
</ul>
<p>Попутно мы также рассмотрим:</p>
<ul>
<li>Шаблон <em>внутренняя изменчивость</em> (<em>interior mutability</em>), в котором неизменяемый
тип предоставляет API для изменяемого внутреннего типа значение. Кроме того правила
заимствования применяются в момент работы программы, а не в момент компиляции</li>
<li>Зацикленные ссылки. Как они могут привести к утечками памяти и как этого избежать</li>
</ul>
<p>Приступим!</p>
<a class="header" href="print.html#aТип-данных-boxt-ссылается-на-данные-в-куче-и-имеет-известный-размер" id="aТип-данных-boxt-ссылается-на-данные-в-куче-и-имеет-известный-размер"><h2>Тип данных <code>Box&lt;T&gt;</code> ссылается на данные в куче и имеет известный размер</h2></a>
<p>Самый простой (очевидный) умный указатель это (коробка) <em>box</em> (<code>Box&lt;T&gt;</code>).
Коробки позволяют вам поместить одно знание в кучу (мы уже упоминали о том, что
такое куча в Главе 4). Код 15-1 показывает как можно использовать коробку для хранения
значения типа <code>i32</code> в куче</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Код 15-1: сохранение значения <code>i32</code> типа в куче используя
коробку</span></p>
<p>Результатом будет печать строки  <code>b = 5</code>. В этом случае, мы можем получить доступ
к данным в коробке, как если бы эти данные были в стеке. Как любое значение, которое
владеет данными, когда коробка выходит станет находиться за областью работу программы,
как <code>b</code> после отработки функцией <code>main</code> всех команд, она станет недействительной.
Недействительными будут и коробка (контейнер данных, данные о котором находятся в
стеке) и данные.</p>
<p>Конечно, хранение единственного значения в куче неудобно. Обычно такое решение
применяется крайне редко. Использование коробки наиболее удобно тогда, когда
необходимо точно знать размер типа хранимого типа данных. Например, в коде 15-2,
в котором содержится определение перечисления для <em>списка недостатков</em> (<em>cons list</em>)
тип структуры данных взят из функционального программирования. Обратите внимание,
что такой код не скомпилируется:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">код 15-2: первая попытка определения перечисления для представления
списка недостатков с данными типа <code>i32</code></span></p>
<p>Мы реализуем список недостатков, которые хранят только значения типа <code>i32</code>. Мы также
можем выбрать реализацию списка недостатков независимого от типа значений с помощью
обобщенных типов данных (дженериков), которые мы обсуждали в Главе 10.</p>
<blockquote>
<a class="header" href="print.html#aПодробнее-о-списке-недостатков" id="aПодробнее-о-списке-недостатков"><h4>Подробнее о списке недостатков</h4></a>
<p><em>Список недостатков</em> cons list* - это структура данных, которая пришла из языка программирования
Lisp и его диалектов. В Lisp, функция <code>cons</code>  (сокращение от “construct
function” функции-конструктора) создаёт новый список используя два аргумента,
один из которых значение, а другое список.</p>
<p>Концепция такого шаблонного решения пришла из функционального программирования</p>
<p>Список создаётся путём рекурсивного вызова функции <code>cons</code>.
Каноническое имя для обозначения базового случая рекурсии - «Nil», которое обозначает
окончание списка. Обратите внимание, что это значение не является тем же что и
“null” или “nil” в Главе 6. Это недействительное или отсутствующе значение.</p>
</blockquote>
<p>Этот специальный список содержит и значение и ссылку остаток списка в этой точке.
Остатки списка определены по вложенным спискам. Конец списка обозначается значением
<code>Nil</code>. Cons-списки не используются очень часто в Rust; <code>Vec &lt;T&gt;</code> обычно является
лучшим выбором. Реализация этой структуры данных является хорошим примером ситуации,
когда <code>Box &lt;T&gt;</code> полезен. Давайте узнаем, почему!</p>
<p>Для того, чтобы сохранить список значений <code>1, 2, 3</code>, используя cons-список, напишем
следующий код:</p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p>Первое <code>Cons</code>-значение хранит 1 и другой список как значение. Это список содержит
значение 2 и другой список. Этот список содержит значение 3 и <code>Nil</code>- сигнал, что
список завершён.</p>
<p>Пытаемся скомпилировать данный код 15-3:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt;
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |     --------------- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p><span class="caption">код 15-3: ошибка. Попытка определить бесконечное рекурсивное
перечисление</span></p>
<p>Описание ошибки сообщает, что тип имеет бесконечный размер. Почему? Т.к. мы
определили, что <code>List</code> имеет рекурсивное значение самого себя. Это значит, что
Rust не может вычислить размер памяти, который надо выделить значению списка.
Для решения этой задачи, сначала надо понять, как компилятор определяет сколько
памяти необходимо для хранения не рекурсивного типа. Вспомним определение перечисления
<code>Message</code> из примера 6-2:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#}</code></pre></pre>
<p>Когда компилятору необходимо знать сколько ему необходимо памяти для значения перечисления
<code>Message</code>, он может пройтись по порядку по его значениям. Для <code>Message::Quit</code> не
надо памяти. <code>Message::Move</code> необходимо место для хранения двух значений типа <code>i32</code>.
И так далее. Таким образом, наибольшее количество памяти, которое понадобится для
хранения одного элемента - это наибольшее значение этого его значения перечисления.</p>
<p>Теперь можно понять, почему применяя данный алгоритм вычисления размера в рекурсивных
типах происходят ошибки (15-4).</p>
<p><img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">вид 15-4: бесконечный <code>List</code> содержит бесконечное значение
<code>Cons</code> variants</span></p>
<p>Поэтому компилятор выдаёт ошибку (он не может понять, сколь же памяти нужно выделить
данному типу). Компилятор в этом случает даёт полезную рекомендацию:</p>
<pre><code class="language-text">= help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
        make `List` representable
</code></pre>
<p>Т.к. <code>Box&lt;T&gt;</code> является ссылкой, мы всегда знаем её размер: ссылка всегда имеет
размер <code>usize</code>. Значения <code>usize</code> будет являться адресом в куче. Куча может быть
любого размера, но адрес начала данных всегда будет кратен <code>usize</code>.  Мы исправим
ошибку, сделав изменения в коде нашего примера:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">код 15-5: определение <code>List</code>, который использует <code>Box&lt;T&gt;</code>
для определения размера для хранения типа</span></p>
<p>Теперь компилятор может рассчитать размер типов. В этом ошибок не будет. Теперь <code>Cons</code>
выглядит следующим образом:</p>
<p><img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" /></p>
<p><span class="caption">вид 15-6: <code>List</code>, который имеет определенный размер </span></p>
<p>Это основная сфера использования коробок - решение вопроса с рекурсивными данными.
Мы ещё рассмотрим ещё один аспект, где Rust использует данные неизвестного заранее
размера (в Главе 17). Когда будем обсуждать объектные типажи.</p>
<p>Хотя вы ещё не использовали коробки очень часто, они - хороший способ понять, что
же такое умные указатели. Два аспекта, которые имеют умные указатели - это реализация
типажей <code>Deref</code> и <code>Drop</code>. Рассмотрим, как эти типажи работают и как умные указатели
их используют.</p>
<a class="header" href="print.html#aТипаж-deref-позволяет-получить-доступ-к-данным-по-ссылке" id="aТипаж-deref-позволяет-получить-доступ-к-данным-по-ссылке"><h2>Типаж <code>Deref</code> позволяет получить доступ к данным по ссылке</h2></a>
<p>Первый важный типаж связанный с умным указателем это <code>Deref</code>, который позволяет
нам перезаписать оператор <code>*</code> получения данных по ссылке. Перезапись данного оператора
для умного указателя даёт доступ к данным удобным.</p>
<p>Мы вкратце упоминали оператор разыменования в Главе 8, в хэш-карте в разделе
«Обновление значения на основе старого значения». У нас была изменяемая ссылка,
и мы хотели изменить значение, указываемое ссылкой. Для этого сначала нужно было
разыменовать ссылку. Вот другой пример, использующий ссылки на значения <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
{
    let y = &amp;mut x;

    *y += 1
}

assert_eq!(6, x);
#}</code></pre></pre>
<p>Мы используем <code>*y</code> для доступа к данным, к которым изменяемая ссылка <code>y</code> ссылается,
а не к изменяемой ссылке как таковой. Далее, мы можем изменить данные, в данном
случае добавив 1.</p>
<p>Для ссылок, которые не являются умными указателями, есть только одно значение, на
которое ссылается указатель. Поэтому операция разыменования очевидна. Умные указатели
также могут сохранять метаданные о указателях или данные. Когда разыменование происходит,
нам необходим доступ к данным, а не к метаданным. Поэтому разыменование обычного
указателя - это получение данных, а не метаданных. Нам необходимо иметь возможность
использовать умные указатели в том же месте, где мы используем обычные указатели.
Для того, чтобы это было возможным, нам нужно перезаписать поведение оператора <code>*</code>,
реализовав типаж <code>Deref</code>.</p>
<p>Код 15-7 демонстрирует пример перезаписи оператора <code>*</code> используя <code>Deref</code> для
структуры, которая хранит данные mp3 и метаданные. <code>Mp3</code>, как умный указатель
владеет данными  <code>Vec&lt;u8&gt;</code> содержащими аудио. Дополнительно, структура содержит
опциональные метаданные (в данном случае, описание артиста и заголовок).
Мы хотим иметь возможность удобного доступа к данным аудио, не к метаданным. Для
того реализуем типаж <code>Deref</code>.</p>
<p>Для реализации типажа <code>Deref</code> необходимо реализовать метод <code>deref</code>, которые заимствует
<code>self</code> и возвращает внутренние данные:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Deref;

struct Mp3 {
    audio: Vec&lt;u8&gt;,
    artist: Option&lt;String&gt;,
    title: Option&lt;String&gt;,
}

impl Deref for Mp3 {
    type Target = Vec&lt;u8&gt;;

    fn deref(&amp;self) -&gt; &amp;Vec&lt;u8&gt; {
        &amp;self.audio
    }
}

fn main() {
    let my_favorite_song = Mp3 {
        // we would read the actual audio data from an mp3 file
        audio: vec![1, 2, 3],
        artist: Some(String::from(&quot;Nirvana&quot;)),
        title: Some(String::from(&quot;Smells Like Teen Spirit&quot;)),
    };

    assert_eq!(vec![1, 2, 3], *my_favorite_song);
}
</code></pre></pre>
<p><span class="caption">код 15-7: реализация типажа <code>Deref</code></span></p>
<p>Большая часть кода думаю вам понятна: объявление структуры, реализация типажа и
функция main, в которой создаётся экземпляр структуры. Мы только не объясняли ещё
тему ассоциированных типом (оставим это до Главы 19). Это всё лишь другой способ
объявления обобщенного параметра.</p>
<p>В макросе <code>assert_eq!</code> мы сравниваем вектор <code>vec![1, 2, 3]</code> и результат разыменования
ссылки на экземпляр <code>Mp3</code> <code>*my_favorite_song</code> (результат использования реализации
типажа Deref). Типаж <code>Deref</code> не будет реализован, компилятор сообщит об ошибке
(пожалуйста, проверьте).</p>
<p>Без реализации типажа <code>Deref</code> компилятор может только разыменовать <code>&amp;</code> ссылки.
В данном примере мы получим значение экземпляра <code>Mp3</code>. Благодаря реализации типажа
<code>Deref</code> компилятор знает, что те типы данных, которые реализовали типаж <code>Deref</code>
реализовали метод, который возвращает ссылку (в данном случае <code>&amp;self.audio</code>).
Для того, чтобы ссылка могла быть разыменована, компилятор неявным образом преобразует
выражение <code>*my_favorite_song</code> в:</p>
<pre><code class="language-rust ignore">*(my_favorite_song.deref())
</code></pre>
<p>Результатом разыменования будет значение в поле <code>self.audio</code>.  Причина по которой
метод <code>deref</code> возвращает ссылку является владение: если метод вернёт значение,
значение переместится из <code>self</code>. Целью работы метода не является передача владения,
а передача ссылки на корректное значение или экземпляр.</p>
<p>Обратите внимание, что при разыменовании с помощью символа <code>*</code> вызывается метод
<code>deref</code>.</p>
<a class="header" href="print.html#aРазыменование-явным-образом-с-помощью-функций-и-методов" id="aРазыменование-явным-образом-с-помощью-функций-и-методов"><h3>Разыменование явным образом с помощью функций и методов</h3></a>
<p>В Rust предпочтение отдаётся явном действиям компилятора. Но при этом есть исключения.
При разыменовании аргументов функций и методов. При этом происходит автоматическая
конвертация ссылки в указатель внутри объекта, на который данная ссылка ссылается.
Принудительное разыменование происходит, когда аргумент ссылочного типа передаётся
в функцию отличается от ссылочного аргумента определённого в функции. Принудительное
разыменование добавлено в язык Rust для упрощения вызова функций и методов для
краткости кода. Чтобы не было явного множества использования ссылок и разыменований
с помощью символов <code>&amp;</code> и <code>*</code>.</p>
<p>Приведём пример (15-7). В функции `compress_mp3:</p>
<pre><code class="language-rust ignore">fn compress_mp3(audio: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    // the actual implementation would go here
}
</code></pre>
<p>Если в Rust не будет принудительного разыменования, то эту функцию пришлось
переписать следующим образом:</p>
<pre><code class="language-rust ignore">compress_mp3(my_favorite_song.audio.as_slice())
</code></pre>
<p>В этом случае мы должны явным образом сообщить, что мы хотим получить данные из
поля <code>audio</code> переменной <code>my_favorite_song</code>. Если данные поля будут интенсивно
использоваться, в этом случает вызов метода <code>.audio.as_slice()</code> будет постоянным.</p>
<p>Но т.к. существует принудительное разыменование и мы реализовали типаж <code>Deref</code> в
<code>Mp3</code>, мы можем вызвать функцию таким образом:</p>
<pre><code class="language-rust ignore">let result = compress_mp3(&amp;my_favorite_song);
</code></pre>
<p>Получение ссылок с помощью <code>&amp;</code> это замечательно. Мы можем интерпретировать умные
указатели, как регулярные, постоянные ссылки. Процесс разыменования значит, что
Rust может использовать реализацию типажа <code>Deref</code>. Также Rust известно, что реализация
этого типажа <code>Vec&lt;T&gt;</code> возвращает <code>&amp;[T]</code>. Компилятор видит, что можно использовать
функцию <code>Deref::deref</code> дважды чтобы получить <code>&amp;Vec&lt;u8&gt;</code> из <code>&amp;Mp3</code> и далее <code>&amp;[T]</code>.
Весь это анализ и преобразования делаются в момент компиляции.</p>
<p>Таким же образом (<code>*</code> → <code>&amp;T</code>) работает реализация типажа <code>DerefMut</code> (<code>*</code> → <code>&amp;mut T</code>).</p>
<p>Компилятор производит принудительное разыменование в следующих случаях:</p>
<ul>
<li>Из <code>&amp;T</code> в <code>&amp;U</code> в случае <code>T: Deref&lt;Target=U&gt;</code>.</li>
<li>Из <code>&amp;mut T</code> в <code>&amp;mut U</code> в случае <code>T: DerefMut&lt;Target=U&gt;</code>.</li>
<li>Из <code>&amp;mut T</code> в <code>&amp;U</code> в случае <code>T: Deref&lt;Target=U&gt;</code>.</li>
</ul>
<p>Первые два случая похожи (за исключением изменяемости ссылки): если у вас есть
<code>&amp;T</code> и <code>T</code> реализует <code>Deref</code> для типа <code>U</code>, вы можете получить тип <code>&amp;U</code> неявным
образом. Также для изменяемых ссылок.</p>
<p>Последний более сложный и немного странный: если у вас есть изменяемая ссылка, она
также может превратиться в неизменяемую. Обратное преобразование невозможно, т.к.
неизменяемая ссылка никогда не может быть превращена в изменяемую.</p>
<p>Причина, по которой типаж <code>Deref</code> важен для шаблона умных указателей, является
то что эти указатели могут обрабатываться как регулярные ссылки и использоваться в
местах, которые ожидают регулярных ссылок. Нам не нужно переопределять методы и
например, для явного указания умных указателей.</p>
<a class="header" href="print.html#aТипаж-drop-выполняется-когда-значения-становится-недействительным" id="aТипаж-drop-выполняется-когда-значения-становится-недействительным"><h2>Типаж <code>Drop</code> выполняется когда значения становится недействительным</h2></a>
<p>Другим важным типажом шаблонов умных указателей является <code>Drop</code>. Он позволяет
выполнятся коду в момент окончания существования значения. Умные указатели выполняют
отчистку памяти, кода элементы становятся недействительными. Т.е. типы данных
могут управлять ресурсами в памяти, такими как файлы и подключения и использовать
типаж <code>Drop</code> в контексте умных указателей.</p>
<p>В некоторых языках программирования такой функционал необходимо реализовывать
программисту самостоятельно. Если вы забудете это сделать это может привести к
перерасходованию памяти и  даже к аварии.</p>
<p>Для реализации типажа <code>Drop</code> необходимо реализовать метод <code>drop</code>, который получает
в качестве параметра изменяемую ссылку на <code>self</code>.</p>
<p>Код 15-8 показывает <code>CustomSmartPointer</code> структуру которая ничего не делает, но
печатает в консоль сообщение, когда экземпляр структуры становится недействительным:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer!&quot;);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    println!(&quot;Wait for it...&quot;);
}
</code></pre></pre>
<p><span class="caption">код 15-8: работы типажа <code>Drop</code> при реализации его структурой
<code>CustomSmartPointer</code> после выхода экземпляра этой структуры из области видимости</span></p>
<p>Типаж «Drop» загружается неявным образом в область действия ПО, поэтому вам ненужно
явным образом его импортировать. Метод <code>drop</code> реализован. В нем вызывается макрос
<code>println!</code>. Обратите внимание, что метод <code>drop</code> был вызван неявным образов в момент
удаления переменной из памяти.</p>
<p>Результат:</p>
<pre><code class="language-text">CustomSmartPointer created.
Wait for it...
Dropping CustomSmartPointer!
</code></pre>
<p>Мы, конечно же, можем вызывать данный метод явно. Но в этом нет никакого смысла.
В Главе 16 мы поговорим о случаях необходимого вызова данного метода заране (при
работе в многопоточной среде). Сейчас же рассмотрим пример явного вызова данного метода:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;Wait for it...&quot;);
}
</code></pre>
<p><span class="caption">код 15-9: вызов метода <code>std::mem::drop</code> явно, до того момента
пока значение не выйдет за область видимости</span></p>
<p>При выполнении данного кода на консоль будет выведен следующий результат::</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer!
Wait for it...
</code></pre>
<p>Обратите внимание, что мы вызвали метод <code>drop</code>. Если мы вызовем метод <code>c.drop()</code>
мы получим ошибку компиляции. Нельзя вызывать метод <code>Drop::drop</code>, т.к. в этом случае
этот метод может быть вызван дважды. Вместо этого мы можем вызвать метод <code>std::mem::drop</code>.
Определение метода <code>std::mem::drop</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod std {
    pub mod mem {
        pub fn drop&lt;T&gt;(x: T) { }
    }
}
#}</code></pre></pre>
<p>Эта функция обобщенная, поэтому в ней использовать для любого типа. Причина по которой
эта пустая функция может быть полезной. Она получает во владение параметр, который
удаляется после работы данной функции.</p>
<p>Код определённый в реализации типажа <code>Drop</code> может быть использован для очистки памяти
и безопасности. Например, для создания своего распределителя памяти. При использовании
типажа <code>Drop</code> совместно с системой владения Rust вам не нужно заботится об очистке
памяти. Rust сделает это за вас. Мы получим ошибку компиляции, если будет использовать
переменную после её удаления. Также Rust следит за тем чтобы значение больше нигде
не использовалось.</p>
<p>После того, как мы познакомились с <code>Box&lt;T&gt;</code> и характеристиками умных указателей,
познакомимся с едё другими умными указателями, которые есть в стандартной библиотеке.</p>
<a class="header" href="print.html#aСчётчик-указателей-rct" id="aСчётчик-указателей-rct"><h2>Счётчик указателей <code>Rc&lt;T&gt;</code></h2></a>
<p>В большинстве случаев владение очень понятно: вы знаете какие переменные владеют
значениями. Но это не всегда так бывает. Иногда необходимо, чтобы переменные
имели нескольких владельцев. Для этого существует тип <code>Rc&lt;T&gt;</code>. Это счётчик ссылок,
который следит за количеством ссылок на значение для того, чтобы понять используется
ли данное значение или уже нет. Если количество ссылок равно нулю, то тогда мы
можем удалить данные без каких-либо внешних негативных эффектов.</p>
<p>Это как просмотр ТВ. Когда какой-либо человек входит и смотрит ТВ оно включает его.
Другие люди также могут смотреть ТВ. Когда же последний человек покидает комнату,
он должен выключить ТВ, т.к. его использование никому уже не нужно. Если же выключить
ТВ раньше, люди, которые смотрят ТВ будут недовольны.</p>
<p><code>Rc&lt;T&gt;</code> используется тогда, в куче необходимо разместить данные для общего пользования
(для чтения) и нельзя определить в момент компиляции время, за которое части
использующие программу закончат её использование. Если же вы знаете, какая часть
закончит последней, мы можем сделать эту часть владельцем данных и обычные правила
владения сделают всё техническую работу по освобождению ресурсов.</p>
<p>Обратите внимание, что <code>Rc&lt;T&gt;</code> используется только в однопоточном сценарии. В последующих
главах мы рассмотрим многопоточные программы. Если вы попытаетесь использовать <code>Rc&lt;T&gt;</code>
в различных потоках, вы не сможете скомпилировать такую программу (сработает
защита компилятора).</p>
<a class="header" href="print.html#aИспользование-rct-для-совместного-использования-данных" id="aИспользование-rct-для-совместного-использования-данных"><h3>Использование <code>Rc&lt;T&gt;</code> для совместного использования данных</h3></a>
<p>Рассмотрим уже знакомый нам пример (15-5). В коде 15-11 мы попытаемся
использовать <code>List</code> используя <code>Box&lt;T&gt;</code>. Сначала мы создадим экземпляр списка, который
содержит 5 и затем 10. Далее, мы хотим создать ещё два листа. Один начинается с 3
и продолжается списком содержащий 5 и 10. Другой начинается с 4 и также продолжается
списком с 5 и 10. Т.е. мы хотим, чтобы два списка разделяли бы владение третьим
списком, как показано на иллюстрации 15-10:</p>
<p><img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" /></p>
<p><span class="caption">рисунок 15-10: два списка, <code>b</code> и <code>c</code> совместно используют
(владеют) списком <code>a</code></span></p>
<p>Попытка реализовать это используя определение <code>List</code> с <code>Box&lt;T&gt;</code> не будет работать
(15-11):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">код 15-11: создание экземпляров используя <code>Box&lt;T&gt;</code>, с помощью
которых мы пытаемся совместно использовать одну переменную</span></p>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not
   implement the `Copy` trait
</code></pre>
<p>Переменные <code>Cons</code> владеют данными, которые хранят в себе. Когда мы создаём <code>b</code>, то
он получает во владение <code>a</code>. Когда же мы пытаемся использовать <code>a</code> снова, когда
создаём <code>c</code>, нам это не разрешено, т.к. <code>a</code> уже перемещено.</p>
<p>Мы можем изменить определение <code>Cons</code> для хранения ссылок, но когда мы должны
определить параметры времени жизни и должны конструировать элементы таким образом,
чтобы каждый элемент жил по крайней мере столько же, сколько список, в котором он
содержится. В противном случае, код не будет скомпилирован. Всё это весьма сложно
для реализации.</p>
<p>Лучшим вариантом будет использовать <code>Rc&lt;T&gt;</code> (15-12):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, a.clone());
    let c = Cons(4, a.clone());
}
</code></pre></pre>
<p><span class="caption">код 15-12: определение <code>List</code>, который использует <code>Rc&lt;T&gt;</code></span></p>
<p>Обратите внимание на необходимость использовать выражение <code>use</code>, т.к. <code>Rc</code> не подгружается
по умолчанию. В <code>main</code> мы создаём список содержащий 5 и 10 и сохраняем его в новом
<code>Rc</code> в <code>a</code>. Далее, мы создаём <code>b</code> и <code>c</code>. Мы клонируем <code>a</code>.</p>
<a class="header" href="print.html#aКлонирование-rct-увеличивает-количество-ссылок" id="aКлонирование-rct-увеличивает-количество-ссылок"><h3>Клонирование <code>Rc&lt;T&gt;</code> увеличивает количество ссылок</h3></a>
<p>Мы уже использовали метод <code>clone</code> раньше, для копирования элемента полностью.
Совместно с <code>Rc&lt;T&gt;</code> полная копия не делается. <code>Rc&lt;T&gt;</code> хранить количество ссылок.
Изменим код в <code>main</code>, как показано в 15-13:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># enum List {
#     Cons(i32, Rc&lt;List&gt;),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;rc = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, a.clone());
    println!(&quot;rc after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, a.clone());
        println!(&quot;rc after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;rc after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">код 15-13: печать количества ссылок</span></p>
<p>Вывод на консоль:</p>
<pre><code class="language-text">rc = 1
rc after creating b = 2
rc after creating c = 3
rc after c goes out of scope = 2
</code></pre>
<p>Такое решение помогает нам иметь нескольких владельцев.</p>
<p>В начале этой секции мы сказали, что <code>Rc&lt;T&gt;</code> позволяет делить данные между несколькими
частями программы для чтения неизменяемых ссылок значений <code>T</code>, которые содержаться
в <code>Rc&lt;T&gt;</code>. Если бы <code>Rc&lt;T&gt;</code> позволяла бы иметь изменяемые ссылки, это бы нарушило бы
целостность данных, о котором мы говорили в Главе 4.</p>
<p>В следующей секции мы поговорим о шаблоне внутренней изменчивости и типе <code>RefCell&lt;T&gt;</code>,
который мы можем использовать совместно с  <code>Rc&lt;T&gt;</code> для преодоления ограничений
ссылочной неизменяемости.</p>
<a class="header" href="print.html#refcellt-и-шаблон-внутренней-изменяемости-interior-mutability-pattern" id="refcellt-и-шаблон-внутренней-изменяемости-interior-mutability-pattern"><h2><code>RefCell&lt;T&gt;</code> и шаблон внутренней изменяемости (Interior Mutability Pattern)</h2></a>
<p><em>Внутренняя изменяемость</em> - это шаблон проектирования в Rust, позволяющий изменять
данные даже если ссылки на эти данные неизменяемые (что обычно нельзя сделать,
из-за правил владения). Это шаблон предлагает использовать небезопасный код внутри
структур данных для связи правил Rust заимствования и изменяемости. Мы подробнее
поговорим о небезопасном коде в Главе 19. Этот шаблон полезен, когда вы уверены,
что правила заимствования будут действительный во время работы программы, даже если
компилятор не будет в этом уверен. Небезопасный код будет использован внутри
безопасной API.</p>
<p>Давайте рассмотрим тип данных <code>RefCell&lt;T&gt;</code>, который реализует этот шаблон.</p>
<a class="header" href="print.html#refcellt-имеет-внутреннюю-изменяемость" id="refcellt-имеет-внутреннюю-изменяемость"><h3><code>RefCell&lt;T&gt;</code> имеет внутреннюю изменяемость</h3></a>
<p>В отличие от <code>Rc&lt;T&gt;</code> тип <code>RefCell&lt;T&gt;</code> представляет собой единственного владельца
данных . Что же отличает <code>RefCell&lt;T&gt;</code> от <code>Box&lt;T&gt;</code>? Давайте вспомним правила
заимствования из Главы 4:</p>
<ol>
<li>В любой момент времени вы можете иметь <em>одно из</em>, но не оба:
<ul>
<li>Одна изменяемая ссылка.</li>
<li>Любое количество неизменяемых ссылок.</li>
</ul>
</li>
<li>Ссылки всегда должны быть действительными.</li>
</ol>
<p>С помощью ссылок и  <code>Box&lt;T&gt;</code> правила заимствования применяются на этапе компиляции.
С помощью <code>RefCell&lt;T&gt;</code> они применяются во время работы программы. Если вы нарушите
эти правила, работая с ссылками - будет ошибка компиляции. Если вы работаете с
<code>RefCell&lt;T&gt;</code> и вы нарушите эти правила - вы получите <code>panic!</code>.</p>
<p>Статический анализ, который проводит компилятор Rust, по своей сути консервативен.
Существуют свойства кода, которые невозможно обнаружить, анализируя
код: самая известная проблема с остановкой, которая выходит за рамки этого
но интересная тема для исследования, если вы заинтересованы.</p>
<p>Поскольку некоторый анализ невозможен, компилятор Rust не пытается даже
что-либо предпринять. Если он не может быть уверен, поэтому он консервативен и
иногда отвергает правильные которые фактически не нарушали бы гарантии Rust.
Иными словами, если Rust пропускает неверную программу, люди не смогут доверять
гарантиям Rust. Если Rust отклонит правильную программу, программист будет
быть неудобным, но ничего катастрофического не может произойти. <code>RefCell &lt;T&gt;</code> полезен
когда вы знаете, что правила заимствования соблюдаются, но компилятор не может
понять, что это правильно.</p>
<p>Подобно <code>Rc &lt;T&gt;</code>, <code>RefCell &lt;T&gt;</code> используется только для однопоточных
сценариев. Мы поговорим о том, как получить функциональность <code>RefCell &lt;T&gt;</code> в
многопоточную программу в следующей главе о параллелизме. Пока, все, что вы
нужно знать, что если вы попытаетесь использовать <code>RefCell &lt;T&gt;</code> в многопоточном
контекст, вы получите ошибку времени компиляции.</p>
<p>С помощью ссылок мы используем синтаксис <code>&amp;</code> и <code>&amp; mut</code> для создания простых ссылок
и изменяемых, соответственно. Но с <code>RefCell &lt;T&gt;</code> мы используем методы <code>borrow</code>
и <code>borrow_mut</code>, которые являются частью безопасного API, который имеет<code>RefCell &lt;T&gt;</code>.
<code>borrow</code> возвращает тип умного указателя<code>Ref</code>, а <code>borrow_mut</code> возвращает
умный указатель типа <code>RefMut</code>. Эти два типа реализуют <code>Deref</code>, чтобы мы могли
рассматривайте их так, как если бы они были регулярными ссылками. <code>Ref</code> и<code>RefMut</code>
отслеживают заимствование динамически, и их реализация <code>Drop</code> отпускает заимствования
динамически.</p>
<p>В листинге 15-14 показано, как выглядит <code>RefCell &lt;T&gt;</code> с функциями, которые
заимствовать их параметры неизменно и изменчиво. Обратите внимание, что переменная
<code>data</code> объявляется неизменной с <code>let data</code>, а не<code>let mut data</code>, но
<code>a_fn_that_mutably_borrows</code> разрешено заимствовать данные динамически и производить
изменения данных!</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::cell::RefCell;

fn a_fn_that_immutably_borrows(a: &amp;i32) {
    println!(&quot;a is {}&quot;, a);
}

fn a_fn_that_mutably_borrows(b: &amp;mut i32) {
    *b += 1;
}

fn demo(r: &amp;RefCell&lt;i32&gt;) {
    a_fn_that_immutably_borrows(&amp;r.borrow());
    a_fn_that_mutably_borrows(&amp;mut r.borrow_mut());
    a_fn_that_immutably_borrows(&amp;r.borrow());
}

fn main() {
    let data = RefCell::new(5);
    demo(&amp;data);
}
</code></pre></pre>
<p><span class="caption">код 15-14: использование <code>RefCell&lt;T&gt;</code>, <code>borrow</code> и
<code>borrow_mut</code></span></p>
<p>This example prints:</p>
<pre><code class="language-text">a is 5
a is 6
</code></pre>
<p>В методе <code>main</code> мы создали экземпляр <code>RefCell&lt;i32&gt;</code> содержащий 5 и сохранили в него
значение 5. Обратите внимание, что этот экземпляр мы сохранили в неизменяемую преременную.
Далее, мы передали её функции <code>demo</code>. Обратите внимание, что аргумент функции тоже
неизменяемая ссылка.</p>
<p>В функции <code>demo</code> мы передаём неизменяемую ссылку на значение внутри <code>RefCell&lt;i32&gt;</code>
посредством вызова метода <code>borrow</code> в функцию <code>a_fn_that_immutably_borrows</code>. Далее,
что более интересно, мы передаём изменяемую ссылку на значение внутри <code>RefCell&lt;i32&gt;</code>
посредством вызова метода <code>borrow_mut</code> в функцию <code>a_fn_that_mutably_borrows</code>.</p>
<a class="header" href="print.html#aПравила-заимствования-проверяются-refcellt-в-момент-работы-программы" id="aПравила-заимствования-проверяются-refcellt-в-момент-работы-программы"><h3>Правила заимствования проверяются <code>RefCell&lt;T&gt;</code> в момент работы программы</h3></a>
<p>Рассмотрим пример из Главы 4. Этот код использует ссылки, который пытается
создать изменяемые ссылки в одной и той же области видимости (ошибка):</p>
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;
</code></pre>
<p>Описание ошибки компиляции:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt;
  |
5 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
6 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
7 | }
  | - first borrow ends here
</code></pre>
<p>Если же использовать <code>RefCell&lt;T&gt;</code> и вызвать <code>borrow_mut</code> дважды код скомпилируется,
но в момент работы произойдет ошибка:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::cell::RefCell;

fn main() {
    let s = RefCell::new(String::from(&quot;hello&quot;));

    let r1 = s.borrow_mut();
    let r2 = s.borrow_mut();
}
</code></pre></pre>
<p>код компилируется, но при его работе (<code>cargo run</code>) происходит ошибка:</p>
<pre><code class="language-text">    Finished dev [unoptimized + debuginfo] target(s) in 0.83 secs
     Running `target/debug/refcell`
thread 'main' panicked at 'already borrowed: BorrowMutError',
/stable-dist-rustc/build/src/libcore/result.rs:868
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Ошибка времени выполнения <code>BorrowMutError</code> похожа на ошибку компиляции - сообщается,
что мы уже заимствовали <code>s</code> один раз и нам нельзя заимствовать её снова. Мы не
можем обойти правила заимствования во время работы. Поэтому использовать обертку
<code>RefCell&lt;T&gt;</code> надо весьма аккуратно. У вас может не быть ошибок при компиляции, но
при работе кода - ошибка случится - это весьма негативно скажется на отладке такого
кода.</p>
<a class="header" href="print.html#aМножественное-владение-изменяемыми-данными-при-совместном-использовании-rct" id="aМножественное-владение-изменяемыми-данными-при-совместном-использовании-rct"><h3>Множественное владение изменяемыми данными при совместном использовании <code>Rc&lt;T&gt;</code></h3></a>
<p>и <code>RefCell&lt;T&gt;</code></p>
<p>Итак, почему мы решили компромиссное решение использовать <code>RefCell &lt;T&gt;</code>?
Ну, помните, когда мы говорили, что <code>Rc &lt;T&gt;</code> позволяет вам иметь неизменяемый
ссылка на <code>T</code>? Учитывая, что <code>RefCell &lt;T&gt;</code> неизменен, но имеет возможность внутреннего
изменения мы можем комбинировать <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code>, чтобы получить тип, который
ссылка подсчитана и изменена. В листинге 15-15 показан пример того, как это сделать
что, снова возвращаясь к списку наших минусов из Листинга 15-5. В этом примере,
вместо сохранения значений <code>i32</code> в списке совпадений, мы будем хранить
<code>Rc &lt;RefCell &lt;i32&gt;&gt;</code> значения. Мы хотим сохранить этот тип, чтобы мы могли
иметь владельца данных, который не входит в список (несколько владельцев
функциональность, которую предоставляет <code>Rc &lt;T&gt;</code>), и поэтому мы можем изменять
внутреннее значение  <code>i32</code>(функция внутренней изменчивости, предоставляемая <code>RefCell &lt;T&gt;</code>):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Cons(value.clone(), Rc::new(Nil));
    let shared_list = Rc::new(a);

    let b = Cons(Rc::new(RefCell::new(6)), shared_list.clone());
    let c = Cons(Rc::new(RefCell::new(10)), shared_list.clone());

    *value.borrow_mut() += 10;

    println!(&quot;shared_list after = {:?}&quot;, shared_list);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">код 15-15: использование <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> для создания
<code>List</code>, который мы можем изменять</span></p>
<p>Мы создали экземпляр <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>. Мы сохранили его в <code>value</code>.
Далее мы создали <code>List</code> в <code>a</code>, который содержит <code>Cons</code> . Далее, мы обернули это
значение в <code>Rc&lt;T&gt;</code>, благодаря чему мы смогли создать списки <code>b</code> и <code>c</code>.</p>
<p>Далее, мы добавили число 10 к имеющимися значению с помощью разыменования и
использования функции <code>borrow_mut</code>.</p>
<p>Далее мы вывели на печать <code>shared_list</code>, <code>b</code> и <code>c</code>:</p>
<pre><code class="language-text">shared_list after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>Помимо <code>RefCell&lt;T&gt;</code> существует ещё <code>Cell&lt;T&gt;</code>, которое копирует в и из.
<code>Mutex&lt;T&gt;</code> предлагает изменяемость между потоками. Об этом мы поговорим в соответствующей
главе.</p>
<a class="header" href="print.html#aЗащита-от-создания-ссылочного-зацикливания-и-утечки-памяти" id="aЗащита-от-создания-ссылочного-зацикливания-и-утечки-памяти"><h2>Защита от создания ссылочного зацикливания и утечки памяти</h2></a>
<p>Компилятор обеспечивает множеством различных защит от ошибок: от недействительных
ссылок, эфект гонки. Также весьма удобна система обеспечения очистки ресурсов памяти
(что также называют утечкой памяти). В тоже время, компилятор не может гарантировать,
что это невозможно. Иными словами утечка памяти может быть безопасной.</p>
<p>Используя умные указатели <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code> возможно создать цепочки ссылок,
где элементы циклично ссылаются друг на друга. Это плохая ситуация, т.к. количество
ссылок каждого элемента никогда не достигнет 0 и, следовательно, постоянно будет
находится в памяти. Давайте разберёмся, как это происходит и постараемся найти
пути предотвращения.</p>
<p>В примере кода 15-16 мы будем использовать другой вариант определения <code>List</code>.
Мы будем снова сохранять значение <code>i32</code> в первом элементе. Второй элемент теперь
будет <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>. Вместо изменения значения первого элемента мы будем
изменять второй. Мы также добавим метод <code>tail</code> для удобного доступак к второму
элементу:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre>
<p><span class="caption">код 15-16: определение списка сons, который содержит <code>RefCell</code>.
Мы можетм изменять <code>Cons</code> значение, на которое элемент ссылается</span></p>
<p>Далее, в коде 15-17, мы создадим экземпляр <code>List</code> и сохраним его в переменную <code>a</code>,
которая изначально будет иметь значения <code>5, Nil</code>. Далее, мы создаём переменную
<code>b</code> содержащую 10 и ссылку на <code>a</code>. И в конце мы изменяем <code>a</code> так, что она ссылается
на <code>b</code> вместо <code>Nil</code>. Так мы создаём зацикливание ссылок:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># #[derive(Debug)]
# enum List {
#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
#     Nil,
# }
#
# impl List {
#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
#         match *self {
#             Cons(_, ref item) =&gt; Some(item),
#             Nil =&gt; None,
#         }
#     }
# }
#
use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {

    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(a.clone())));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(ref link) = a.tail() {
        *link.borrow_mut() = b.clone();
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle; it will
    // overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">код 15-17: создание циклической ссылки</span></p>
<p>Мы использовали метод <code>tail</code> для получения ссылки на <code>RefCell</code> в <code>a</code>, которую мы
поместили в переменную <code>link</code>. Далее, мы использовали метод <code>borrow_mut</code> для получения
ссылки на <code>RefCell</code> в для изменения экземпляра <code>Rc</code>, который содержал <code>Nil</code> на
<code>Rc</code> в <code>b</code>. В результате мы создали следующее (15-18):</p>
<p><img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Figure 15-18: A reference cycle of lists <code>a</code> and <code>b</code>
pointing to each other</span></p>
<p>Если вы раскоментируете посследнюю строку с вызовом макроса <code>println!</code> вы получите
ошибку переполнения (overflow).</p>
<p>Посмотрите на результат вывода на консоль! Защита сработала - ничего страшного не
случилось, но это говорит о более сложной проблема - программа используем больше
памяти, чем ей нужно.</p>
<p>Now, as you can see, creating reference cycles is difficult and inconvenient in
Rust. But it’s not impossible: preventing memory leaks in the form of reference
cycles is not one of the guarantees Rust makes. If you have <code>RefCell&lt;T&gt;</code> values
that contain <code>Rc&lt;T&gt;</code> values or similar nested combinations of types with
interior mutability and reference counting, be aware that you’ll have to ensure
that you don’t create cycles. In the example in Listing 15-14, the solution
would probably be to not write code that could create cycles like this, since
we do want <code>Cons</code> variants to own the list they point to.</p>
<p>With data structures like graphs, it’s sometimes necessary to have references
that create cycles in order to have parent nodes point to their children and
children nodes point back in the opposite direction to their parents, for
example. If one of the directions is expressing ownership and the other isn’t,
one way of being able to model the relationship of the data without creating
reference cycles and memory leaks is using <code>Weak&lt;T&gt;</code>. Let’s explore that next!</p>
<a class="header" href="print.html#aПредотвращение-циклических-ссылок-замена-умного-указателя-rct-на-weakt" id="aПредотвращение-циклических-ссылок-замена-умного-указателя-rct-на-weakt"><h3>Предотвращение циклических ссылок: замена умного указателя <code>Rc&lt;T&gt;</code> на <code>Weak&lt;T&gt;</code></h3></a>
<p>Стандартная библиотека Rust предоставляет умный указатель <code>Weak&lt;T&gt;</code>. Его необходимо
использовать для предотвращения циклических ссылок. Эта проблема решается путем
однапраленного владения. Мы уже показывали, как клонирования <code>Rc&lt;T&gt;</code> увеличивает
<code>strong_count</code> ссылки. <code>Weak&lt;T&gt;</code> позволяет не увеличивать <code>strong_count</code>, а увеличивать
<code>weak_count</code> на <code>Rc</code>. Когда <code>Rc</code> выходит за область видимости внутреннее значение
удаляется если <code>strong_count</code> = 0. Для того чтобы получить значение из <code>Weak&lt;T&gt;</code>
прежде всего, нам необходимо обновить его с помощью метода <code>upgrage</code>. Результатом
будет <code>Some</code> или <code>None</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>Мы хотим, чтобы <code>Node</code> мог иметь своих собственных подчиненных узлов и хотим иметь
возможность непосредственного доступа к ним. Поэтому в <code>Vec</code> элементы <code>Rc&lt;Node&gt;</code>.
Мы также хотим иметь возможность изменять узлы и их подчёненность, поэтому <code>Vec</code>
обёрнут умным указателем <code>RefCell</code>. В примере 15-19 мы создадим экземпляр <code>Node</code>
с именем <code>leaf</code>с значением 3 и без подчиненых узлов и другой экземпляр <code>branch</code>
со значением 5 и <code>leaf</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![leaf.clone()]),
    });
}
</code></pre>
<p><span class="caption">Listing 15-19: Создание узла <code>leaf</code> и<code>branch</code>, где <code>branch</code>
родитель <code>leaf</code>, но <code>leaf</code> не имеет ссылки на <code>branch</code></span></p>
<p>The <code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>, since we clone
the <code>Rc</code> in <code>leaf</code> and store that in <code>branch</code>. The <code>Node</code> in <code>branch</code> knows
it’s related to <code>leaf</code> since <code>branch</code> has a reference to <code>leaf</code> in
<code>branch.children</code>. However, <code>leaf</code> doesn’t know that it’s related to <code>branch</code>,
and we’d like <code>leaf</code> to know that <code>branch</code> is its parent.</p>
<p>To do that, we’re going to add a <code>parent</code> field to our <code>Node</code> struct
definition, but what should the type of <code>parent</code> be? We know it can’t contain
an <code>Rc&lt;T&gt;</code>, since <code>leaf.parent</code> would point to <code>branch</code> and <code>branch.children</code>
contains a pointer to <code>leaf</code>, which makes a reference cycle. Neither <code>leaf</code> nor
<code>branch</code> would get dropped since they would always refer to each other and
their reference counts would never be zero.</p>
<p>So instead of <code>Rc</code>, we’re going to make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,
specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>This way, a node will be able to refer to its parent node if it has one,
but it does not own its parent. A parent node will be dropped even if
it has child nodes referring to it, as long as it doesn’t have a parent
node as well. Now let’s update <code>main</code> to look like Listing 15-20:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![leaf.clone()]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre>
<p><span class="caption">Listing 15-20: A <code>leaf</code> node and a <code>branch</code> node where
<code>leaf</code> has a <code>Weak</code> reference to its parent, <code>branch</code></span></p>
<p>Creating the <code>leaf</code> node looks similar; since it starts out without a parent,
we create a new <code>Weak</code> reference instance. When we try to get a reference to
the parent of <code>leaf</code> by using the <code>upgrade</code> method, we’ll get a <code>None</code> value,
as shown by the first <code>println!</code> that outputs:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>Similarly, <code>branch</code> will also have a new <code>Weak</code> reference, since <code>branch</code> does
not have a parent node. We still make <code>leaf</code> be one of the children of
<code>branch</code>. Once we have a new <code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code>
to have a <code>Weak</code> reference to <code>branch</code> for its parent. We use the <code>borrow_mut</code>
method on the <code>RefCell</code> in the <code>parent</code> field of <code>leaf</code>, then we use the
<code>Rc::downgrade</code> function to create a <code>Weak</code> reference to <code>branch</code> from the <code>Rc</code>
in <code>branch.</code></p>
<p>When we print out the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code>
variant holding <code>branch</code>. Also notice we don’t get a cycle printed out that
eventually ends in a stack overflow like we did in Listing 15-14: the <code>Weak</code>
references are just printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The fact that we don’t get infinite output (or at least until the stack
overflows) is one way we can see that we don’t have a reference cycle in this
case. Another way we can tell is by looking at the values we get from calling
<code>Rc::strong_count</code> and <code>Rc::weak_count</code>. In Listing 15-21, let’s create a new
inner scope and move the creation of <code>branch</code> in there, so that we can see what
happens when <code>branch</code> is created and then dropped when it goes out of scope:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![leaf.clone()]),
        });
        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre>
<p><span class="caption">Listing 15-21: Creating <code>branch</code> in an inner scope and
examining strong and weak reference counts of <code>leaf</code> and <code>branch</code></span></p>
<p>Right after creating <code>leaf</code>, its strong count is 1 (for <code>leaf</code> itself) and its
weak count is 0. In the inner scope, after we create <code>branch</code> and associate
<code>leaf</code> and <code>branch</code>, <code>branch</code> will have a strong count of 1 (for <code>branch</code>
itself) and a weak count of 1 (for <code>leaf.parent</code> pointing to <code>branch</code> with a
<code>Weak&lt;T&gt;</code>). <code>leaf</code> will have a strong count of 2, since <code>branch</code> now has a
clone the <code>Rc</code> of <code>leaf</code> stored in <code>branch.children</code>. <code>leaf</code> still has a weak
count of 0.</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope, and its strong count
decreases to 0, so its <code>Node</code> gets dropped. The weak count of 1 from
<code>leaf.parent</code> has no bearing on whether <code>Node</code> gets dropped or not, so we don’t
have a memory leak!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get
<code>None</code> again like we did before <code>leaf</code> had a parent. At the end of the program,
<code>leaf</code> has a strong count of 1 and a weak count of 0, since <code>leaf</code> is now the
only thing pointing to it again.</p>
<p>All of the logic managing the counts and whether a value should be dropped or
not was managed by <code>Rc</code> and <code>Weak</code> and their implementations of the <code>Drop</code>
trait. By specifying that the relationship from a child to its parent should be
a <code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, we’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.</p>
<a class="header" href="print.html#aИтоги-11" id="aИтоги-11"><h2>Итоги</h2></a>
<p>Мы рассмотрели, как вы можете использовать различные типы умных указателей для выбора
различных гарантий и компромиссов, в отличии от обычных ссылок.
<code>Box &lt;T&gt;</code> имеет известный размер и указывает на данные, выделенные в куче.
<code>Rc &lt;T&gt;</code> отслеживает количество ссылок на данные в куче, так что
данные могут иметь несколько владельцев.
<code>RefCell &lt;T&gt;</code> с его внутренней изменчивостью дает нам тип, который может использоваться
там, где нам нужен неизменный тип, и применяет правила заимствования во время
выполнения, а не во время компиляции.</p>
<p>Мы также обсудили типажи <code>Deref</code> и<code>Drop</code>, которые предоставляют функционал умных
указателей. Мы исследовали, как можно создать циклические ссылки, которые могут
вызвать утечку памяти, и как это предотвратить используя <code>Weak &lt;T&gt;</code>.</p>
<p>Если эта глава заинтересовала вас, и теперь вы хотите реализовать свои собственные
умные указатели, проверьте <a href="https://doc.rust-lang.org/stable/nomicon/">The Nomicon</a> чтобы узнать от этом функционале подробнее.</p>
<p>Далее, давайте поговорим о параллелизме в Rust. Мы даже узнаем о нескольких новых
умных указателях, которые могут помочь нам в этом.</p>
<a class="header" href="print.html#aМногопоточность-без-страха" id="aМногопоточность-без-страха"><h1>Многопоточность без страха</h1></a>
<p>Обеспечение безопасности памяти - это не единственная задача, с которой справляется
Rust: быть языком, который лучше других оснащен для многопоточного и параллельного
программирования, всегда был ещё одной сильной стороной Rust. <em>Многопоточное программирование</em>,
где различные части программы выполняется независимо и <em>параллельное программирование</em>,
где разные части программы выполняются в одно и то же время, становятся все более
важными поскольку все больше компьютеров используют несколько процессоров для того,
чтобы наши программы могли воспользоваться преимуществами системы. Исторически,
программирование в этих контекстах было трудным и подвержено множеству ошибок.
Rust надеется это изменить.</p>
<p>Можно подумать, что проблема защиты памяти и предотвращения проблем многопоточности</p>
<ul>
<li>это две разные проблемы и должны решаться разными способами. Однако мы обнаружили,
что владение и система типов являются мощным набором инструменты, которые помогают
справляться с проблемами безопасности памяти <em>и</em> многопоточности!
При использовании прав владения и проверки типов многие ошибки многопоточности
<em>ошибки компиляции</em> в Rust, а не ошибки времени выполнения. Мы прозвали этот аспект
от Rust <em>многопоточность без страха</em>. Это значит, что Rust не только позволяет
вам иметь уверенность в отсутствии побочных ошибок, но также позволяет вам
провести рефакторинг этого типа кода легко, не беспокоясь о появлении новых ошибок.</li>
</ul>
<blockquote>
<p>Обратите внимание на слоган <em>многопоточность без страха</em>. Мы говорим сейчас о
проблемах <em>многопоточности</em> (для краткости) - полная версия <em>многопоточность и параллелизм</em>.</p>
</blockquote>
<p>Многие языки убеждены в надёжности решений, которые они предлагают вам. Это очень
разумная стратегия, особенно для языков более высокого уровня. Языки более низкого
уровня не имеют такой роскоши. Rust дает нам множество инструментов для моделирования
различными способами.</p>
<p>Тема этой главы:</p>
<ul>
<li>Создание потока для одновременного выполнения кода</li>
<li>Отправка сообщений* параллельно и использование каналов для отправки сообщений
между потоками.
<em>Разделение состояния</em> многопоточности. Множество потоков имеют доступ к какой-то
части данных.</li>
<li>Потокобезопасные типажи <code>Sync</code> и <code>Send</code></li>
</ul>
<a class="header" href="print.html#aИспользование-потоков-для-запуска-кода-параллельно" id="aИспользование-потоков-для-запуска-кода-параллельно"><h2>Использование потоков для запуска кода параллельно</h2></a>
<p>В большинстве современных операционных систем, выполнения кода программы называют
<em>процессом</em>. Операционная система одновременно выполняет и управляет множеством
процессов.</p>
<p>Для упрощения работы с процессам вводится логическое понятие <em>потока</em>.</p>
<p>Разделение вычислений, которые ваша программа должна выполнять в нескольких потоках,
может повысить производительность, поскольку программа будет выполнять несколько
действий в в то же время. Однако программирование с помощью потоков может добавить
сложностей. Поскольку потоки выполняются одновременно, нет никакой гарантии
относительно порядка, в котором будут выполняться части вашего кода в разных потоках.
Это может привести к гонке условия, при которых потоки получают доступ к данным
или ресурсам в непоследовательном порядке; взаимоблокировкам, когда два потока
предотвращают продолжение друг друга или ошибки, которые происходят только в определенных
ситуациях, которые трудно воспроизвести надежно. Rust уменьшает влияние этих и
других недостатков использования потоков, но программирование в многопоточном
контексте все еще требует вдумчивости и код таких программ структурирован по-другому,
чем для однопотоковых программ.</p>
<p>Существует несколько разных способов, которыми языки программирования реализуют потоки.
Многие операционные системы предоставляют API для создания новых потоков. К тому же,
многие языки программирования предоставляют собственную специальную реализацию потоков.
Язык программирования, предоставляемые потоки, иногда называет <em>легким</em> или
<em>зеленые</em> потоки. Эти языки принимают несколько таких зеленых потоков и выполняют
их в контексте различного количества потоков операционной системы. По этой причине,
модель, в которой язык вызывает API-интерфейсы операционной системы для создания
потоки иногда называются <em>1:1</em>, один поток ОС для одного языкового потока.
Модель зеленых потоков называется <em>M:N</em> модель, «M» зеленых потоков на <code>N</code> ОС
потоков, где <code>M</code> и<code>N</code> не обязательно совпадают.</p>
<p>Каждая модель имеет свои преимущества и недостатки. Компромисс, который больше всего
важен значение для Rust - это поддержка времени выполнения. <em>Runtime</em> - запутанный
термин; он может иметь разное значение в разных контекстах. Здесь мы подразумеваем
некоторый код, включенный в каждый двоичный формат. Для некоторых языков этот код
большой, для других этот код невелик. Между собой, в обиходе программистов, когда
говорят «без времени исполнения» часто бывает имеют ввиду, «небольшое время выполнения».
Любой язык, не являющийся ассемблером, имеет некоторое количество времени выполнения.
Языки с малым бинарным кодом имеют меньше возможностей, но в результате это приводит
к меньшим двоичным файлам. Меньшие двоичные файлы упрощают объединение языка с другими
языками в других контекстах. Многие языки увеличивают двоичный файл в обмен на
дополнительные функции. Rust стремиться не использовать двоичные файлы.</p>
<p>Лёгкие потоки предполагают использование большие двоичные файлы, которые включают
в себе механизмы управления потоками. Поэтому Rust предоставляет модель 1:1.
Т.к. Rust - это низкоуровневый язык программирования, существуют решения позволяющие
реализовать N:M потоковые модели.</p>
<p>Теперь, когда мы определили, какие типы потоков использует Rust, давайте рассмотрим,
как использовать связанных с потоками API в стандартной библиотеке.</p>
<a class="header" href="print.html#aСоздание-нового-поток-с-помощью--spawn" id="aСоздание-нового-поток-с-помощью--spawn"><h3>Создание нового поток с помощью  <code>spawn</code></h3></a>
<p>Чтобы создать новый поток, мы вызываем функцию <code>thread::spawn</code> и передаем ему
замыкание (мы говорили о замыканиях в главе 13), содержащий код, который мы хотим
запускать в новом потоке. Пример в листинге 16-1 печатает некоторый текст из
нового потока и другой текст из основного потока:</p>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13), containing the code we want
to run in the new thread. The example in Listing 16-1 prints some text from a
new thread and other text from the main thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
    }
}
</code></pre></pre>
<p><span class="caption">код 16-1: создание нового потока для печати в отдельном
потоке чего-либо во время печати в главном потоке</span></p>
<p>Обратите внимание, что когда главный поток прекратит работу, в новом потоке также
прекратится печать. Вывод может быть различным при каждом запуске программы:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>Потоки, вероятно, по очереди будут работать, но это не гарантировано. В этом примере,
основной поток, напечатает первым, хотя в коде печать в коде будет объявлена раньше.
И хотя мы сказали, что создали поток для печати <code>i</code> до 9, он только напечатает до 5,
т.е. до закрытия основного потока. Если вы всегда видите работу только один потока
или если вы не видите перекрытия, попробуйте увеличивая число в диапазонах, чтобы
создать больше возможностей для потока сделать перерыв и дать другому потоку поворот.</p>
<a class="header" href="print.html#aОжидание-окончания-работы-всех-потоков-используя-join" id="aОжидание-окончания-работы-всех-потоков-используя-join"><h4>Ожидание окончания работы всех потоков используя <code>join</code></h4></a>
<p>Не только код в листинге 16-1 не позволяет завершить запущенный поток. Нет никаких
гарантий, что потом может быть запущен. Для решения этой задачи используется
функция <code>thread :: spawn</code> и возвращаемому значению <code>JoinHandle</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
    }

    handle.join();
}
</code></pre></pre>
<p><span class="caption">код 16-2: сохранение значения <code>JoinHandle</code> из <code>thread::spawn</code>
для гарантированного ожидания конца работы потока</span></p>
<p><code>JoinHandle</code> владеет значением, которое запустить ожидание выполнение потока с
помощью метода <code>join()</code>. Вывод будет примерно таким:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>Потоки всё ещё работают хаотично, но главный поток ожидает выполнения дочернего.</p>
<p>Если же мы перенесём код <code>handle.join()</code> перед циклом основного потока, то последовательность
строк вывода будет иной:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
        }
    });

    handle.join();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
    }
}
</code></pre></pre>
<p>Главный поток будет ожидать окончания работы подчинённого:</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<a class="header" href="print.html#aИспользование-move-замыканий-в-потоках" id="aИспользование-move-замыканий-в-потоках"><h3>Использование <code>move</code>-замыканий в потоках</h3></a>
<p>Есть ещё одна опция замыканий, о которой мы ещё не говорили. Это <code>move</code>-замыкания</p>
<blockquote>
<p>Создание замыканий, которые получают доступ к значения из среды выполнения часто
используются при запуске нового потока.</p>
</blockquote>
<p>Продемонстрируем это на примерах!</p>
<p>Обратите внимание на замыкание, которое мы послали в качестве входных данные в
функцию <code>thread::spawn</code> в коде 16-1. Мы не использовали данных из в основного потока.
Рассмотрим первое приближение:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join();
}
</code></pre>
<p><span class="caption">код 16-3: попытка использования вектора, созданного в основном
потоке из дочернего потока</span></p>
<p>Замыкание использует <code>v</code>, т.е. <code>v</code> будет частью среды замыкания. Т.к. <code>thread::spawn</code>
запускает выполнение замыкания в новом потоке.</p>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --&gt;
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword, as shown:
  |     let handle = thread::spawn(move || {
</code></pre>
<p>К сожалению, существуют определенные проблемы: мы заранее не можем знать время жизни
дочернего потока и как долго переменная будет действительна.</p>
<p>Демонстрация проблемы явным образом (16-4):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join();
}
</code></pre>
<p><span class="caption">код 16-4: поток с замыканием, который пытается получить ссылку
на <code>v</code> из главного потока, который удаляет <code>v</code></span></p>
<p>Для решения проблемы последуем совету компилятора:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword, as shown:
  |     let handle = thread::spawn(move || {
</code></pre>
<p>Добавив <code>move</code> перед замыканием, мы представляем замыканию владение значением.
Пример рабочего приложения:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join();
}
</code></pre></pre>
<p><span class="caption">код 16-5: использование <code>move</code> для передачи владения переменной
в дочерний поток</span></p>
<p>А что если добавить <code>drop</code>? Код не будет скомпилирован:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  --&gt;
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<p>Функционал &quot;владение&quot; помог компилятору обнаружить и избежать ошибки. Ура!</p>
<p>Теперь, когда вы познакомились с потоками и некоторыми элементами API, пора рассмотреть
более интересные примеры.</p>
<a class="header" href="print.html#aОтправление-сообщений-данных-потоками" id="aОтправление-сообщений-данных-потоками"><h2>Отправление сообщений (данных) потоками</h2></a>
<p>Одна из опций многопоточности, которая делает её столько популярной - это
<em>передача сообщений</em>. Это когда потоки или субъекты общаются путем отправки друг другу
сообщений, содержащие данные. Вот идея в форме лозунга:</p>
<blockquote>
<p>Не обмениваться данными путем разделения памяти; вместо этого, делитесь памятью
путём общения.</p>
<ul>
<li>[Эффективный переход] (http://golang.org/doc/effective_go.html)</li>
</ul>
</blockquote>
<p>Основным инструментом для достижения этой цели является <em>канал</em>. Канал имеет две
половинки: передатчик и приемник. Одна часть нашего кода может вызывать методы
передатчика данных, которые мы хотим отправить, а другая часть проверяет сообщения.</p>
<p>Мы приступим к примеру, в котором у нас есть один поток, который будет
генерировать значения и отправлять их по каналу. Основной поток получит
значения и распечатает их.</p>
<p>Приступим! Давайте начнем с создания канала (16-6):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
#     tx.send(()).unwrap();
}
</code></pre></pre>
<p><span class="caption">код 16-6: создание канала и присвоение значений переменным
<code>tx</code> и <code>rx</code></span></p>
<p>Функция <code>mpsc::channel</code> создаёт новый канал. Модуль <code>mpsc</code> содержит в себе функционал
для <em>множества отправителей и одного получателя</em>. Начнём с одного отправителя.
В дальнейшем добавим ещё.</p>
<p>Функция <code>mpsc::channel</code> возвращает кортеж. Отправитель и получатель. Это сокращения
от <em>transmitter</em> <em>receiver</em>. Здесь также мы используем выражение <code>let</code> для превращения
элементов кортежа в переменные (мы поговорим подробнее о возможностях <code>let</code> в
Главе 18).</p>
<p>Пример отправки текстового сообщения 16-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">код 16-7: отправление из потока <code>tx</code> сообщения “hi”</span></p>
<p>Мы используем функцию <code>thread::spawn</code> для создания нового потока. Мы используем
<code>move</code> для передачи переменой <code>tx</code>.</p>
<p>Сообщение отправляется с помощью метода <code>send</code>. Метод возвращает <code>Result&lt;T, E&gt;</code>.
Если получателя нет (или он удалён) будет ошибка. Чтобы её изменить используется
метод <code>unwrap</code> (для игнорирования ошибки).</p>
<p>В коде 16-8 мы продемонстрируем получаете значения:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">код 16-8: отправление сообщения по каналу между потоками</span></p>
<p>Отправитель имеет два полезных метода <code>recv</code> and <code>try_recv</code>.</p>
<p>Результат:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<a class="header" href="print.html#aКак-каналы-используют-владение" id="aКак-каналы-используют-владение"><h3>Как каналы используют владение</h3></a>
<p>Рассмотрим взаимодействие каналов и владения на примере (16-9):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">код 16-9: попытка доступа к <code>val</code>после её отправки через канал</span></p>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
   not implement the `Copy` trait
</code></pre>
<a class="header" href="print.html#aОтправка-множества-значений" id="aОтправка-множества-значений"><h3>Отправка множества значений</h3></a>
<p>Пример отправки множества сообщений.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">код 16-10: отправка множества сообщений</span></p>
<p>Результат:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<a class="header" href="print.html#aСоздание-множества-отправителей-путем-клонировния" id="aСоздание-множества-отправителей-путем-клонировния"><h3>Создание множества отправителей путем клонировния</h3></a>
<p>Пример:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># use std::thread;
# use std::sync::mpsc;
# use std::time::Duration;
#
# fn main() {
// ...snip...
let (tx, rx) = mpsc::channel();

let tx1 = tx.clone();
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});
// ...snip...
#
#     for received in rx {
#         println!(&quot;Got: {}&quot;, received);
#     }
# }
</code></pre></pre>
<p><span class="caption">код 16-11: отправка множества сообщений и остановка между каждым</span></p>
<p>Вывод:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<a class="header" href="print.html#shared-state-concurrency" id="shared-state-concurrency"><h2>Shared State Concurrency</h2></a>
<p>Обмен сообщениями не является единственным способом взаимодействия в многопоточной
среде. Вспомните Go-слоган (о котором мы уже упоминали):</p>
<blockquote>
<p>Не взаимодействуйте с помощью разделения памяти - разделяйте память путём
взаимодействия.</p>
</blockquote>
<p>Что же значит &quot;взаимодействие путём разделения памяти&quot;? И более того, почему же
такой способ обмена информацией так не любят любители отправлять сообщения?</p>
<p>Суть в том, что взаимодействие с помощью каналов - это что-то вроде монопольного
владения. Многопоточное разделения памяти - это что-то вроде множественного владения.
Как вы знаете множественное владение возможно посредством умных указателей (Глава
15). Этот функционал несёт в себе дополнительные сложности.</p>
<p>Система владения Rust может помочь решить многие сложности. Рассмотрим один из
минимальных и неделимых компонент многопоточности - мьютексы.</p>
<a class="header" href="print.html#aМьютексы-предоставляют-доступ-к-данным-из-одного-потока-за-раз" id="aМьютексы-предоставляют-доступ-к-данным-из-одного-потока-за-раз"><h3>Мьютексы предоставляют доступ к данным из одного потока (за раз)</h3></a>
<p>Мьютекс применяется для разделения памяти. Он позволяет только одному потоку получать
доступ к данным. Для организации такого доступа необходимо соблюсти последовательность
действий:</p>
<ol>
<li>Перед тем как попытаться получить доступ к данным необходимо получить блокировку.</li>
<li>После того, как данные были использованы вам необходимо разблокировать их (отдать
блокировку).</li>
</ol>
<p>Реальным примером мьютекса будет дискуссия на конференции, где есть только один
микрофон. Прежде чем участник дискуссии может говорить, он должен
спросить или сообщить, что он хотели бы использовать микрофон. Как только он получит
микрофон, он может разговаривать столько, сколько захочет, а затем отдаст
микрофон следующему участнику, который хотел бы поговорить. Было бы грубо
начать кричать, не имея микрофона или украсть микрофон до того, как другой участник
закончит. Никто больше не сможет говорить, если участник дискуссии забыл передать
микрофон следующему, когда он закончил использовать его. Если управление общим
микрофоном будет нарушено любым и вышеприведённых способов, общение не будет работать
так, как планировалось!</p>
<p>Управление мьютексами может быть невероятно сложным и именно поэтому
многие люди с энтузиазмом относятся к каналам. Однако в Rust мы не можем использовать
блокировку и разблокировка неправильным образом, благодаря системе типов и владению.</p>
<a class="header" href="print.html#mutext-api" id="mutext-api"><h4><code>Mutex&lt;T&gt;</code> API</h4></a>
<p>Давайте рассмотрим пример использования мьютекса в коде 16-12, без использования
несколько потоков:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">код 16-12: работа <code>Mutex&lt;T&gt;</code> API в однопоточном контексте</span></p>
<p>Как и любые другие типы, тип <code>Mutex&lt;T&gt;</code> имеет ассоциированную функцию <code>new</code>.
Для доступа к данным внутри мьютекса мы используем метод <code>lock</code>. Блокировка будет
недоступна другим потокам пока текущий не отдаст её.</p>
<p>Как вы уже, наверное догадались <code>Mutex&lt;T&gt;</code> является умным указателем. Метод <code>lock</code>
возвращает умныйй указатель <code>MutexGuard</code>. Он реализовал <code>Deref</code> и <code>Drop</code>.</p>
<a class="header" href="print.html#aРазделение-mutext-между-множеством-потоков" id="aРазделение-mutext-между-множеством-потоков"><h4>Разделение <code>Mutex&lt;T&gt;</code> между множеством потоков</h4></a>
<p>Рассмотрим пример разделения значения между множеством потоков, используя <code>Mutex&lt;T&gt;</code>.</p>
<p>Let’s now try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>. Мы
создадим 10 потоков и каждый будет увеличивать счётчик на 1. Реализуя эту задачу
мы будем получать ошибки, на которых мы будем учиться и изучать работу с <code>Mutex&lt;T&gt;</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(|| {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">код 16-13: создание 10 потоков, каждый из которых увеличивает
счётчик на 1 с помощью <code>Mutex&lt;T&gt;</code></span></p>
<p>Мы создаём переменную <code>counter</code> внутри <code>Mutex&lt;T&gt;</code>. Далее мы создаём 10 потоков с
помощью цикла <code>for</code>. Внутри цикла мы увеличиваем значение на 1</p>
<p>Для того, чтобы все дочерние потоки выполнили свою работу - мы используем <code>join</code>,
чтобы подождать выполнения каждого потока.</p>
<p>Сообщения об ошибках:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows
`counter`, which is owned by the current function
  --&gt;
   |
9  |         let handle = thread::spawn(|| {
   |                                    ^^ may outlive borrowed value `counter`
10 |             let mut num = counter.lock().unwrap();
   |                           ------- `counter` is borrowed here
   |
help: to force the closure to take ownership of `counter` (and any other
referenced variables), use the `move` keyword, as shown:
   |         let handle = thread::spawn(move || {
</code></pre>
<p>Для решения этой проблемы будем использовать <code>move</code>:</p>
<pre><code class="language-rust ignore">thread::spawn(move || {
</code></pre>
<p>Запускаем - получили новые ошибки:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt;
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt;
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>К сожалению, это решение не работает.</p>
<p>Упростим наши пример, чтобы лучше разобраться. Вместо цикла просто создадим
два потока:</p>
<pre><code class="language-rust ignore">let handle = thread::spawn(move || {
    let mut num = counter.lock().unwrap();

    *num += 1;
});
handles.push(handle);

let handle2 = thread::spawn(move || {
    let mut num2 = counter.lock().unwrap();

    *num2 += 1;
});
handles.push(handle2);
</code></pre>
<p>Запускаем - получили ошибки:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt;
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt;
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>Компилятор сообщает, что нельзя передавать владение между потоками.</p>
<a class="header" href="print.html#aМножественное-владение-между-множеством-потоков" id="aМножественное-владение-между-множеством-потоков"><h4>Множественное владение между множеством потоков</h4></a>
<p>Мы уже знаем как можно разделять владение данных с помощью умного указателя <code>Rc&lt;T&gt;</code>.
Раньше мы использовали его только в однопоточном контексте. Рассмотрим его работу
в многопоточном. Обернём <code>Mutex&lt;T&gt;</code> в <code>Rc&lt;T&gt;</code> и будем клонировать <code>Rc&lt;T&gt;</code> перед
перемещение владения в поток:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = counter.clone();
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">код 16-14: попытка использования <code>Rc&lt;T&gt;</code> для организации владения
потоками <code>Mutex&lt;T&gt;</code></span></p>
<p>Ошибка:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied
  --&gt;
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ the trait `std::marker::Send` is not
   implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
   |
   = note: `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads
   safely
   = note: required because it appears within the type
   `[closure@src/main.rs:11:36: 15:10
   counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
   = note: required by `std::thread::spawn`
</code></pre>
<p>Мы поговорим о <code>Send</code> в следующей секции.</p>
<p>К сожалению, умный указатель <code>Rc&lt;T&gt;</code>не может защитить данные в многопоточной среде.
А что если у нас будет тип похожий на <code>Rc&lt;T&gt;</code>, но работающий в потокобезопасном
режиме?</p>
<a class="header" href="print.html#aАтомарный-счётчик-ссылок-arct" id="aАтомарный-счётчик-ссылок-arct"><h4>Атомарный счётчик ссылок <code>Arc&lt;T&gt;</code></h4></a>
<p>Тип потобезопасный счётчик сылок - это <code>Arc&lt;T&gt;</code>. Он входит в стандартную библиотеку в
модуль <code>std::sync::atomic</code>.</p>
<p>Почему не все примитивные типы атомарны и почему не все типы стандартной библиотеки
реализовали <code>Arc&lt;T&gt;</code> по умолчанию. Ответ - из-за проблем с производительностью.
Многопоточность накладывает дополнительные расходы ресурсов.</p>
<p>По своему поведения <code>Arc&lt;T&gt;</code> и <code>Rc&lt;T&gt;</code> идентичны:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = counter.clone();
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">код 16-15: использование <code>Arc&lt;T&gt;</code> для предоставления владения
между множеством потоков</span></p>
<p>This will print:</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>Возможно, вы заметили, что, поскольку <code>counter</code> является неизменным, но мы можем
получить изменяемую ссылку на значение внутри него. Это означает, что <code>Mutex &lt;T&gt;</code>
обеспечивает внутреннюю изменчивость, как <code>Cell</code>. Точно так же, как мы использовали
<code>RefCell &lt;T&gt;</code> в главе 15, чтобы иметь возможность изменять содержимое внутри
<code>Rc &lt;T&gt;</code>, мы используем <code>Mutex &lt;T&gt;</code>, чтобы иметь возможность изменять содержимое
внутри <code>Arc &lt;T&gt;</code>.</p>
<p>Напомним, что <code>Rc &lt;T&gt;</code> не решило проблему доступа к данным в мнопоточной среде.
Также <code>Mutex &lt;T&gt;</code> не предотвращает взаимные блокировки.</p>
<p>В следующей секции мы поговорим о использовании типажей <code>Send</code> и <code>Sync</code> для работы
в многопоточной среде.</p>
<a class="header" href="print.html#aРасширения-возможностей-многопоточных-программ-с-помощью-типажей-sync-и-send" id="aРасширения-возможностей-многопоточных-программ-с-помощью-типажей-sync-и-send"><h2>Расширения возможностей многопоточных программ с помощью типажей <code>Sync</code> и <code>Send</code></h2></a>
<p>Как вы уже успели заметить в самом языке Rust нет языковых конструкций для работы
с многопоточностью. Всё опции становятся доступны при использовании библиотек.</p>
<a class="header" href="print.html#aТипаж-send-индикатор-владения-которое-может-быть-передано-от-одного-потока-к-другому" id="aТипаж-send-индикатор-владения-которое-может-быть-передано-от-одного-потока-к-другому"><h3>Типаж <code>Send</code> индикатор владения, которое может быть передано от одного потока к другому</h3></a>
<p>Почти в все типы в стандартной библиотеке Rust реализуют типаж <code>Send</code>. Если он
не реализует (например, <code>Rc&lt;T&gt;</code> - значит он не должен использоваться в многопоточной
среде).</p>
<a class="header" href="print.html#aРеализация-типажа-sync-говорит-о-том-что-это-его-можно-использовать-в-многопоточной-среде" id="aРеализация-типажа-sync-говорит-о-том-что-это-его-можно-использовать-в-многопоточной-среде"><h3>Реализация типажа <code>Sync</code> говорит о том, что это его можно использовать в многопоточной среде</h3></a>
<p>Реализация типажа <code>Sync</code> - индикатор того, что тип потокобезопасный. Т.е.
если тип <code>T</code> является <code>Sync</code>если <code>&amp;T</code> является <code>Send</code>.
The <code>Sync</code> marker trait indicates that a type is safe to have references to a
value from multiple threads. Another way to say this is for any type <code>T</code>, <code>T</code>
is <code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code> so that the reference can be
sent safely to another thread. In a similar manner as <code>Send</code>, primitive types
are <code>Sync</code> and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p>Умные указатели <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> и производные от <code>Cell&lt;T&gt;</code> не являются
потокобезопасными  - не реализуют <code>Sync</code>.</p>
<a class="header" href="print.html#aРеализация-send-и-syncв-ручном-режиме---небезопасна" id="aРеализация-send-и-syncв-ручном-режиме---небезопасна"><h3>Реализация <code>Send</code> и <code>Sync</code>в ручном режиме - небезопасна</h3></a>
<p>Обычно Вам не нужно реализовывать типажи <code>Send</code> и <code>Sync</code>. Т.к. это типажи-маркеры
они не имеют методов.</p>
<a class="header" href="print.html#aИтого" id="aИтого"><h2>Итого</h2></a>
<p>Компилятор проводит работу благодаря, которой ваш код может быть потокобезопасным.
Реализовав все его требования вы можете быть уверены, что ваша многопоточное решение
будет работать безотказно.</p>
<p>Next, let’s talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger, and how Rust’s idioms relate to those you
might be familiar with from Object Oriented Programming.
В следующей главе мы рассмотрим вопросы архитектуру приложений. Рассмотрим связи
различных концепций программирования реализованных в Rust для выбора подходящих решений.</p>
<a class="header" href="print.html#aЯвляется-ли-rust-ООП-языком-программирования" id="aЯвляется-ли-rust-ООП-языком-программирования"><h1>Является ли Rust ООП языком программирования?</h1></a>
<p>ООП - концепция программирования для моделирования процессов и объектов. Существует
множество определений ООП. Язык Rust нельзя однозначно отнести к языку ООП. Далее
мы рассмотрим концепции ООП и как они реализуются в Rust.</p>
<a class="header" href="print.html#aЧто-означает-объектно-ориентированное" id="aЧто-означает-объектно-ориентированное"><h2>Что означает объектно-ориентированное?</h2></a>
<p>В сообществе разработчиков отсутствует консенсус относительно особенностей
языка, который он должен иметь, чтобы быть названным объектно-ориентированным.
Rust реализован под влиянием различных парадигм программирования.</p>
<a class="header" href="print.html#aОбъекты-содержат-данные-и-поведение" id="aОбъекты-содержат-данные-и-поведение"><h3>Объекты содержат данные и поведение</h3></a>
<p>Книга &quot;Приёмы объектно-ориентированного проектирования. Паттерны проектирования&quot;
(1994) называемая также &quot;книгой банды четырёх&quot; является каталогом
объектно-ориентированных шаблоны проектирования. В ней есть описание
объектно-ориентированных программ:</p>
<blockquote>
<p>Объектно-ориентированные программы состоят из объектов. <em>Объект</em> является пакетом
состоящих из данных и процедур, которые работают с этими данными. Эти процедуры
обычно называются <em>методами</em> или <em>операциями</em>.</p>
</blockquote>
<p>В соответствии с этим определением Rust является объектно-ориентированным ЯП:
структуры и перечисления имеют данные и блок <code>impl</code>, которые предоставляет методы
для структур и перечислений. Хотя структуры и перечисления имеющие методы
не <em>называются</em> объектами, они обеспечивают одинаковую функциональность, которую
предоставляют объекты, используя определение объектов в книге банды четырёх.</p>
<a class="header" href="print.html#aСкрытие-деталей-реализации" id="aСкрытие-деталей-реализации"><h3>Скрытие деталей реализации</h3></a>
<p>Другим аспектом, обычно связанным с объектно-ориентированным программированием,
является идея <em>инкапсуляции</em>: детали реализации объекта недоступны для кодирования
с использованием этого объекта. Единственный способ взаимодействия с объектом -
через публичный API, который предлагает объект; код с использованием объекта не
должен охватить внутренние объекты объекта и напрямую изменить данные или поведение.
Инкапсуляция позволяет изменять и реорганизовывать внутренние содержание объекта
без необходимо изменить код, который использует объект.</p>
<p>Как мы обсуждали в главе 7, мы можем использовать ключевое слово <code>pub</code>, чтобы решить,
какие модули, типы, функции и методы в нашем коде могут быть общедоступными. По
умолчанию ни к каким элементам нет доступа. Например, мы можем определить структуру
<code>AveragedCollection</code>, которая имеет поле, содержащее вектор значений<code>i32</code>.
Структура может также иметь поле, которое знает среднее значение в векторе
так что всякий раз, когда кто-либо хочет знать среднее значение значений,
имеет в своем векторе, нам не нужно его вычислять по требованию. <code>AveragedCollection</code>
будет кэшировать рассчитанное среднее значение для нас. В коде 17-1 приведено
определение структура <code>AveragedCollection</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
#}</code></pre></pre>
<p><span class = "caption"> код 17-1: Структура <code>AveragedCollection</code>, которая
содержит список целых чисел и среднее значение элементов в коллекция. &lt;/ SPAN&gt;</p>
<p>Обратите внимание, что структура помечена <code>pub</code>, так что другой код может использовать
её, но поля внутри структуры остаются закрытыми. Это важно, т.к.мы хотим гарантировать,
что всякий раз, когда значение добавляется или удаляется из списка, мы также
обновляем среднее значение. Мы делаем это, применяя методы <code>add</code>,<code>remove</code> и
<code>average</code> в структуре, как показано в листинге 17-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct AveragedCollection {
#     list: Vec&lt;i32&gt;,
#     average: f64,
# }
impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
#}</code></pre></pre>
<p><span class="caption">листинг 17-2: реализации открытых методов
<code>add</code>, <code>remove</code> и <code>average</code> в структуре <code>AveragedCollection</code></span></p>
<p>Открытые методы <code>add</code>,<code>remove</code> и <code>average</code> являются единственным способом изменения
экземпляра <code>AveragedCollection</code>. Когда элемент добавляется в <code>list</code>, используя
<code>add</code>, или удаляется с помощью метода<code>remove</code>, коды этих методов вызывают закрытый
метод <code>update_average</code>, который позаботится об обновлении поля <code>average</code>.
Поскольку поля <code>list</code> и <code>average</code> являются закрытыми, нет никакого способа, чтобы
внешний код добавлял или удалял элементы в поле <code>list</code>, которое может привести к
тому, что поле <code>average</code> перестанет содержать актуальные данные. Метод <code>average</code>
возвращает значение поля <code>average</code>, что позволяет внешнему коду прочитать <code>average</code>,
но не изменять его.</p>
<p>Поскольку мы инкапсулировали детали реализации <code>AveragedCollection</code>, мы можем легко
изменить такие аспекты, как структура данных в будущем. Например, мы могли бы
использовать <code>HashSet</code> вместо<code>Vec</code> для поля <code>list</code>. Т.к. методы <code>add</code>,<code>remove</code>
и <code>average</code> общедоступны, код, использующий <code>AveragedCollection</code>, не нуждается в
изменении. Такого у нас не получится, если мы сделали бы доступным поле <code>list</code>
внешнему коду: <code>HashSet</code> и<code>Vec</code> имеют разные методы для добавления и удаления
элементов, поэтому внешний код, вероятно, должен будет измениться, если он изменяет
<code>list</code> непосредственно.</p>
<p>Если инкапсуляция является обязательным аспектом для определения языка, как
объектно-ориентированного, то Rust соответствует этому требованию. Модификатор
доступа <code>pub</code>  позволяет инкапсулировать детали реализации.</p>
<a class="header" href="print.html#aНаследование-как-система-типов-и-как-способ-совместно-использования-кода" id="aНаследование-как-система-типов-и-как-способ-совместно-использования-кода"><h3>Наследование, как система типов и как способ совместно использования кода</h3></a>
<p><em>Наследование</em> - это механизм, который предоставляют некоторые языки программирования.
Объект может быть определен, чтобы наследовать от определения другого объекта,
тем самым получив данные и поведение родительского объекта без необходимости их
повторного определения. Наследование является характеристикой объектно-ориентированного
языка программирования.</p>
<p>Если язык должен реализовать наследование, чтобы быть объектно-ориентированным
языком программирования, тогда Rust не является объектно-ориентированным. Не
существует способа определить структуру, которая бы наследовала поля и методы от
другой структуры. Однако, если вы привыкли использовать наследование, в Rust есть
альтернативные решения.</p>
<p>У наследования есть два преимущества. Первое - это повторное использование кода.
Реализации методов по умолчанию в типаже (листинг 10-15) даёт возможность использовать
его в реализациях. Это похоже на то, как функционал родительского класса, наследуется
его дочерними классами. Перезапись методов по умолчанию в реализациях также возможна.</p>
<p>Вторая причина использования наследования в системе типов - сообщить о том, что
дочерний тип может быть использован в том же месте, что и родительский. Эта функциональная
возможность также называется <em>полиморфизм</em>. Это когда множество объектов можеть
быть использованы если они имеют соответствующую форму.</p>
<!-- PROD: START BOX -->
<blockquote>
<p>В то время как многие люди используют &quot;полиморфизм&quot; для описания наследования,
это на самом деле определенный вид полиморфизма, называемая &quot;полиморфизмом подтипа&quot;.
Существуют другие формы. Использование обобщенного параметра в типаже, является
также полиморфизмом, в частности «параметрический полиморфизм». Точный
детали между различными видами полиморфизма здесь не имеют решающего значения,
так что не беспокойтесь о деталях: просто знайте, что Rust имеет несколько
функции, связанные с полиморфизмом, в отличие от многих языков ООП.</p>
</blockquote>
<!-- PROD: END BOX -->
<p>Чтобы поддерживать такой тип шаблона, у Rust есть <em>типажи-объекты</em>.
Любое значение может подойти, если оно реализует определённый шаблон.</p>
<p>Наследование в последнее время не является излюбленным приёмом в различных языках
программирования. Для повторного использования кода может понадобиться
больше кода для совместного использования, чем вам действительно нужно. Подклассы
не должны всегда используют все характеристики своего родительского класса, но
наследование означает подкласс получает все данные и поведение своего родителя.
Это может сделать дизайн программы менее гибкий и создает возможность вызова методов
в подклассах, которые не имеют смысла или вызывают ошибки, поскольку методы не
применяются к подклассу, но должны быть унаследованы от родительского класса.
К тому же, некоторые языки позволяют только наследовать подкласс только от одного
класса. Эти ограничения понижают гибкость дизайна программ.</p>
<p>Поэтому Rust выбрал использования типажей-объектов наследованию. В следующей секции
вы узнаете, как типажи-объекты реализуют полиморфизм.</p>
<a class="header" href="print.html#aОбъекты-типажи--trait-objects-for-using-values-of-different-types" id="aОбъекты-типажи--trait-objects-for-using-values-of-different-types"><h2>Объекты-типажи  Trait Objects for Using Values of Different Types</h2></a>
<p>В Главе 8 мы говорили о том что, ограничением векторов - хранение данных только
одного типа. В примере 8-1 мы демонстрировали, как перечисления могут хранить
разные типы данных внутри каждого значения. Вектор может хранить данные такого
перечисления. Такая конструкция удобна в том случае, когда необходима структура
состоящая из фиксированного набора данных.</p>
<!-- The code example I want to reference did not have a listing number; it's
the one with SpreadsheetCell. I will go back and add Listing 8-1 next time I
get Chapter 8 for editing. /Carol -->
<p>В некоторых случаях возникает необходимость иметь набор типов, которые можно было
бы расширять пользователям библиотеки. Например, множество графических библиотек
имеют интерфейсы, благодаря которым создаваемые на их основе новые компоненты
могут становиться частью системы, расширяя её возможности. Например, интерфейс
может иметь метод <code>draw</code> и каждый новый элемент, которые его реализует может
быть использован для рисования. Мы рассмотрим как эту концепцию можно реализовать
в Rust.</p>
<p>При создании графической библиотеки (назовём её <code>rust_gui</code>), мы не можем заранее
знать всех типов которые пользователи библиотеки хотят создать. Мы не можем создать
<code>enum</code>, которая содержала бы все возможные типы. Особенностью графической библиотеки
в том, что предоставив интерфейсы нельзя будет заранее знать, какой код будет выполнен
при вызове методов (например, при вызове метода <code>draw</code>).</p>
<p>В языках программирования, в которых реализовано наследование эту задачу можно
было бы решить созданием абстрактного класса <code>Component</code>, который бы имел
виртуальный метод <code>draw</code>. Все реализовавшие этот класс имели бы свою реализацию
метода. Использующий код данных методов относился бы ко всем реализациям класса
<code>Component</code>, как к этому классу (используя только функциональные возможности
предоставляемые этим классом).</p>
<a class="header" href="print.html#aОпределение-типажа-с-виртуальным-общим-методом-поведением" id="aОпределение-типажа-с-виртуальным-общим-методом-поведением"><h3>Определение типажа с виртуальным (общим) методом (поведением)</h3></a>
<p>В Rust мы можем определить типаж, который мы назовем «Draw». Он будет иметь один
виртуальный метод (метод требующий реализации) <code>draw</code>. Далее, мы можем создать
вектор, который содержит список указателей (<code>&amp;</code>-ссылок или умных указателей <code>Box&lt;T&gt;</code>).
Мы поговорим о причинах, по которым объекты-типажи должны быть внутри указателями
в главе 19.</p>
<p>Мы упоминали, что мы не можем называть структуры и перечисления &quot;объектами&quot;, т.к.
они имеют особую природу (не похожую на объекты в других языках программирования).
В структурах и перечислениях объявление полей и поведений разделены. Объекты-типажи
больше напоминают объекты (ООП-языков), в том смысле, что они объединяют данные,
составленные из указателя на конкретный объект, с поведением методов, определенных в признаке.
В тоже время типажи не могут хранить данные. Их цель предоставлять поведение.</p>
<p>Типаж определяет поведение, которое необходимо в определённой ситуации. Далее,
вы можем использовать типаж-объект, где мы хотели бы использовать конкретный тип
или обобщенный тип. Система типов Rust предполагает, что реализации типажей имеют
соответствующий функционал. В примере 17-3 показано, как определить типаж <code>Draw</code>
содержащий метод <code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Draw {
    fn draw(&amp;self);
}
#}</code></pre></pre>
<p><span class="caption">код 17-3: определение типажа <code>Draw</code> trait</span></p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Думаю, что тут всё понятно. Далее, добавим кое-что новое. В коде 17-4 в структуре
<code>Screen</code>, которая содержит поле <code>components</code>, которое является вектором, содержащее
данные типа <code>Box&lt;Draw&gt;</code>. <code>Box&lt;Draw&gt;</code> является объектом-типажом, т.к. в обёртке
<code>Box&lt;T&gt;</code> может содержаться любое значение реализовавшее типаж <code>Draw</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
#}</code></pre></pre>
<p><span class="caption">код 17-4: определение структуры <code>Screen</code> с полем
<code>components</code>, который является вектором типажа-объектов, которые реализуют типаж
<code>Draw</code></span></p>
<p>В структуре <code>Screen</code>, мы определим метод <code>run</code>, который будет вызывать метод <code>draw</code>
каждого элемента вектора <code>components</code> (17-5):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
# pub struct Screen {
#     pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
# }
#
impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-5: реализация метода <code>run</code> в <code>Screen</code>, который вызывает
метод <code>draw</code> каждого элемента вектора</span></p>
<p>Это решение отличается от использования обобщенного параметра и типажа. Обобщенный
параметр может быть использовать только для какого-то конкретного типа, в то время
как типаж объекта может быть использован для любого конкретного типа. Рассмотрим
пример совметного использования обобщенного типа и объекта-типажа (17-6):</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-6: альтернативная реализация структуры <code>Screen</code> и
метода <code>run</code>, используя обобщенный объект-типаж </span></p>
<p>Это решение вводит ограничение для экземпляров структуры <code>Screen</code> (вектор может
хранить только однотипные экземпляры, реализовавшие  типаж <code>Draw</code> - например, только
<code>Button</code> или только <code>TextField</code>). Если у вас будут только однородные коллекции,
использование дженериков и объектов-типажей предпочтительнее, поскольку экземпляры
будут мономорфны.</p>
<p>В отличие от предыдущего примера, один экземпляр <code>Screen</code> может хранить вектор,
содержащий или <code>Box&lt;Button&gt;</code> или <code>Box&lt;TextField&gt;</code>. Далее мы рассмотрим как это работает
подробнее, а также поговорим о вопросах производительности во время выполнения программы.</p>
<a class="header" href="print.html#aРеализации-типажа" id="aРеализации-типажа"><h3>Реализации типажа</h3></a>
<p>Теперь добавим реализации типажа <code>Draw</code> в наш код. Наши реализации не будут содержать
кода внутри методов (для простоты) 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub trait Draw {
#     fn draw(&amp;self);
# }
#
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // Code to actually draw a button
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-7: структура <code>Button</code> реализует типаж <code>Draw</code></span></p>
<p>Поля <code>width</code>, <code>height</code> и <code>label</code> структуры  <code>Button</code> будут отличаться от, например,
полей другой структуры <code>TextField</code>, которая может иметь поля <code>width</code>, <code>height</code>,
<code>label</code> и <code>placeholder</code>. Каждая реализация также имеет свою версию метода <code>draw</code>.
Дополнительно структура <code>Button</code> может иметь ещё одни блок <code>impl</code>, содержащие
дополнительные методы. Этим методы может не иметь любая другая реализация <code>Draw</code>.
Во внешней библиотеке также можно реализовать типаж <code>Draw</code> (17-8):</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rust_gui;
use rust_gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // Code to actually draw a select box
    }
}
</code></pre>
<p><span class="caption">код 17-8: использование внешнего контейнера <code>rust_gui</code> и
реализация типажа <code>Draw</code> структурой <code>SelectBox</code></span></p>
<p>Пользователь нашей библиотеки может реализовать функцию <code>main</code> и в ней создать
экземпляр <code>Screen</code> и добавить экземпляры структур <code>SelectBox</code> и <code>Button</code> в вектор
с помощью умного указателя <code>Box&lt;T&gt;</code>. В коде можно вызывать метод <code>run</code> структуры
<code>Screen</code>, который в свою очередь вызовет метод <code>draw</code> в каждом компоненте вектора.
Код 17-9 демонстрирует реализацию:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use rust_gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">код 17-9: использование объектов-типаже для хранения значений
различных типов, которые реализовали типаж</span></p>
<p>Несмотря на то, что мы не знали, что кто-то однажды добавит тип <code>SelectBox</code>,
наша реализация <code>Screen</code> смогла работать с <code>SelectBox</code> и нарисовать её,
т.к. <code>SelectBox</code> реализует тип<code>Draw</code>, что означает, что он реализует
метод <code>draw</code>.</p>
<p>Это демонстрация неявной типизации (т.н. <em>duck typing</em>). В реализации метода <code>run</code>
структуры <code>Screen</code> (17-5) не нужно знать тип конкретного элемента. Необходимо только
знать, что этот элемент имеет метод <code>draw</code>.</p>
<p>Плюсом реализации подобного решения является отсутствие необходимости проверять
начие реализации метода во время работы программы. Код не будет скомпилирован, если
какой-либо элемент вектора не реализует типаж.</p>
<p>Например, код (17-10) демонстрирует, что случится если мын попытаемся добавить
<code>String</code> в качестве компонента вектора:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rust_gui;
use rust_gui::Draw;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">код 17-10: попытка использования типа, который не реализовал
типаж объекта-типажа</span></p>
<p>Мы получили ошибку, т.к. <code>String</code> не реализовал типаж <code>Draw</code>:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: Draw` is not satisfied
  --&gt;
   |
 4 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `Draw`
</code></pre>
<a class="header" href="print.html#aТипажи-объектов-выполняют-динамическую-диспетчеризацию-связывание" id="aТипажи-объектов-выполняют-динамическую-диспетчеризацию-связывание"><h3>Типажи-объектов выполняют динамическую диспетчеризацию (связывание)</h3></a>
<p>Напомним что в главе 10, когда мы обсуждали процесс мономорфизации, что
компилятор выполняет, когда мы используем типажи для ограничения в дженероках:
компилятор создаёт реализации для конкретных типов, которые использует в месте
использования такого обобщенного параметра. Т.е. компилятор выполняет
<em>статическую связывание</em>. Такой код работает очень быстро.</p>
<p>Когда же мы используем типажи-объекты, компилятор не может выполнить мономорфизацию,
т.к. мы не знаемвсех типов, которые могут быть использованы в коде, Rust отслеживает
код, который может использоваться при вызове метода и выполнят это работу во время
выполнения программы. Это приводик к замедлению работы программы.</p>
<p>Динамическая диспечеризация также предостерегает компилятор выбирать встроенный
код метода, который предотвращает некоторые оптимизации. Благодаря чему мы получили
дополнительную гибкость в коде.</p>
<a class="header" href="print.html#aБезопасность-типажей-объектов" id="aБезопасность-типажей-объектов"><h3>Безопасность типажей-объектов</h3></a>
<!-- Liz: we're conflicted on including this section. Not being able to use a
trait as a trait object because of object safety is something that
beginner/intermediate Rust developers run into sometimes, but explaining it
fully is long and complicated. Should we just cut this whole section? Leave it
(and finish the explanation of how to fix the error at the end)? Shorten it to
a quick caveat, that just says something like "Some traits can't be trait
objects. Clone is an example of one. You'll get errors that will let you know
if a trait can't be a trait object, look up object safety if you're interested
in the details"? Thanks! /Carol -->
<p>Не все типажи могут быть типажами-объектами. Только безопасные типажи-объекты могут
ими быть. Чтобы быть безопасным типаж должен соответствовать следующим условиям:</p>
<ul>
<li>The trait does not require <code>Self</code> to be <code>Sized</code></li>
<li>все методы типажа являются безопасными.</li>
</ul>
<p><code>Self</code> - это ключевое слово, которое является псевдонимом типа, который реализовал
типаж или методы. <code>Sized</code> является типажём-маркером, таким как <code>Send</code> и <code>Sync</code>.
<code>Sized</code> автоматически реализуется в типах, которые имеют известный тип во время
компиляции (такие как <code>i32</code> и ссылки). Типы, которые не имеют известный размер,
включая срезы (<code>[T]</code>) и объекты-типажи.
<code>Sized</code> является неявным типов всех обобщенных параметров по умолчанию. Большинство
полезных операций в Rust требуют от использованного типа реализовать <code>Sized</code>.
Если нам необходимо использовать в срезах типажи, то мы должны явным образом указать
это с помощью <code>T: ?Sized</code>.</p>
<p>Типажи имеют опцию по умолчанию <code>Self: ?Sized</code>. Это значит, что они могут быть
реализованы в типах, которым могут быть, а могут не быть <code>Sized</code>.  Например, если
мы создадим типаж <code>Foo</code>, который реализовывает <code>Self: ?Sized</code>, то он выглядит так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo: Sized {
    fn some_method(&amp;self);
}
#}</code></pre></pre>
<p>Теперь типаж <code>Sized</code> является родительским типажом (<em>supertrait</em>) <code>Foo</code>. Это значит,
что <code>Foo</code> требует от своих реализаций реализацию методов описанных в декларации
<code>Foo</code> (т.е. <code>Self</code>) были также <code>Sized</code>. Мы поговорим о <em>supertrait</em> в Главе 19.</p>
<p><code>Foo</code> требует чтобы <code>Self</code> реализовал <code>Sized</code>. В тоже время <code>Self</code> нельзя использовать
в типажах объектов.</p>
<p><code>Foo</code> requires <code>Self</code> to be <code>Sized</code>, and therefore is not allowed to be used in
a trait object like <code>Box&lt;Foo&gt;</code>. This is because it would be impossible to implement
the trait <code>Foo</code> for a trait object like <code>Box&lt;Foo&gt;</code>: trait objects aren’t sized,
but <code>Foo</code> requires <code>Self</code> to be <code>Sized</code>. A type can’t be both sized and unsized
at the same time!</p>
<p>For the second object safety requirement that says all of a trait’s methods
must be object safe, a method is object safe if either:</p>
<ul>
<li>It requires <code>Self</code> to be <code>Sized</code> or</li>
<li>It meets all three of the following:
<ul>
<li>It must not have any generic type parameters</li>
<li>Its first argument must be of type <code>Self</code> or a type that dereferences to
the Self type (that is, it must be a method rather than an associated
function and have <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first argument)</li>
<li>It must not use <code>Self</code> anywhere else in the signature except for the
first argument</li>
</ul>
</li>
</ul>
<p>Those rules are a bit formal, but think of it this way: if your method requires
the concrete <code>Self</code> type somewhere in its signature, but an object forgets the
exact type that it is, there’s no way that the method can use the original
concrete type that it’s forgotten. Same with generic type parameters that are
filled in with concrete type parameters when the trait is used: the concrete
types become part of the type that implements the trait. When the type is
erased by the use of a trait object, there’s no way to know what types to fill
in the generic type parameters with.</p>
<p>Пример типажа, у которого методы не безопасны - это типаж стандартной библиотеки
<code>Clone</code>. Реализация метода <code>clone</code> в <code>Clone</code> выглядит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
#}</code></pre></pre>
<p>Типаж <code>String</code> реализует <code>Clone</code> и вызывает метод  <code>clone</code> вы получаете ссылку на
экземпляр <code>String</code>.
<code>String</code> implements the <code>Clone</code> trait, and when we call the <code>clone</code> method on
an instance of <code>String</code> we get back an instance of <code>String</code>. Similarly, if we
call <code>clone</code> on an instance of <code>Vec</code>, we get back an instance of <code>Vec</code>. The
signature of <code>clone</code> needs to know what type will stand in for <code>Self</code>, since
that’s the return type.</p>
<p>If we try to implement <code>Clone</code> on a trait like the <code>Draw</code> trait from Listing
17-3, we wouldn’t know whether <code>Self</code> would end up being a <code>Button</code>, a
<code>SelectBox</code>, or some other type that will implement the <code>Draw</code> trait in the
future.</p>
<p>Компилятор сообщит вам, если вы попытаетесь нарушить правила. Например, такой код не
скомпилируется:</p>
<pre><code class="language-rust ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<p>Мы получим ошибку:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt;
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
  made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<!-- If we are including this section, we would explain how to fix this
problem. It involves adding another trait and implementing Clone manually for
that trait. Because this section is getting long, I stopped because it feels
like we're off in the weeds with an esoteric detail that not everyone will need
to know about. /Carol -->
<a class="header" href="print.html#aРеализация-ООП-шаблона-проектирования" id="aРеализация-ООП-шаблона-проектирования"><h2>Реализация ООП шаблона проектирования</h2></a>
<p>Давайте рассмотрим пример шаблона &quot;Состояние&quot; и как его использовать в Rust.
Шаблон <em>Состояние</em> - это когда на поведение влияет внутренние значения. Внутреннее
состояние представлено набором объектов, наследующих общую функциональность
(мы будем использовать структуры и типажи поскольку Rust не имеет объектов и
наследования). Каждый объект состояния ответственный за свое поведение и правила
изменения своего состояния. Значение, которое содержит один из этих состояний, не знает
что-либо о различном поведении других состояний или о том, когда происходит переход
между состояниями. В будущем, когда меняются требования, нам не придется менять
код значения, содержащего состояние или код, который использует значение. Что ж
нужно только обновить код внутри одного из объектов состояния, чтобы изменить его
правила или, возможно, добавить больше объектов состояния.</p>
<p>Чтобы изучить эту идею, мы собираемся внедрить рабочий процесс в блоге с помощью
последовательности шагов. Мы хотим реализовать последовательность рабочих процессов:</p>
<ol>
<li>При создания поста создаётся пустой черновик.</li>
<li>Далее мы запрашиваем проверку черновика.</li>
<li>После проверки происходит публикация.</li>
<li>После публикации становиться доступна опция публикации содержания.</li>
</ol>
<p>Любые другие попытки изменения поста не должны иметь какого-либо эффекта на его
внутреннее содержание. Например, если мы попытаемся перевести пост из состояния
&quot;черновик&quot; в состояние &quot;принят&quot; без проведения проверки (состояние &quot;проверка&quot;),
то пост останется в состоянии &quot;черновик&quot;.</p>
<p>Код 17-11 показывает последовательность рабочий цикл публикации поста. Этот пример
использования мы и собираемся реализовать в библиотечном контейнере <code>blog</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">код 17-11: демонстрация необходимого поведения</span></p>
<p>Мы хотим создать новый черновик постав в блоге с помощью метода <code>Post::new</code>. Далее
мы хотим добавить текст. Если мы попытаемся напечатать внесённый текст, мы это
не сможем сделать, т.к. пост является черновиком. Мы добавили <code>assert_eq!</code> в целях
демонстрации.</p>
<p>Далее, мы хотим перевести пост в состояние &quot;проверка&quot;. После получения статуса
&quot;проверено&quot; пост можно будет опубликовать. Это значит, что можно будет получить
текст с помощью метода <code>content</code>.</p>
<p>Обратите внимание, что мы взаимодействуем только с типом <code>Post</code>. Внутри данного
типа происходит изменения состояния (черновик, ожидание проверки, опубликован).
Состояния меняются посредством вызова методов экземпляра <code>Post</code>. Мы не можем изменять
состояние непосредственно. Это также значит, что мы не можем совершить ошибки в
изменении последовательности получения данным экземпляром определенного состояния.</p>
<a class="header" href="print.html#aОпределение-post-и--создание-нового-экземпляра-при-этом-экземпляр-будет-находится" id="aОпределение-post-и--создание-нового-экземпляра-при-этом-экземпляр-будет-находится"><h3>Определение <code>Post</code> и  создание нового экземпляра (при этом экземпляр будет находится</h3></a>
<p>в состоянии &quot;черновик&quot;</p>
<p>Приступим к реализации библиотеки! Мы знаем техническое задание. Надо напечатать
содержание структуры <code>Post</code>, которое содержит какой-то текст. Начнём с определение
структуры и создадим функцию <code>new</code> для создания экземпляра <code>Post</code> (код 17-12).
Мы также реализуем закрытый типаж <code>State</code>. <code>Post</code> будет содержать типажный объект
<code>Box&lt;State&gt;</code> внутри <code>Option</code> внутри закрытого поля <code>state</code>. Вы увидите почему
использование перечисления <code>Option</code> необходимо. Типаж <code>State</code> определяет все
поведения состояния: &quot;черновик&quot;(<code>Draft</code>), &quot;ожидание проверки&quot; (<code>PendingReview</code>)
и &quot;опубликован&quot; (<code>Published</code>) (все они реализуют типаж) <code>State</code>. Сейчас типаж не
имеет методов и мы начинаем с определения состояния &quot;черновик&quot;:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    state: Option&lt;Box&lt;State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
#}</code></pre></pre>
<p><span class="caption">код 17-12: определение структуры <code>Post</code> и функции <code>new</code>,
которая создаёт новый экземпляр <code>Post</code>. Также создание типажа <code>State</code>и структуры
<code>Draft</code>, которая реализует <code>State</code></span></p>
<p>Когда мы создаём новый экземпляр <code>Post</code> мы устанавливаем значение в поле <code>state</code>.
Оно будет содержать <code>Some</code> содержащее умный указатель <code>Box</code>, который указывает на
экземпляр структуры <code>Draft</code>. Таким образом мы релизуем первоначальную концепцию.
Т.к. поле <code>state</code> является закрытым нет другой возможности создвать экземпляр
<code>Post</code> с каким-либо другим состоянием.</p>
<a class="header" href="print.html#aСохранение-текста-поста" id="aСохранение-текста-поста"><h3>Сохранение текста поста</h3></a>
<p>В функции <code>Post::new</code> мы установили значение поля <code>content</code> пустую <code>String</code>.</p>
<p>В коде 17-11 мы показали, что мы можем вызвать метод <code>add_text</code> и передать ей
<code>&amp;str</code>, для того чтобы добавить текс в содержание поста. Мы реализуем этот метод
для того, чтобы защитить переменную <code>content</code> от возможности внешнего изменения.
Мы хотим, чтобы был котроль над содержанием данной переменной.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-13: реализация метода <code>add_text</code> для добавления текста
в <code>content</code></span></p>
<p>Функция <code>add_text</code> получает изменяемую ссылку на <code>self</code>, т.е. мы можем изменять
экземпляр <code>Post</code>. Внутри мы вызываем метод  <code>push_str</code> <code>String</code>. Этот функционал
не является составной частью шаблона влияющего на поведение.</p>
<a class="header" href="print.html#aСодержание-черновика-пустое" id="aСодержание-черновика-пустое"><h3>Содержание черновика пустое</h3></a>
<p>После того, как мы вызвали метод <code>add_text</code> и добавили содержание в наше сообщение,
мы всёже хотим чтобы метод <code>content</code> возвращал пустую строку. Реализуем этот метод:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-14: добавление реализации метода  <code>content</code>, который
всегда возвращает пустое значение</span></p>
<p>Пока всё до стоки 8 кода 17-11 реализовано.</p>
<a class="header" href="print.html#aзапрос-проверки-сделанных-изменений" id="aзапрос-проверки-сделанных-изменений"><h3>запрос проверки сделанных изменений</h3></a>
<p>Далее запросим проверку содержания сообщения, для того, чтобы изменить состояние
с <code>Draft</code> на <code>PendingReview</code>. Для этого мы хотим, чтобы <code>Post</code> имел открытый метод
<code>request_review</code>, который получает изменяемую ссылку на <code>self</code>. Далее мы вызываем
закрытый метод <code>request_review</code> у состояния и этот метод вернёт новое состояние.
Для того, чтобы удалить старое состояние, метод <code>request_review</code> должен получить
владение значением состояния. Для этого нам понадобиться перечисление <code>Option</code>.
Мы получим значение из <code>Some</code> и вернём <code>None</code>. Далее мы установим значение в поле
<code>state</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-15: реализация методов  <code>request_review</code> в типажах
<code>Post</code> и <code>State</code></span></p>
<p>Мы добавили метод <code>request_review</code> в типаж <code>State</code>. Теперь всем реализации, типажа
должны реализовать метод <code>request_review</code>.
Обратите внимение, что вместо <code>self</code>, <code>&amp;self</code> или  <code>&amp;mut self</code> первым параметром
метода мы имеем <code>self: Box&lt;Self&gt;</code>. Это означает, что метод считается действительным
(правильным) если вызывается из <code>Box</code> содержащего данный тип. Также мы видим,
что происходит получение владения <code>Box&lt;Self&gt;</code>, т.к. нам необходимо изменить состояние.</p>
<p>Также мы видим реализацию метода <code>request_review</code> в структуре <code>Draft</code>. Метод
возвращает экземпляр структуры <code>PendingReview</code>, которая является типом данных
реализовавшим <code>State</code>.</p>
<p>Мы уже видим удобство использование данного шаблона. Неважно, какое состояние
сейчас у сообщения. У каждого экземпляра состояния можно вызвать метод <code>request_review</code>.</p>
<p>Мы реализовали весь функционал до 11 строки кода 17-11!</p>
<a class="header" href="print.html#aУлучшим-код-изменение-сообщения-при-изменение-состояния" id="aУлучшим-код-изменение-сообщения-при-изменение-состояния"><h3>Улучшим код изменение сообщения при изменение состояния</h3></a>
<p>Метод <code>approve</code> в  <code>Post</code> похож на <code>request_review</code> - он устанавливает состояние
на подтвержденное. Нам надо добавить метод <code>approve</code> в типаж <code>State</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         Box::new(PendingReview {})
#     }
#
    // ...snip...
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
#         self
#     }
#
    // ...snip...
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-16: реализация метода <code>approve</code> типажей <code>Post</code> и <code>State</code>
</span></p>
<p>Внесём изменение в метод <code>content</code>: мы хотим получать содержание, если состояние
<code>Published</code> иначе возвращаете пустую строку:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait State {
#     fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
# }
# pub struct Post {
#     state: Option&lt;Box&lt;State&gt;&gt;,
#     content: String,
# }
#
impl Post {
    // ...snip...
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // ...snip...
}
#}</code></pre></pre>
<p><span class="caption">код 17-17: обновление метода <code>content</code></span></p>
<p>Мы взывали метод <code>as_ref</code>, т.к. хотим получить ссылку на значение внутри. Далее,
мы вызываем метод <code>unwrap</code>.</p>
<p>Добавим реализацию по умолчанию в типаж <code>State</code>. В структуре <code>Published</code> мы
перезапишем метод <code>content</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String
# }
trait State {
    // ...snip...
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// ...snip...
struct Published {}

impl State for Published {
    // ...snip...
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-18: добавление метода <code>content</code> к типажу <code>State</code>
</span></p>
<a class="header" href="print.html#aНедостатки-шаблона-Состояние" id="aНедостатки-шаблона-Состояние"><h3>Недостатки шаблона &quot;Состояние&quot;</h3></a>
<p>Мы показали, что Rust может реализовать ООП шаблон &quot;Состояние&quot; для того чтобы хранить
различные поведения, которые публикация имеет в зависимости от внутреннего состояния.
Методы структуры <code>Post</code> ничего не знают о различных вариантах поведения. Вся логика
шаблон сосредоточена в типаже  <code>State</code> и его реализациях.</p>
<p>Могут быть альтернативные решения. Например, выражение <code>match</code> в методе структуры
<code>Post</code> выбирает нужное поведение. Или даже в коде, который использует экземпляр
<code>Post</code> (<code>main</code>) проверяет состояние статьи и изменяет поведение. Чем больше будет
состояний, тем сложнее будет код.</p>
<a class="header" href="print.html#aУпрощаем-решение" id="aУпрощаем-решение"><h4>Упрощаем решение</h4></a>
<p>Мы собираемся показать, как немного переосмыслить шаблон состояния, чтобы получить
другое, более ясное решение.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
       &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-19: <code>Post</code> с методом <code>content</code> <code>DraftPost</code> без метода
<code>content</code></span></p>
<a class="header" href="print.html#aРеализация-превращений-в-другие-типы" id="aРеализация-превращений-в-другие-типы"><h4>Реализация превращений в другие типы</h4></a>
<p>Продолжим доработку нашего нового решения:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct Post {
#     content: String,
# }
#
# pub struct DraftPost {
#     content: String,
# }
#
impl DraftPost {
    // ...snip...

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">код 17-20:  <code>PendingReviewPost</code> создаётся с помощью метода
<code>request_review</code> в <code>DraftPost</code>. Метод <code>approve</code> создаёт <code>Post</code></span></p>
<p>Продолжаем улучшать наш код.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">код 17-21: изменения в <code>main</code> для использования новой
версии кода библиотеки</span></p>
<p>Rust предлагает более простые решения проблемы, которые возникают при проектировании
шаблонных решений.</p>
<a class="header" href="print.html#aИтоги-12" id="aИтоги-12"><h2>Итоги</h2></a>
<p>Не важно, что вы думаете о объектно-ориентированных возможностях Rust. После прочтения
данной главы, вы теперь выдите, что с помощью объектов-типажей мы можем реализовать
опции, которые предоставляет ООП. Динамическое связывание может дать гибкость
в коде. ООП шаблон не всегда является лучшим решением, а является только лишь
иллюстрацией его возможностей.</p>
<p>Далее мы рассмотрим другую опцию Rust - шаблоны. Рассмотрим этот функционала подробнее.</p>
<a class="header" href="print.html#aШаблоны-соответствуют-структуре-значений" id="aШаблоны-соответствуют-структуре-значений"><h1>Шаблоны соответствуют структуре значений</h1></a>
<p>Шаблоны - это особый синтаксис в Rust для соответствия структуре наших типов.
Простых и сложных. Образец состоит из некоторой комбинации литералов;
неструктурированных массивов, перечислений, структур или кортежей; переменных,
подстановочных шаблонов заполнителей. Эти части описывают «форму» данных, с
которыми мы работаем.</p>
<p>Мы используем шаблон для получения значения и сравнения его с шаблоном. Если
шаблон соответствует значению, мы делаем что-то со значениями. Напомним,
В главе 6, когда мы обсуждали выражение <code>match</code>, которое использует шаблоны, такие
как машина для сортировки монет.</p>
<p>В этой главе мы постараемся освятить все темы связанные с шаблонами. Мы расскажем
где можно использовать шаблоны (их место в языковых конструкциях). Мы расскажем
о разнице между различными видами шаблонов и вариациях синтаксиса.</p>
<a class="header" href="print.html#aМеста-использования-шаблонов" id="aМеста-использования-шаблонов"><h2>Места использования шаблонов</h2></a>
<p>Шаблоны можно использовать в различных частях синтаксических конструкций. Вы уже
использовали их даже не осознавая этого. В этой секции мы расскажем о местах, где
можно использовать шаблоны.
Patterns pop up in a number of places in Rust. You’ve been using them a lot
without realizing it! This section is a reference to all the places where
patterns are valid.</p>
<a class="header" href="print.html#aРукава-match" id="aРукава-match"><h3>Рукава <code>match</code></h3></a>
<p>Как мы уже обсуждали в главе 6, основным местом, где шаблоны используются - это
рукава выражений <code>match</code>. Формально, выражения <code>match</code> определятся как объединение
ключевого слова <code>match</code>, значения которое будет сравниваться и одно или несколько
рукавов, которые составляют шаблон и выражение, которое будет выполнено, если
значение будет соответствовать шаблону:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<a class="header" href="print.html#aИсчерпываемость-и-шаблон-по-умолчанию-_" id="aИсчерпываемость-и-шаблон-по-умолчанию-_"><h4>Исчерпываемость и шаблон по умолчанию <code>_</code></h4></a>
<p>Выражения <code>match</code> должны охватывать все возможные варианты значения.</p>
<p>Есть специальный символ <code>_</code>. Его надо располагать последним в списке. Этот шаблон
выбирает все остальные варианты. Этот шаблон удобно использовать чтобы игнорировать
все остальные варианты.</p>
<a class="header" href="print.html#aВыражения-if-let" id="aВыражения-if-let"><h3>Выражения <code>if let</code></h3></a>
<p>Мы уже обсуждали выражение <code>if let</code> в главер 6. Мы использовали компактную замену
<code>match</code> для поиска по одному варианту. <code>if let</code> также может иметь <code>else</code> для
выполнения блока кода, если условие поиске не выполнено.</p>
<p>Код 18-1 показывает как можно совместно использовать <code>if let</code>, <code>else if</code> и
<code>else if let</code>. Следующий код демонстрирует серию проверок цвета фона. Для этой
цели мы создали имитацию ввода данных пользователем. Если пользователь ввел любимый
цвет - мы сообщим этот цвет. Если сегодня вторник - фон основания будет зелёным.
Если пользователь указал свой возраст и мы смогли прочитать число, цвет будет
зависеть от значения числа. Если ни одно из условий не будет выполнено цвет фона
будет синим:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">код 18-1: смешенное использование <code>if let</code>, <code>else if</code>,
<code>else if let</code> и <code>else</code></span></p>
<p>Как вы видите схема проверки довольно-таки сложная для восприятия и вполне возможно
не покрывает всех случаев. В отличии от таких конструкций <code>match</code> и компилятор
помогают выявить возможные ошибки. Так что мы рекомендуем использовать этот
оператор при решении сложных задач поиска данных.</p>
<a class="header" href="print.html#while-let" id="while-let"><h3><code>while let</code></h3></a>
<p>Конструкция <code>while let</code> похожа на <code>if let</code>. Она позволяет выполнять цикл пока
выражение внутри <code>while let</code> соответствует шаблону. Пример 18-2 использует вектор,
в качестве стека и печатает значения в вектор в противоположном направлении:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
#}</code></pre></pre>
<p><span class="caption">код 18-2: использование <code>while let</code> для печати значений в цикле
пока метод <code>stack.pop()</code> возвращает <code>Some</code></span></p>
<p>Этот пример построчно выведет содержание вектора: 3, 2 и затем 1. Метод <code>pop</code> возвращает
последний элемент в списке <code>Some(value)</code> и удаляет его из вектора. Если вектор
пустой, он возвращает <code>None</code>. Цикл <code>while</code> продолжит выполнять код внутри блока
пока метод <code>pop</code> возвращает <code>Some</code>. Как только он вернёт <code>None</code>, цикл <code>while</code>
прекращается. Мы можем использовать <code>while let</code> для выборки каждого элемента из
стека.</p>
<a class="header" href="print.html#aЦикл-for" id="aЦикл-for"><h3>Цикл <code>for</code></h3></a>
<p>Работа цикла <code>for</code> уже была освещена в главе 3. Это наиболее часто используемый цикл
в Rust. В примере 18-3 продемонстрировано, как мы можем использовать шаблон для
получения кортежа - (значение, его индекс):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
#}</code></pre></pre>
<p><span class="caption">код 18-3: использование цикла <code>for</code> для получения кортежа:</span></p>
<p>Будет напечатано:</p>
<pre><code class="language-text">1 is at index 0
2 is at index 1
3 is at index 2
</code></pre>
<p>Первый вызов <code>enumerate</code> создаёт кортеж <code>(0, 1)</code>. В нём содержится индекс и значение
<code>(index, value)</code>, где <code>index</code> равен 0, а <code>value</code> будет равно 1.</p>
<a class="header" href="print.html#aОператор-let" id="aОператор-let"><h3>Оператор <code>let</code></h3></a>
<p><code>match</code> и <code>if let</code> я являются конечным списком, где используется шаблоны. Рассмотрим
обычное объявление переменной <code>let</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>Мы проделывали это уже сотни раз, реализуя примеры учебника. Возможно, вы не
осознавали, но вы использовали шаблоны всё это время. Формально оператор выглядит
так:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>Мы видим операторы, такие как <code>let x = 5;</code>, где имя переменной является <code>PATTERN</code>.</p>
<p>С помощью <code>let</code> мы сравниваем выражение с шаблоном и присваиваем ему значение.
В примере <code>let x = 5;</code> написано, что необходимо связать всё с переменой <code>x</code>.</p>
<p>Может быть и такой вариант::</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (x, y, z) = (1, 2, 3);
#}</code></pre></pre>
<p><span class="caption">код 18-4: использование шаблона для создания 3-х переменных</span></p>
<p>Мы также видели другой пример разбора кортежа на переменные (в главе 16), где
функция <code>mpsc::channel()</code> возвращает кортеж (<code>tx</code>, <code>rx</code>).</p>
<a class="header" href="print.html#aПараметры-функции-1" id="aПараметры-функции-1"><h3>Параметры функции</h3></a>
<p>Также как и <code>let</code>, параметры функции также могут быть шаблоном. Код 18-5
демонстрирует объявление функции <code>foo</code>, у которой есть параметр с именем <code>x</code>,
типа <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) {
    // code goes here
}
#}</code></pre></pre>
<p><span class="caption">код 18-5: объявление функции</span></p>
<p>Демонстрация того, как фунция может иметь параметр тип кортеж:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">код 18-6: объявление функции с кортежем в виде параметра</span></p>
<p>Будет напечатано <code>Current location: (3, 5)</code>. Когда мы отправим значение <code>&amp;(3, 5)</code>
в функцию <code>print_coordinates</code>, значения будет сопоставлено с шаблоном <code>&amp;(x, y)</code>.
<code>x</code> получит значение 3, а <code>y</code> получит значение 5.</p>
<p>Т.к. замыкания похожи на функции (мы их обсуждали в главе 13), мы также можем
использовать шаблоны в списках параметров замыканий.</p>
<p>То что роднит шаблоны в циклах <code>for</code>,<code>let</code> и параметрах функции - это то что они
должны быть однозначными. Подробнее об этом поговорим в следующей секции.</p>
<a class="header" href="print.html#aКогда-шаблон-можен-не-сработать" id="aКогда-шаблон-можен-не-сработать"><h2>Когда шаблон можен не сработать</h2></a>
<p>Шаблоны делятся на два вида - действительные всегда или действительные частично.
Например операторы <code>if let</code>и <code>while let</code> требуют только действительные шаблоны.</p>
<p>В общем случае вам нет необходимости беспокоится об этих особенностях.
Но всё же бывают случаи, когда из-за этого могут возникнуть ошибки. Например, в
примере <code>let x = 5;</code> шаблон является всегда действительным. Если же в качестве
типа данных используется перечисление <code>Some&lt;T&gt;</code>, может возникнуть ошибка.:</p>
<pre><code class="language-rust ignore">let Some(x) = some_option_value;
</code></pre>
<p><span class="caption">Listing 18-7: попытка присвоить действительный частично
шаблон <code>let</code></span></p>
<p>Если <code>some_option_value</code> = <code>None</code>, эта это значение не будет соответствовать шаблону
<code>Some(x)</code>. Шаблон <code>Some(x)</code> не покрывает всех возможных значений перечисления.
Поэтому компилятор сообщит об ошибке:</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; &lt;anon&gt;:3:5
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<p>Т.к. мы не можем обеспечить подобной конструкции хранить все возможные значения,
она не считается правильной.</p>
<p>Решить проблему компиляции выражение <code>if let</code>. Если шаблон не будет действительный,
код внутри не сработает. Пример показан в коде  18-8:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_option_value: Option&lt;i32&gt; = None;
if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<p><span class="caption">код 18-8: использование <code>if let</code> и блока с невсеохватывающим
шаблоном (вмето <code>let</code>)</span></p>
<p>Если же в конструкцию <code>if let</code> вы внесёте всеохватывающих шаблон или константное
значение, то компилятор также сообщит об ошибке в коде 18-9:</p>
<pre><code class="language-rust ignore">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<p><span class="caption">код 18-9: попытка использования всеохватывающего шаблона в
в конструкции <code>if let</code></span></p>
<p>Сообщение об ошибке:</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<p>В конструкции <code>match</code> в последнем условии (или рукаве) можно использовать шаблон,
который охватывает все остальные варианты.</p>
<p>В этой секции мы рассказали вам о тонкостях работы шаблонов в Rust. Далее, мы
рассмотрим более подробно синтаксис.</p>
<a class="header" href="print.html#aСинтаксис-шаблонов" id="aСинтаксис-шаблонов"><h2>Синтаксис шаблонов</h2></a>
<p>В этой секции мы подробно расскажем о видах шаблонов и месте и способах их
использования.</p>
<a class="header" href="print.html#aЛитералы" id="aЛитералы"><h3>Литералы</h3></a>
<p>Как мы уже видели в главе 6, вы можете использовать литералы непосредственно к
коде:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>Будет напечатано <code>one</code>, т.к. <code>x</code> равен 1.</p>
<a class="header" href="print.html#aИменованные-переменные" id="aИменованные-переменные"><h3>Именованные переменные</h3></a>
<p>Именованные переменные - это всеохватывающие шаблоны, которые принимают все
допустимые значения.</p>
<p>В коде 18-10 мы декларируем переменную <code>x</code> со значением <code>Some(5)</code> и переменную
<code>y</code> со значением <code>10</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">код 18-10: Выражение <code>match</code>, которое демонстрируют особенности
работы с включенными внутрь <code>Some()</code> значения переменной <code>y</code></span></p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>Рассмотрим подробнее, что же происходит при работе этого кода. Первый шаблон рукава
<code>match</code> имеет значение <code>Some(50)</code> и текущее значение <code>x</code> не соответствует этому
значению. Во втором рукаве шаблон соответствует всем значениям Some.
Обратите внимание что в этому случае создаётся новая область видимости, в которой
включается новая переменная с именем <code>y</code>, которой присваивается значения внешней
переменной.</p>
<p>Если же <code>x</code> равно <code>None</code>, сработает шаблон <code>_</code>. В этом случае, будет напечатано
<code>Default case, x = None</code>.</p>
<p>Последняя строчка кода сообщит о текущем состоянии переменных <code>x</code> и <code>y</code>.</p>
<a class="header" href="print.html#aГруппа-шаблонов" id="aГруппа-шаблонов"><h3>Группа шаблонов</h3></a>
<p>В выражение <code>match</code> благодаря логическому оператору <code>|</code> можно реализовать группу
условий, одном из которых должно удовлетворять условие. В результате будет выполнен
одни блок кода. Эта опция делает код компактнее::</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>Будет напечатано <code>one or two</code>.</p>
<a class="header" href="print.html#aИспользование-" id="aИспользование-"><h3>Использование <code>...</code></h3></a>
<p>Вы также можете использовать <code>...</code> для поиска значения входящего в числовой отрезок:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>Если <code>x</code> равно 1, 2, 3, 4 или 5, будет напечатано &quot;one through five&quot;.</p>
<p>Также в <code>match</code> можно использовать отрезки символов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 'c';

match x {
    'a' ... 'j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>Будет напечатано <code>early ASCII letter</code>.</p>
<a class="header" href="print.html#aДеструктуризация-для-получения-значений" id="aДеструктуризация-для-получения-значений"><h3>Деструктуризация для получения значений</h3></a>
<p>Шаблоны могут быть использованы для деструктуризации структур, перечислений,
кортежей и ссылок. Деструктуризация значит получение значений из компонентов
группировочной структуры. Код 18-11 демонстрирует объявление структуры <code>Point</code>.
Структура содержит два поля <code>x</code> и <code>y</code>. С помощью <code>let</code> мы инициируем несколько
переменных одновременно:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">код 18-11: инициализация переменных</span></p>
<p>В этом коде создаются переменные <code>x</code> и <code>y</code>, которые соответствуют переменным <code>x</code>
и <code>y</code> в <code>p</code> по всем параметрам (имени, типу). Очень важно, чтобы имена переменных
совпадали. Если же вы хотите использовать другие имена переменных, это тоже можно
сделать, добавив описание полей структуры:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">код 18-12: деструктуризация полей структуры в переменные</span></p>
<p>Также мы можем одновременно тестировать и использовать поля структуры для инициализации
переменных:</p>
<pre><pre class="playpen"><code class="language-rust"># struct Point {
#     x: i32,
#     y: i32,
# }
#
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">код 18-13: деструктуризация и тестирование на соответствие
значению шаблона</span></p>
<p>Будет напечатано <code>On the y axis at 7</code>, т.к. <code>x = 0</code>.</p>
<p>Мы уже приводили пример деструктуризации в главе 6 в коде 6-5, где мы деструктурировали
тип данных <code>Option&lt;i32&gt;</code> используя выражение <code>match</code>, добавляя единицу внутреннему
значению <code>Some</code>.</p>
<p>Если значение, которые мы ищем в шаблоне содержит ссылку, мы можем использовать
<code>&amp;</code> в шаблоне для разделения ссылки и значения. Это удобно в замыканиях используемых
итераторами. Код 18-14 демонстрирует, как реализовать цепочку вызовов, для того, чтобы
выполнить необходимые расчёты и получить результат:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let points = vec![
    Point { x: 0, y: 0 },
    Point { x: 1, y: 5 },
    Point { x: 10, y: -3 },
];
let sum_of_squares: i32 = points
    .iter()
    .map(|&amp;Point {x, y}| x * x + y * y)
    .sum();
#}</code></pre></pre>
<p><span class="caption">код 18-14: описания ссылки на структуру для доступа к полям
структуры</span></p>
<p><code>iter</code> обрабатывает ссылки на элементы последовательности. Если в коде вы не укажите
в описании шаблона перед названием структуры символ <code>&amp;</code> мы получим ошибку типов
входных данных:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt;
   |
14 |         .map(|Point {x, y}| x * x + y * y)
   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`
   |
   = note: expected type `&amp;Point`
              found type `Point`
</code></pre>
<p>Вы также можете смешивать, искать по шаблону и деструктировать ещё более сложным
образом. Например, так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
#}</code></pre></pre>
<p>Эта конструкция разделяет комплексный тип на компоненты.</p>
<a class="header" href="print.html#aИгнорирование-значений-в-шаблоне" id="aИгнорирование-значений-в-шаблоне"><h3>Игнорирование значений в шаблоне</h3></a>
<p>В грамматике шаблонов есть несколько элементов, которые могут быть использованы
для игнорирования значений или группы значений: <code>_</code>, имя с <code>_</code> и <code>..</code>. Рассмотрим
каждый такой шаблон подробнее.</p>
<a class="header" href="print.html#aИгнорирование-всего-значения-с-помощью-шаблона-_" id="aИгнорирование-всего-значения-с-помощью-шаблона-_"><h4>Игнорирование всего значения с помощью шаблона <code>_</code></h4></a>
<p>Мы уже познакомились с использование <code>_</code> операторе <code>match</code>. Его также можно использовать,
как обозначение как способ игнорирования аргумента:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(_: i32) {
    // code goes here
}
#}</code></pre></pre>
<p><span class="caption">код 18-15: использование <code>_</code> в заголовке функции</span></p>
<a class="header" href="print.html#aИгнорирование-части-значения-_" id="aИгнорирование-части-значения-_"><h4>Игнорирование части значения <code>_</code></h4></a>
<p>Вы также можете использовать <code>_</code> для игнорирования части значения. Код 18-16,
в операторе <code>match</code> находит значение <code>Some</code> и игнорирует его содержимое внутри:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = Some(5);

match x {
    Some(_) =&gt; println!(&quot;got a Some and I don't care what's inside&quot;),
    None =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">код 18-16: игнорирование содержания <code>Some</code></span></p>
<p>Это весьма удобно, когда просто нужно проигнорировать конкретное значение <code>Some</code>.</p>
<p>Мы также можем использовать <code>_</code> для игнорирования определённых значений в шаблоне:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
#}</code></pre></pre>
<p><span class="caption">код 18-17: игнорирование элементы шаблона</span></p>
<p>Будет напечатано <code>Some numbers: 2, 8, 32</code>.</p>
<a class="header" href="print.html#aИгнорирование-неиспользуемых-переменные-у-которых-в-начале-имени-стоит-символ-_" id="aИгнорирование-неиспользуемых-переменные-у-которых-в-начале-имени-стоит-символ-_"><h4>Игнорирование неиспользуемых переменные, у которых в начале имени стоит символ <code>_</code></h4></a>
<p>Если необходим оставить в коде неиспользуемую переменную это можно сделать с помощью
символа <code>_</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
    println!(&quot;{}&quot;, y);
}
</code></pre></pre>
<p><span class="caption">код 18-18: демонстрация игнорировании компилятором неиспользуемой
функции</span></p>
<p>Обратите внимание на смысловой разнице использования символа <code>_</code>, как части имени
переменной и <code>_</code> в отдельности.</p>
<p>В коде 18_19 демонстрируется пример использования переменной с именем <code>s</code>.
В имени используется <code>_</code> для того, чтобы предотвратить многократное использование
переменной <code>s</code>:</p>
<pre><code class="language-rust ignore">let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<p><span class="caption">код 18-19: неиспользуемая переменная связывается  с переменой
<code>s</code> и получает владение</span></p>
<p>Если используется <code>_</code>, код будет работать:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
#}</code></pre></pre>
<p><span class="caption">код 18-20: использование <code>_</code></span></p>
<a class="header" href="print.html#aИгнорирование-оставшихся-частей-значения-с-помощью-" id="aИгнорирование-оставшихся-частей-значения-с-помощью-"><h4>Игнорирование оставшихся частей значения с помощью <code>..</code></h4></a>
<p>С помощью значений вы можете с помощью шаблонов получить только небольшую часть
данных. Используя <code>..</code> вы можете получить отрезок данных. В примере 18-21 у вас
есть структура содержащая координаты (x,y,z). В <code>match</code> мы хотим получить только
данные <code>x</code>, а остальные данные проигнорировать:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
#}</code></pre></pre>
<p><span class="caption">код 18-21: игнорирование полей структуры <code>Point</code> кроме  <code>x</code>
с помощью <code>..</code></span></p>
<p><code>..</code> это сокращённая запись <code>y: _</code> and <code>z: _</code>. Такая опция удобна при работе со структурой
с большим количеством полей.</p>
<p><code>..</code> также может быть использована для получения только нужных значений в кортеже:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p><span class="caption">код 18-22: выбор только первого и последнего значения кортежа</span></p>
<p>В продемонстрированном примере мы получили значения первого и последнего элемента
кортежа.</p>
<p>Использование <code>..</code> должно быть однозначно и очевидно. Если компилятор не сможет
понять вашего замысла - будет ошибка:</p>
<pre><code class="language-rust ignore">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">код 18-23: попытка использовать <code>..</code> дважды</span></p>
<p>Описание ошибки:</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<p>Т.к. невозможно определить сколько значений необходимо проигнорировать. Имя переменной
не несёт для компилятора какой-либо информации для выборки. Поэтому код не будет
скомпилирован.</p>
<a class="header" href="print.html#ref-и-ref-mut-для-изменений-ссылок-в-шаблонах" id="ref-и-ref-mut-для-изменений-ссылок-в-шаблонах"><h3><code>ref</code> и <code>ref mut</code> для изменений ссылок в шаблонах</h3></a>
<p>Обычно, когда значение совпадает с шаблоном последовательность работы программы
перемещается внутрь блока <code>match</code>, т.е. применяются правила владения. Код 18-24
демонстрирует пример:</p>
<pre><code class="language-rust ignore">let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
</code></pre>
<p><span class="caption">код 18-24: создание переменной и попытка получить владение
ей</span></p>
<p>Пример не скомпилируется, т.к. значение внутри <code>Some</code> будет перемещено <code>match</code>.</p>
<p>Воспользумся символом <code>ref</code> в шаблоне для того сделать ссылку на полученное значение :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p><span class="caption">код 18-25: создание такой ссылки, что он не будет иметь
владение своим значеним</span></p>
<p>Этот код скомпилируется, т.к. мы не перемещаем значение внутрь блока.</p>
<p>Для создания изменяемой ссылки используйте <code>ref mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref mut name) =&gt; *name = String::from(&quot;Another name&quot;),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
#}</code></pre></pre>
<p><span class="caption">код 18-26: создание изменяемой ссылки на значение</span></p>
<p>Этот пример будет скомпилирован и в результате будет напечатано
<code>robot_name is: Some(&quot;Another name&quot;)</code>. Т.к. <code>name</code> является изменяемой ссылкой,
мы получим доступ к данным с помощью оператора <code>*</code>.</p>
<a class="header" href="print.html#aДополнительные-условия-с-помощью-защиты-оператора-matchmatch-guards" id="aДополнительные-условия-с-помощью-защиты-оператора-matchmatch-guards"><h3>Дополнительные условия с помощью защиты оператора <code>match</code>(Match Guards)</h3></a>
<p>Вы можете представить т.н. дополнительную проверку (защиту) (<em>match guards</em>) рукава
оператора <code>match</code> с помощью введения дополнительного условия внутри оператором <code>if</code>.
Например, так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">код 18-27: введение внутреннего дополнительного условия</span></p>
<p>Будет напечатано <code>less than five: 4</code>. Если же <code>num</code> был бы увеличен <code>Some(7)</code>,
этот пример напечатал бы <code>7</code>. Дополнительная защита позволяет усложнить проверку,
добавив гибкости (при необходимости).</p>
<p>К примере кода 18-10, мы видели, что если шаблон скрывал переменные, мы не могли
создать шаблон для отслеживания случая, при котором это значение было равно какому-либо
значение извне <code>match</code>. Код 18-28 показывает реализовать эту задачу с помощью защиты
<code>match</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">код 18-28: использоване защиты match для дополнительного тестирования
значения</span></p>
<p>Будет напечатано <code>Default case, x = Some(5)</code>. Т.к. второе условие не соблюдается
<code>x</code> != <code>y</code>, выполняется последние условие в <code>match</code>.</p>
<p>Если мы используем защиту match в нескольких шаблонах при помощи <code>|</code>, то условие
применяется ко всем шаблонам. Код 18-29 показывает это на примере:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
#}</code></pre></pre>
<p><span class="caption">код 18-29: комбинация нескольких шаблонов с защитой match</span></p>
<p>Будет напечатано <code>no</code>, т.к. условие в <code>if</code> применяется ко всему шаблону <code>4 | 5 | 6</code>, not only to the last value <code>6</code>. Другими словами, работает следующее условие:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>а не это:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<a class="header" href="print.html#aСвязываение-" id="aСвязываение-"><h3>Связываение <code>@</code></h3></a>
<p>Для того, чтобы проверить соответствие шаблону и создать переменную связанную с этим
значением мы можем использовать <code>@</code>. Код 18-30 демонстрирует пример, в котором
мы хотим проверить наличие поля  <code>Message::Hello</code> <code>id</code> в отрезке значений <code>3...7</code>,
а также связать найденное значение с переменной:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id @ 3...7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id)
    },
    Message::Hello { id: 10...12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
#}</code></pre></pre>
<p><span class="caption">код 18-30: использование <code>@</code> для связывания значения в шаблоне
во время тестирования</span></p>
<p>Будет напечатано <code>Found an id in range: 5</code>. Написав <code>id @</code> перед отрезком значений
мы проверяет входит ли значение в этот отрезок. Во втором рукаве проверяется условие.
Найденное значение не сохраняется. В последнем условии <code>match</code> мы только определили
переменную (она не будет учувствовать ни в каком сравнении). Использование <code>@</code>
добавляет гибкости и лаконичности в код ваших программ.</p>
<a class="header" href="print.html#aИтоги-13" id="aИтоги-13"><h2>Итоги</h2></a>
<p>Шаблоны весьма полезны. При использовании оператора <code>match</code> компилятор должен
убедиться, что были проверены все возможные варианты совпадений. Оператор <code>let</code>
ми другие опции могут сделать этот <code>match</code> ещё более удобным в применении.</p>
<p>Настало время рассмотреть расширенные возможности Rust. В следующей главе будет
рассмотрены такие опции языка. Надеюсь, что будет интересно.</p>
<a class="header" href="print.html#aРасширенные-возможности" id="aРасширенные-возможности"><h1>Расширенные возможности</h1></a>
<p>Мы прошли долгий путь! К настоящему времени мы узнали 99% всего, что может вам
понадобятся при написании программ на Rust. Прежде чем мы сделаем еще один проект
в главе 20, давайте поговорим о нескольких вещах, с которыми вы можете столкнуться
в течение последнего 1% времени. Не стесняйся пропустите эту главу и вернитесь к ней,
как только вы столкнетесь с этими вещами в своей работе; функции, которые мы научимся
использовать здесь, полезны в очень специфических ситуациях. Мы не хотим оставлять
эти функции без внимания, хотя вы к ним не будет часто обращаться.</p>
<p>В этой главе мы рассмотрим:</p>
<ul>
<li>Небезопасный Rust: когда вам нужно отказаться от некоторых гарантий Rust и
сообщим компилятору, что вы будете нести ответственность за соблюдение гарантий</li>
<li>Расширенные сроки жизни: дополнительный синтаксис в сложных ситуациях</li>
<li>Расширенные типажи: связанные типы, параметры типа по умолчанию, супертипажи и
шаблон newtype для связи с типажами</li>
<li>Расширенные типы: еще несколько о шаблоне newtype, псевдонимы типов,
Тип «никогда» (“never”) и типы с динамическим размером</li>
<li>Расширенные функции и замыкания: указатели на функции и возвращение замыканий
из функции.</li>
</ul>
<p>Итак приступим.</p>
<a class="header" href="print.html#aНебезопасный-rust" id="aНебезопасный-rust"><h2>Небезопасный Rust</h2></a>
<p>Во всех предыдущих главах этой книги мы обсуждали код написанный в Rust, который
гарантирует безопасность памяти во время компиляции. Однако внутри Rust скрывается
другой язык, - небезопасный Rust, которые не обеспечивает безопасной работы с памятью.
Это язык работает также как и первый, но предоставляет вам дополнительные возможности.</p>
<p>Небезопасный Rust существует, потому что по своей природе статический анализ является
консервативным. Когда пытаясь определить, поддерживает ли код некоторые гарантии
или нет, лучше отклонить некоторые программы, которые действительны, чем принимать
некоторые программы, которые ошибочны. Бывают случаи, когда ваш код может быть в
порядке, но Rust считает это нет. В этих случаях вы можете использовать небезопасный
код, чтобы сообщить компилятору: «поверь мне, я знаю, что я делаю». Недостатком
является то, что вы сами; если вы написали код неправильно, можете иметь проблемы
из-за небезопасной работы с памятью, такие как нулевой указатель при
разыменовании.</p>
<p>Есть еще одна причина, по которой Rust должен иметь небезопасный код: базовый
аппаратное обеспечение компьютеров по своей сути небезопасно. Если Rust не позволял
вам делать небезопасные операций, были бы некоторые задачи, которые вы просто не
могли сделать. Но Rust должен позволять вам выполнять низкоуровневые системные
программы, например, напрямую взаимодействовать с вашей операционной системой или
даже писать собственные система! Это часть целей языка. Нам нужен реализовать
это.</p>
<a class="header" href="print.html#aНебезопасные-сверхспособности" id="aНебезопасные-сверхспособности"><h3>Небезопасные сверхспособности</h3></a>
<p>Мы переключаемся на небезопасный Rust, используя ключевое слово <code>unsafe</code> и создаём
новый блок, который содержит небезопасный код. Есть четыре действия, которые вы
можете предпринять в небезопасном Rust, которые вы не можете сделать безопасном.
Мы называем это «небезопасные суперспособности». Мы не видели большинство этих функций,
так как ими можно воспользоваться с <code>unsafe</code>.</p>
<ol>
<li>Разыменование сырого указателя</li>
<li>Вызов небезопасной функции или метода</li>
<li>Доступ или изменение изменяемой статической переменной</li>
<li>Реализация небезопасного типажа</li>
</ol>
<p>Важно понимать, что <code>unsafe</code> не отключает проверку заимствования или любые другие
проверки безопасности Rust: если вы используете ссылку в небезопасной
кода, он все равно будет проверена. Единственное, что делает ключевое слово <code>unsafe</code>
дают вам доступ к этим четырем функциям, которые не проверяются компилятором для
безопасности памяти. Вы по-прежнему получаете некоторую степень безопасности внутри
небезопасного блока! Кроме того, <code>unsafe</code> не означает, что код внутри блока опасен или
или будет иметь проблемы с безопасностью памяти: цель состоит в том, что вы, как
программист гарантируете, что код внутри <code>unsafe</code> блока будет иметь действительную
память, во время отключения проверок компилятора.</p>
<p>Однако люди ошибаются, и ошибки случаются. Если вы сделаете в небезопасном блоке
связанную с безопасностью памяти, вы будете знать, что она должна
быть связанными с этим блоком. Это упрощает поиск ошибок, так как мы знаем, что
Rust проверяет для нас весь другой код. Для того, чтобы свести ошибки работы с
памятью к минимуму необходимо минимизировать небезопасные блоки кода : сохраняйте
<code>unsafe</code> блоки малыми и вы будете благодарить себя позже, так как у вас будет
меньше кода для анализа.</p>
<p>Чтобы максимально изолировать небезопасный код, рекомендуется заключить небезопасный
код в безопасную абстракцию и предоставить безопасный API, который мы будем обсуждать,
когда будем обсуждать небезопасные функции и методы. Части стандартная библиотеки
реализованы как безопасные абстракции над небезопасным кодом, которые были проверены.
Это предотвращает утечку памяти в <code>unsafe</code> блоках.</p>
<p>Давайте поговорим о каждой из четырех небезопасных свехспособностях, и по пути
мы рассмотрим некоторые абстракции, которые обеспечивают безопасный интерфейс
для небезопасного кода.</p>
<a class="header" href="print.html#aРазыменование-сырых-указателей" id="aРазыменование-сырых-указателей"><h3>Разыменование сырых указателей</h3></a>
<p>Рассмотрим материал главы 4 ещё раз. Там мы говорили о ссылках. Мы изучили, что
компилятор всегда проверяет действительность ссылок. Небезопасный Rust предоставляет
два новых типа для работы со ссылками. Также как ссылки, мы имеет изменяемые и
неизменяемые указатели (<code>*const T</code> и <code>*mut T</code>). В контексте сырых ссылок &quot;неизменяемость&quot;
значит, что указателям нельзя присваивать значения непосредственно после разыменования.</p>
<p>Отличия сырых ссылок от умных указателей:</p>
<ul>
<li>разрешается игнорирование правил заимствования, можно иметь изменяемые и неизменяемы
указатели или множество указателей на одну и ту же область памяти.</li>
<li>нет гарантии действительности указателя</li>
<li>возможность иметь null-ссылки</li>
<li>нет реализации автоматической очистки памяти</li>
</ul>
<p>Код 19-1 демонстрирует, как создавать сырые ссылки из обычных ссылок:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
#}</code></pre></pre>
<p><span class="caption">код 19-1: создание сырых ссылок из ссылок</span></p>
<p><code>*const T</code> является неизменяемым сырым указателем. <code>*mut T</code> является изменяемым
сырым указателем. Мы создали сырые указатели с помощью ключевого слова <code>as</code> приведя
обычные изменяемые и неизменяемые ссылки к этим типам.</p>
<p>Код 19-2 показывает, как создать сырой указатель на конкретный адрес памяти.
Это, конечно, весьма опасное действие делать такие присваивания, но это возможно:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let address = 0x012345usize;
let r = address as *const i32;
#}</code></pre></pre>
<p><span class="caption">код 19-2: создание сырых указателей на определённый адрес
памяти</span></p>
<p>Обратите внимания, что в приведённых примерах нет блока <code>unsafe</code>. Вы можете <em>создать</em>
сырые указатели в безопасном коде, но вы не можете разыменовать их или прочесть
данные. Использование оператора разыменования сырых указателей разрешается только
в блоке <code>unsafe</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
#}</code></pre></pre>
<p><span class="caption">код 19-3: разыменование сырых указателей в блоке <code>unsafe</code></span></p>
<p>Создание указателей разрешено. Только при попытке доступа к объекту могут быть
какие-либо проблемы.</p>
<p>Также обратите внимание, что в примерах кода 19-1 и 19-3 мы создали <code>*const i32</code>
и <code>*mut i32</code>, которые ссылаются на одну и ту же область памяти. Если мы попытаемся
создать неизменяемую и изменяемую ссылку на <code>num</code> вместо сырых указателей, такой
код не скомпилируется, т.к. будут нарушены правила наличия изменяемых и неизменяемых
ссылок. С помощью сырых указателей мы можем создать изменяемый указатель и неизменяемый
указатель на одну и ту же область памяти и изменять данные с помощью изменяемого
указателя, потенциально создавая эффект гонки. Будьте осторожны!</p>
<p>Если существует столько возможных неприятностей, для чего же нужны эти сырые ссылки?!
Одно весьма важное их свойство - это возможность быть интерфейсом кода на С. Другим
вариантом использования является создание безопасных абстракций, которых не сможет
понять система проверки заимствования. Далее мы рассмотрим небезопасные функции,
где мы познакомимся с примером использования безопасных абстракций, которые используют
небезопасный код.</p>
<a class="header" href="print.html#aВызов-небезопасной-функции-или-метода" id="aВызов-небезопасной-функции-или-метода"><h3>Вызов небезопасной функции или метода</h3></a>
<p>Второй операция, которую мы рассмотрим  - это небезопасная функция. Небезопасные
функции и методы выглядят также, как и обычные функции и методы, но они имеют
дополнительное обозначение <code>unsafe</code> перед собой. Рассмотрим пример::</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
#}</code></pre></pre>
<p>Если мы попытаемся вызвать функцию <code>dangerous</code> без блока <code>unsafe</code>, мы получим ошибку:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt; &lt;anon&gt;:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>Вставив <code>unsafe</code>-блок вокруг вызова функции <code>dangerous</code>, мы сообщаем компилятору,
что мы понимаем, что используем небезопасную функцию, мы знаем как её использовать
правильным образом и мы соблюли все необходимые условия.</p>
<a class="header" href="print.html#aСоздание-безопасных-абстракций-вокруг-небезопасного-кода" id="aСоздание-безопасных-абстракций-вокруг-небезопасного-кода"><h4>Создание безопасных абстракций вокруг небезопасного кода</h4></a>
<p>Рассмотрим пример из стандартной библиотеки. Рассмотрим функцию <code>split_at_mut</code> и
посмотрим как мы можем реализовать её сами. Этот безопасный метод определён в
изменяемом срезе. Метод получает срез и разделяет его на два:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
#}</code></pre></pre>
<p><span class="caption">код 19-4: использование безопасной функции <code>split_at_mut</code></span></p>
<p>Эту функцию нельзя реализовать, используя только безопасный Rust. Попытка реализации
может выглядеть примерно так (19-5). Для просторы мы реализуем функцию, а не метод
и только для целых чисел:</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">код 19-5: попытка реализации функции <code>split_at_mut</code></span></p>
<p>Эта функция сначала получает общую длину среза. Далее, проверяет значение что
параметр меньше или равен этому значению.</p>
<p>Далее, функция возвращает два среза в кортеже: первый от 0 до значения, второй от
значения до конца среза.</p>
<p>При попытке компиляции данной функции вы получите следующее сообщение об ошибке:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt; &lt;anon&gt;:6:11
  |
5 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
6 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
7 | }
  | - first borrow ends here
</code></pre>
<p>Компилятор не понимает, что вы хотите получить различные части среза, он понимает
лишь то, что вы хотите осуществить заимствование дважды. Заимствование различных
частей среза не вызывает ошибок компиляции, но всё же это не является лучшим решением.</p>
<p>Код 19-6 демонстрирует, как можно использовать <code>unsafe</code>-блок, сырой указатель и
вызов небезопасной функции для реализации целей функции <code>split_at_mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
#}</code></pre></pre>
<p><span class="caption">код 19-6: использование небезопасного кода для реализации
<code>split_at_mut</code></span></p>
<p>Пожалуйста, освежите в памяти материал главы 4, где мы изучили, что указатели
на одни и теже данные являются срезом. Мы часто использовали метод <code>len</code> для
получения длинны среза. Мы можем использовать метод <code>as_mut_ptr</code> для получения
сырого указателя на срез. В этом случае мы получаем изменяемый срез <code>i32</code> значений,
который мы сохраняем в переменной <code>ptr</code>.</p>
<p>Благодаря небезопасному методу <code>slice::from_raw_parts_mut</code> мы смогли реализовать
задуманный в предыдущем решении алгоритм.</p>
<p>Т.к. срезы являются безопасными языковыми конструкциями, после их создания ими
можно пользоваться в безопасной части кода. Функция <code>slice::from_raw_parts_mut</code>
является небезопасной, т.к. она получает сырой указатель (без проверки на действительность).
Метод <code>offset</code> сырого указателя также не является безопасным, т.к. он работает с
данными не проверяя их действительность. Мы заключили вызовы данных функций в
<code>unsave</code>-блок.</p>
<p>Обратите внимание, что результат функции <code>split_at_mut</code> является безопасным.
Мы создали безопасную абстракцию для небезопасного кода с помощью <code>unsafe</code>-блока.</p>
<p>В отличии от функции <code>slice::from_raw_parts_mut</code> код 19-7 скорей всего не будет
работать. Этот код получает данные по адресу памяти и создаёт срез длинной 10000:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
#}</code></pre></pre>
<p><span class="caption">код 19-7: создание среза по адресу памяти</span></p>
<p>Использование такого кода может привести к непредсказуемым последствиям.</p>
<a class="header" href="print.html#extern-функции-вызывающие-внешний-код-являются-небезопасными" id="extern-функции-вызывающие-внешний-код-являются-небезопасными"><h4><code>extern</code> функции вызывающие внешний код являются небезопасными</h4></a>
<p>Иногда появляется необходимость вызвать код написанный на другом языке программирования.
Для этой цели существует специальное ключевое слов <code>extern</code>, которое облегчает
создание и использование <em>интерфейса внешних функций</em> (<em>Foreign Function Interface</em>
(FFI)). Код 19-8 демонстрирует, как установить связь с С-функцией <code>abs</code>. Функции
в блоках <code>extern</code> всегда являются небезопасными:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">код 19-8: определение и вызов <code>extern</code>-функции написанной
на другом языке программирования</span></p>
<p>С помощью блока <code>extern &quot;C&quot;</code> мы сообщаем какую функцию мы хотим вызвать. <code>&quot;C&quot;</code>
определяет интерфейс какого языка будет использован <em>application binary interface</em>
(ABI). Наиболее часто используемым интерфейсом является интерфейс языка C.</p>
<p>Вызов внешних функций всегда является небезопасным, т.к. компилятор Rust не может
гарантировать безопасность такого кода.</p>
<!-- PROD: START BOX -->
<a class="header" href="print.html#aВызов-функций-rust-из-других-языков-программирования" id="aВызов-функций-rust-из-других-языков-программирования"><h5>Вызов функций Rust из других языков программирования</h5></a>
<p>Ключевое слово <code>extern</code> также используется для создания интерфейса, который позволяет
вызывать функции Rust из других языков программирования. Вместо блока <code>extern</code>
мы можем добавить к описанию функции это ключевое слово. Также необходимо добавить
аннотацию <code>#[no_mangle]</code>, чтобы сообщить компилятору не анализировать данную функцию.
В следующем примере функция <code>call_from_c</code> будет доступна для кода языка программирования
Си (С):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
#}</code></pre></pre>
<p>Использование <code>extern</code> не требует использования <code>unsafe</code></p>
<!-- PROD: END BOX -->
<a class="header" href="print.html#aПолучение-доступа-и-внесение-изменений-в-изменяемую-статическую-переменную" id="aПолучение-доступа-и-внесение-изменений-в-изменяемую-статическую-переменную"><h3>Получение доступа и внесение изменений в изменяемую статическую переменную</h3></a>
<p>Рассказывая о возможностях языка мы ещё ни разу не упомянули о глобальных переменных.
Множество языков программирования поддерживают такую возможность. Этот функционал
несёт в себе потенциальные проблемы, например, если в многопоточной среде вы будете
получать доступ к такой переменной, то может возникнуть эффект гонки.</p>
<p>Глобальные переменные в Rust называют <em>статическими</em> (<em>static</em>). Код 19-9 демонстрирует
определение и использование статической переменной имеющий тип строковый срез:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">код 19-9: определение и использование неизменяемой статической
переменной</span></p>
<p><code>static</code> переменные походи на константы. Их имена по договорённости также необходимо
писать с большой буквы <code>SCREAMING_SNAKE_CASE</code>. Кроме того у таких переменных обязательно
необходимо (<em>must</em>) указывать тип. В данном случае это <code>&amp;'static str</code>. Только
ссылки с модификатором <code>'static</code> могут быть сохранены в статической переменной.
По этой причине нет необходимости аннотировать такие переменные модификатором
времени жизни.</p>
<p>Доступ к неизменяемым переменным является безопасным. Значения в статических
переменных имеют фиксированный адрес в памяти. В отличии от них константам разрешается
дублировать свои данные.</p>
<p>Другое отличие статических переменных от констант - они могут быть изменяемыми.
Доступ и изменения статических переменных являются небезопасными. Пример кода 19-10
показывает как объявлять, получать доступ и изменять изменяемую статическую переменную
<code>COUNTER</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">код 19-10: чтение и запись изменяемой статической переменной</span></p>
<p>Также как и обычная переменная, статическая переменная может быть изменяемой. Для
этого в описании переменной необходимо использовать ключевое слово <code>mut</code>. Каждый
раз, когна необходим доступ к такой переменной, используется <code>unsafe</code>-блок. Данный
код компилируется и выводит <code>COUNTER: 3</code>. В многопоточной среде при доступе к
такой переменной эффект гонок вполне вероятен.</p>
<p>Использование изменяемых статических данных весьма небезопасно. Весьма сложно отслеживать
их корректность и защитить от эффекта гонок в многопоточной среде.</p>
<a class="header" href="print.html#aРеализация-небезопасных-типажей" id="aРеализация-небезопасных-типажей"><h3>Реализация небезопасных типажей</h3></a>
<p>С помощью <code>unsafe</code> также можно реализовать небезопасные типажи. При этом типаж и
его реализации помечаются <code>unsafe</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
#}</code></pre></pre>
<p><span class="caption">код 19-11: определение и реализация небезопасного типажа</span></p>
<p>Также как и небезопасные функции, методы в небезопасных типажах могут быть небезопасны
поэтому их реализации также помечаются <code>unsafe</code></p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits from Chapter 16, and
that the compiler implements these automatically if our types are composed
entirely of <code>Send</code> and <code>Sync</code> types. If we implement a type that contains
something that’s not <code>Send</code> or <code>Sync</code> such as raw pointers, and we want to mark
our type as <code>Send</code> or <code>Sync</code>, that requires using <code>unsafe</code>. Rust can’t verify
that our type upholds the guarantees that a type can be safely sent across
threads or accessed from multiple threads, so we need to do those checks
ourselves and indicate as such with <code>unsafe</code>.</p>
<p>Использование <code>unsafe</code> не делает в описанных четырёх случаях не делает код неправильным
или подозрительным. Просто к такой код не может быть проанализирован компилятором
должным образом и на программиста ложится ответственность за его корректность.
Кроме того данная аннотация сужает потенциально опасный код до минимума, что может
ускорить процесс поиска ошибки.</p>
<a class="header" href="print.html#aРасширенные-модификаторы-времени-жизни-МВЖ-lifetimes" id="aРасширенные-модификаторы-времени-жизни-МВЖ-lifetimes"><h2>Расширенные модификаторы времени жизни (МВЖ) (Lifetimes)</h2></a>
<p>В главе 10 мы изучили как аннотировать ссылочные переменные с помощью МВЖ для
помощи компилятору понять какие взаимосвязи существуют между данными. В этой секции
мы рассмотрим ещё не освященные опции МВЖ:  <em>подтипы</em>, <em>границы</em> и <em>объекты-типажи</em>.</p>
<a class="header" href="print.html#aПодтипы" id="aПодтипы"><h3>Подтипы</h3></a>
<p>Представьте, что мы хотим реализовать текстовый анализатор (parser). Для этого
необходимо создать структуру, экземпляры которой будут хранить ссылки на строку, которую
мы анализируем. Назовём эту структуру <code>Context</code>. Мы создадим анализатор, который
будет анализировать эту строку и возвращать индикатор успеха или неудачи. Анализатору
необходимо заимствовать сороку для анализа. Реализация может быть похожа на код
19-12, который не скомпилируется, т.к. мы не указали МВЖ:</p>
<pre><code class="language-rust ignore">struct Context(&amp;str);

struct Parser {
    context: &amp;Context,
}

impl Parser {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
</code></pre>
<p><span class="caption">код 19-12: определение структуры <code>Context</code>, которая содержит
строковый срез. Структура <code>Parser</code> содержит ссылку на экземпляр <code>Context</code>. Метод
<code>parse</code> всегда возвращает ошибку со ссылкой на строковый срез</span></p>
<p>Для простоты функция <code>parse</code>  возвращается <code>Result&lt;(), &amp;str&gt;</code>. Поэтому мы ничего
не делаем для успешной работы и при ошибке возвращаем часть строки, которая не смогла
быть обработана. Реальные функции такого рода должны содержать больше информации.</p>
<p>Как же записаь МВЖ для строкового среза в <code>Context</code> и ссылку в <code>Parser</code>? Очевидным
решением является использование МВЖ везде:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Context&lt;'a&gt;(&amp;'a str);

struct Parser&lt;'a&gt; {
    context: &amp;'a Context&lt;'a&gt;,
}

impl&lt;'a&gt; Parser&lt;'a&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
        Err(&amp;self.context.0[1..])
    }
}
#}</code></pre></pre>
<p><span class="caption">код 19-13: аннотирование ссылок в <code>Context</code> и <code>Parser</code></span></p>
<p>Этот код скомпилируется. Следующий код (19-14) декларирует функцию, которая получает
входной параметр <code>Context</code> и используя <code>Parser</code> для анализа текста.</p>
<pre><code class="language-rust ignore">fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">Listing 19-14: попытка добавить функцию <code>parse_context</code>,
которая получает <code>Context</code> и использует <code>Parser</code></span></p>
<p>При попытке компиляции мы получаем две хорошо описанные ошибки:</p>
<pre><code class="language-text">error: borrowed value does not live long enough
  --&gt; &lt;anon&gt;:16:5
   |
16 |     Parser { context: &amp;context }.parse()
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough
17 | }
   | - temporary value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the
body at 15:55...
  --&gt; &lt;anon&gt;:15:56
   |
15 |   fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
   |  ________________________________________________________^
16 | |     Parser { context: &amp;context }.parse()
17 | | }
   | |_^

error: `context` does not live long enough
  --&gt; &lt;anon&gt;:16:24
   |
16 |     Parser { context: &amp;context }.parse()
   |                        ^^^^^^^ does not live long enough
17 | }
   | - borrowed value only lives until here
   |
note: borrowed value must be valid for the anonymous lifetime #1 defined on the
body at 15:55...
  --&gt; &lt;anon&gt;:15:56
   |
15 |   fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
   |  ________________________________________________________^
16 | |     Parser { context: &amp;context }.parse()
17 | | }
   | |_^
</code></pre>
<p>Эти ошибки говорят, что время жизниа <code>Parser</code>, который мы создаём и параметра метода
заканчивается после завершения работы функции. Но они должны продолжать жить далее.</p>
<p>Т.е. для <code>Parser</code> и <code>context</code> необходимо пережить ( <em>outlive</em>) работы функции и
быть действительными после.</p>
<p>Давайте рассмотрим определение функции <code>parse</code> в 19-13 снова. Обратим внимание на
сигнатуру метода:</p>
<pre><code class="language-rust ignore">    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {
</code></pre>
<p>Напомним, что при использовании ПВЖ описание должно иметь вид:</p>
<pre><code class="language-rust ignore">    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {
</code></pre>
<p>Проблема этой функции в том, что время жизни экземпляра <code>Parser</code> заканчивается после
завершения функции и время жизни параметра также.</p>
<p>Необходимо описать время жизни таким образом, чтобы срез в <code>Context</code> и ссылка в
<code>Parser</code> имели бы разные времена жизни и возвращаемое значение было связано с временем
жизни среза.</p>
<p>Мы можем попытаться дать <code>Parser</code> и <code>Context</code> различные параметры времени жизни.
К сожалению, это решение не решит полностью проблему, но это всё же правильный путь
на пути к решению:</p>
<pre><code class="language-rust ignore">struct Context&lt;'s&gt;(&amp;'s str);

struct Parser&lt;'c, 's&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}

impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {
    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {
        Err(&amp;self.context.0[1..])
    }
}

fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {
    Parser { context: &amp;context }.parse()
}
</code></pre>
<p><span class="caption">код 19-15: определение различных переменных времени жизни</span></p>
<p>We’ve annotated the lifetimes of the references in all the same places that we
annotated them in Listing 19-13, but used different parameters depending on
whether the reference goes with the string slice or with <code>Context</code>. We’ve also
added an annotation to the string slice part of the return value of <code>parse</code> to
indicate that it goes with the lifetime of the string slice in <code>Context</code>.</p>
<p>Here’s the error we get now:</p>
<pre><code class="language-text">error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references
 --&gt; src/main.rs:4:5
  |
4 |     context: &amp;'c Context&lt;'s&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the pointer is valid for the lifetime 'c as defined on the struct at 3:0
 --&gt; src/main.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:0
 --&gt; src/main.rs:3:1
  |
3 | / struct Parser&lt;'c, 's&gt; {
4 | |     context: &amp;'c Context&lt;'s&gt;,
5 | | }
  | |_^
</code></pre>
<p>Rust doesn’t know of any relationship between <code>'c</code> and <code>'s</code>. In order to be
valid, the referenced data in <code>Context</code> with lifetime <code>'s</code> needs to be
constrained to guarantee that it lives longer than the reference to <code>Context</code>
that has lifetime <code>'c</code>. If <code>'s</code> is not longer than <code>'c</code>, then the reference to
<code>Context</code> might not be valid.</p>
<p>Which gets us to the point of this section: Rust has a feature called <em>lifetime
subtyping</em>, which is a way to specify that one lifetime parameter lives at
least as long as another one. In the angle brackets where we declare lifetime
parameters, we can declare a lifetime <code>'a</code> as usual, and declare a lifetime
<code>'b</code> that lives at least as long as <code>'a</code> by declaring <code>'b</code> with the syntax <code>'b: 'a</code>.</p>
<p>Для того, чтобы сообщить компилятору, что время жизни <code>'s</code> будет не меньше времени
жизни <code>'c</code>, мы изменим описание структуры следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Context&lt;'a&gt;(&amp;'a str);
#
struct Parser&lt;'c, 's: 'c&gt; {
    context: &amp;'c Context&lt;'s&gt;,
}
#}</code></pre></pre>
<p>Теперь всё в порядке. Такие особенности применяются не часть, но всё же бывают.</p>
<a class="header" href="print.html#aГраницы-времени-жизни-переменных" id="aГраницы-времени-жизни-переменных"><h3>Границы времени жизни переменных</h3></a>
<p>В главе 10 мы обсуждали как использовать границы в типажах обобщенных типах.
Мы можем также добавить параметры времени жизни как ограничения в обобщенные типы.
Например, рассмотрим тип, который является оболочкой для ссылок. Вспомним тип
<code>RefCell&lt;T&gt;</code> из главы 15: он имеет методы <code>borrow</code> и <code>borrow_mut</code>, которые возвращают
<code>Ref</code> и <code>RefMut</code>. Это определение структуры <code>Ref</code> без переменной времени жизни:</p>
<pre><code class="language-rust ignore">struct Ref&lt;'a, T&gt;(&amp;'a T);
</code></pre>
<p><span class="caption">код 19-16: определение структуры-оболочки для ссылки на обобщенный
тип без переменной времени жизни</span></p>
<p>Без связи обобщенного параметра и переменной времени жизни мы получим ошибку, т.к.
компилятор не знает как долго тип <code>T</code> будет существовать:</p>
<pre><code class="language-text">error[E0309]: the parameter type `T` may not live long enough
 --&gt; &lt;anon&gt;:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
  |
  = help: consider adding an explicit lifetime bound `T: 'a`...
note: ...so that the reference type `&amp;'a T` does not outlive the data it points at
 --&gt; &lt;anon&gt;:1:19
  |
1 | struct Ref&lt;'a, T&gt;(&amp;'a T);
  |                   ^^^^^^
</code></pre>
<p>Т.к. <code>T</code> может быть любым типом, <code>T</code> сам может быть ссылкой или типом содержащим
ссылки. Поэтому компилятор не может определить время жизни <code>T</code>.</p>
<p>Для решения этой задачу в Rust есть подсказка:</p>
<pre><code class="language-text">consider adding an explicit lifetime bound `T: 'a` so that the reference type
`&amp;'a T` does not outlive the data it points at.
</code></pre>
<p>Код 19-17 демонстрирует реализацию данного совета:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
#}</code></pre></pre>
<p><span class="caption">код 19-17: добавления ограничения времени жизни для <code>T</code></span></p>
<p>Мы можем решить эту задачу и другим способом. В коде 19-18 продемонстрирована
работа со статическими переменными. Это означает, что если <code>T</code> содержит какую-либо
ссылку, она должна иметь <code>'static</code> время жизни:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StaticRef&lt;T: 'static&gt;(&amp;'static T);
#}</code></pre></pre>
<p><span class="caption">код 19-18: добавление <code>'static</code> время жизни для <code>T</code> для
введения ограничения <code>T</code></span></p>
<p>Types without any references count as <code>T: 'static</code>. Because <code>'static</code> means the
reference must live as long as the entire program, a type that contains no
references meets the criteria of all references living as long as the entire
program (since there are no references). Think of it this way: if the borrow
checker is concerned about references living long enough, then there’s no real
distinction between a type that has no references and a type that has
references that live forever; both of them are the same for the purpose of
determining whether or not a reference has a shorter lifetime than what it
refers to.</p>
<a class="header" href="print.html#aПеременные-времени-жизни-объектов-типажей" id="aПеременные-времени-жизни-объектов-типажей"><h3>Переменные времени жизни объектов-типажей</h3></a>
<p>В главе 17 вы изучали объекты-типажи. Они применяются при динамической диспетчеризации.
Но мы ещё не обсуждали случай использования переменных времени жизни в таких
конструкциях. Рассмотрим такой пример. В коде 19-19 у нас есть типаж <code>Foo</code> и структура
<code>Bar</code>, которая содержит ссылку (и, следовательно, имеет переменную времени жизни):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo { }

struct Bar&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo for Bar&lt;'a&gt; { }

let num = 5;

let obj = Box::new(Bar { x: &amp;num }) as Box&lt;Foo&gt;;
#}</code></pre></pre>
<p><span class="caption">код 19-19: использование типа, который имеет переменную времени
жизни</span></p>
<p>Этот код компилируется без ошибок. Это происходит потому, что существуют правила
между типажами объектов и переменными времени жизни:</p>
<ul>
<li>по умолчанию ПВЖ для типажей-объектов <code>'static</code>.</li>
<li>если мы имеем <code>&amp;'a X</code> or <code>&amp;'a mut X</code>, то по умолчанию <code>'a</code>.</li>
<li>если мы имеем один <code>T: 'a</code>, то по умолчанию  <code>'a</code>.</li>
<li>если мы имеем множество <code>T: 'a</code> типов, то время жизни на до указывать явным образом.</li>
</ul>
<p>В случае явного указания времени жизни типажей-объектов, например <code>Box&lt;Foo&gt;</code>,
синтаксис будет следующий <code>Box&lt;Foo + 'a&gt;</code> или <code>Box&lt;Foo + 'static&gt;</code>.</p>
<p>Далее, мы рассмотрим расширенные возможности связанные с типажами.</p>
<a class="header" href="print.html#aРасширенные-опции-типажей" id="aРасширенные-опции-типажей"><h2>Расширенные опции типажей</h2></a>
<p>Мы уже познакомились с функционалом типажей в главе 10. Также как и переменные
времени жизни при первом знакомстве мы не раскрывали всех возможностей компонента
языка, остановившись лишь на основных. Теперь, когда вы стали уверенными пользователями
языка Rust, пора углубить ваши знания.</p>
<a class="header" href="print.html#aАссоциированные-типы" id="aАссоциированные-типы"><h3>Ассоциированные типы</h3></a>
<p>Ассоциированные типы (<em>Associated types</em>) - это способ связи ассоциированного
типа-конетейнера с типажом таким образом, чтобы методы типажа могли бы использовать
типы ассоциированных типов в своём описании. Реализация типажа будет использовать
конкретные типы, которые будут использованы в соответствующей реализации.</p>
<p>Мы описали большинство вещей в этой главе как очень редкие.
Связанные типы находятся где-то посередине; они используются реже, чем элементы, которые
описали ранее (в предыдущих главах), но более распространенны, чем многие из вещей
этой главы.</p>
<p>Примером типажа, который ассоциируется с типом является <code>Iterator</code>, который входит
в стандартную библиотеку. Он имеет ассоциированный тип <code>Item</code>, который содержит
тип элементов, которые могут быть использованы. В главе 13 мы уже рассматривали
использование итератора 19-20:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
#}</code></pre></pre>
<p><span class="caption">код 19-20: определение типажа <code>Iterator</code>, который имеет
ассоциированный тип <code>Item</code></span></p>
<p>Типаж <code>Iterator</code> имеет ассоциированный тип <code>Item</code>. <code>Item</code> является контейнером типа.
Метод <code>next</code> возвращает значение <code>Option&lt;Self::Item&gt;</code>. Реализации этого типажа
должны определить конкретный тип для <code>Item</code> и будет возвращать значения этого типа.</p>
<a class="header" href="print.html#aАссоциированные-типы-как-вид-обобщенных-типов" id="aАссоциированные-типы-как-вид-обобщенных-типов"><h4>Ассоциированные типы, как вид обобщенных типов</h4></a>
<p>Когда в коде 13-6 мы реализовали типаж <code>Iterator</code> для структуры <code>Counter</code>, мы
установили тип <code>Item</code> равным <code>u32</code>:</p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</code></pre>
<p>Всё это весьма напоминает обобщенные типы. Так почему же типаж <code>Iterator</code> не определён,
как в коде 19-21?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
#}</code></pre></pre>
<p><span class="caption">код 19-21: гипотетическое определение типажа <code>Iterator</code>
используя обобщенные типы</span></p>
<p>Отличием реализации 19-21 является то, что для каждого типа мы должны будет написать
реализацию. Например, для <code>String</code> <code>Iterator&lt;String&gt; for Counter</code>. Т.е. если типаж
имеет обобщенный параметр мы можем реализовать типаж для типа множество раз, при
этом каждый раз меняя обобщенный параметр на конкретный. Когда мы используем метод
<code>next</code> мы должны предоставить аннотации для указания какой <code>Iterator</code> должен быть
использован.</p>
<p>При работе с ассоциированными типам и мы не должны реализовывать типаж множество
раз. Используя определение <code>Iterator</code> из кода 19-20 мы только лишь выбираем один
раз каким будет тип <code>Item</code>. Т.е. необходима только лишь <code>impl Iterator for Counter</code>.</p>
<p>Есть ещё одно преимущество использования ассоциированных типов. Рассмотрим два
типажа в примере 19-22. Оба типажа используют узлы и углы. <code>GGraph</code> испльзует обобщенные
параметры, <code>AGraph</code> ассоциированные типы</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait GGraph&lt;Node, Edge&gt; {
    // methods would go here
}

trait AGraph {
    type Node;
    type Edge;

    // methods would go here
}
#}</code></pre></pre>
<p><span class="caption">код 19-22: для варианта определение типажа</span></p>
<p>Предположим, что мы хотим реализовать функцию, которая рассчитывать дистанцию
между узлами любого типа. В типаже  <code>GGraph</code> такая реализация будет иметь вид 19-23:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait GGraph&lt;Node, Edge&gt; {}
#
fn distance&lt;N, E, G: GGraph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 {
    // ...snip...
#     0
}
#}</code></pre></pre>
<p><span class="caption">код 19-23: представление описания функции <code>distance</code>, которая
использует типаж <code>GGraph</code> и которая должна указать все обобщенные параметры</span></p>
<p>Наша функция должна определить типы параметров <code>N</code>, <code>E</code> и <code>G</code>, где <code>G</code> ограничена
типажом <code>GGraph</code>, который имеет типы  <code>N</code> (<code>Node</code>), а <code>E</code> (<code>Edge</code>). Даже если
функция  <code>distance</code> не будет использовать данные типов углов, мы должны описать
<code>E</code>, т.к. мы используем типаж <code>GGraph</code> мы должны указать тип для <code>Edge</code>.</p>
<p>При использовании ассоциированных типов описание метода <code>distance</code> будет выглядеть
следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait AGraph {
#     type Node;
#     type Edge;
# }
#
fn distance&lt;G: AGraph&gt;(graph: &amp;G, start: &amp;G::Node, end: &amp;G::Node) -&gt; u32 {
    // ...snip...
#     0
}
#}</code></pre></pre>
<p><span class="caption">код 19-24: описание функции <code>distance</code>, которая использует
типаж <code>AGraph</code> и ассоциированный тип <code>Node</code></span></p>
<p>Такой вид намного нагляднее, т.к. нам нужно только один обобщенный параметр типа
<code>G</code>. Для использования типа <code>Node</code> ассоциированного с <code>AGraph</code> мы можем указать
<code>G::Node</code>.</p>
<a class="header" href="print.html#aИспользование-типажных-объектов-и-ассоциированных-типов" id="aИспользование-типажных-объектов-и-ассоциированных-типов"><h4>Использование типажных объектов и ассоциированных типов</h4></a>
<p>Вы, возможно, удивились почему мы не использовали типажи-объекты в функциях <code>distance</code>
в примерах 19-23 и Listing 19-24. Описание для функции <code>distance</code> при работе с
<code>GGraph</code> было бы более компактным при использование типажных объектов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait GGraph&lt;Node, Edge&gt; {}
#
fn distance&lt;N, E&gt;(graph: &amp;GGraph&lt;N, E&gt;, start: &amp;N, end: &amp;N) -&gt; u32 {
    // ...snip...
#     0
}
#}</code></pre></pre>
<p>This might be a more fair comparison to Listing 19-24. Specifying the <code>Edge</code>
type is still required, though, which means Listing 19-24 is still preferable
since we don’t have to specify something we don’t use.</p>
<p>It’s not possible to change Listing 19-24 to use a trait object for the graph,
since then there would be no way to refer to the <code>AGraph</code> trait’s associated
type.</p>
<p>It is possible in general to use trait objects of traits that have associated
types, though; Listing 19-25 shows a function named <code>traverse</code> that doesn’t
need to use the trait’s associated types in other arguments. We do, however,
have to specify the concrete types for the associated types in this case. Here,
we’ve chosen to accept types that implement the <code>AGraph</code> trait with the
concrete type of <code>usize</code> as their <code>Node</code> type and a tuple of two <code>usize</code> values
for their <code>Edge</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait AGraph {
#     type Node;
#     type Edge;
# }
#
fn traverse(graph: &amp;AGraph&lt;Node=usize, Edge=(usize, usize)&gt;) {
    // ...snip...
}
#}</code></pre></pre>
<p>Хотя при использовании типажных объектов вам не нужно знать конкретный тип
параметра <code>graph</code> во время компиляции, необходимо ограничить использование типажа
<code>AGraph</code> с помощью конкретных ассоциированных типов. Без их указания компилятор
не сможет понять, какую реализацию использовать.</p>
<a class="header" href="print.html#aПерезагрузка-операторов-и-типы-параметров-по-умолчанию" id="aПерезагрузка-операторов-и-типы-параметров-по-умолчанию"><h3>Перезагрузка операторов и типы параметров по умолчанию</h3></a>
<p>Синтаксис <code>&lt;PlaceholderType=ConcreteType&gt;</code> используется для указания типа по умолчанию
в обобщенном типе.</p>
<p>Rust не позволяет создавать собственные операторы или перезагружать произвольные
операторы. В тоже время возможно перезагружать операторы определенные в модуле
<code>std::ops</code>. Код 19-25 показывает, как перезагрузить оператор <code>+</code> с помощью
реализации типажа <code>Add</code> структурой <code>Point</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug,PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p><span class="caption">код 19-25: реализация типажа <code>Add</code> для перезагрузки оператора
<code>+</code> для структуры <code>Point</code></span></p>
<p>Мы реализовали метод <code>add</code>. Типаж <code>Add</code> имеет ассоциированный тип с именем <code>Output</code>,
который используется для определения типа данных в методе <code>add</code>.</p>
<p>Рассмотрим типаж <code>Add</code> более детально. Это его определение:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
#}</code></pre></pre>
<p>Эта конструкция похожа на типаж с одним методом и ассоциированным типом. Что-то
новенькое - это <code>RHS=Self</code> в угловых скобках. Этот синтаксис называется <em>параметрами
по умолчанию</em> (<em>default type parameters</em>). <code>RHS</code> является обобщенным типом параметра
(сокращение от “right hand side”). Если вы не определите конкретный тип для <code>RHS</code>
типом по умолчанию будет <code>Self</code>.</p>
<p>Рассмотрим другой пример реализации типажа <code>Add</code>. Представим, что у нас есть
структура содержащая значения в различных единицах изменения. Мы можем реализовать
<code>Add</code> для <code>Millimeters</code> различными способами 19-26:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Millimeters) -&gt; Millimeters {
        Millimeters(self.0 + other.0)
    }
}

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
#}</code></pre></pre>
<p><span class="caption">код 19-26: реализация типажа <code>Add</code> для <code>Millimeters</code>
для предоставления возможности добавлять <code>Millimeters</code> к <code>Millimeters</code> и
<code>Millimeters</code> к <code>Meters</code></span></p>
<p>Если мы прибавим <code>Millimeters</code> к другому <code>Millimeters</code> нам не нужно использовать
<code>RHS</code> с помощью определенного типа, т.к. по умолчанию используется тип <code>Self</code>.
Если мы хотим складывать <code>Millimeters</code> и <code>Meters</code>, в этом случае нам наобходимо
указать <code>impl Add&lt;Meters&gt;</code>.</p>
<p>Параметры по умолчанию используются в двух основных случаях:</p>
<ol>
<li>Чтобы расширить тип без внесения изменений в существующий код.</li>
<li>Чтобы позволить сделать улучшения, которые не хотят большинство пользователей.</li>
</ol>
<p>Пример второй цели: часто вы добавляете два типа вместе. Используя параметры по
умолчанию проще реализовать типаж без описания дополнительных параметров. Т.е.
мы переносим часто используемые определение в описание типажа.</p>
<a class="header" href="print.html#aИспользование-полного-имени-для-устранения-неоднозначности" id="aИспользование-полного-имени-для-устранения-неоднозначности"><h3>Использование полного имени для устранения неоднозначности</h3></a>
<p>Компилятор не может предотвратить создание метода с тем же именем, что и в другом
типаже. Также он не может препятствовать реализовать эти два типажа в одном типе.
Мы также можем реализовать этот метод непосредственно в типе. Для того чтобы указать
какой же из этих методов мы хотим использовать необходимо проделать это правильно
указать. В примере 19-27, где типажи <code>Foo</code> и <code>Bar</code> оба имеют метод <code>f</code> и мы реализуем
оба типажа в структуре <code>Baz</code>, которая также имеет метод <code>f</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Foo {
    fn f(&amp;self);
}

trait Bar {
    fn f(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
}

impl Bar for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
}

impl Baz {
    fn f(&amp;self) { println!(&quot;Baz's impl&quot;); }
}

fn main() {
    let b = Baz;
    b.f();
}
</code></pre></pre>
<p><span class="caption">код 19-27: реализация двух типажей, которые имеют метод с
одинаковым именем и которое совпадает с именем определенным в структуре</span></p>
<p>Для реализации метода <code>f</code> для <code>Foo</code> в <code>Baz</code> мы печатаем <code>Baz's impl of Foo</code>.
Для реализации метода <code>f</code> для <code>Foo</code> в <code>Bar</code> мы печатаем <code>Baz's impl of Bar</code>.
При реализации метода <code>f</code> в самом <code>Foo</code> будет напечатано <code>Baz's impl</code>. При вызове
метода <code>b.f()</code> будет напечатано <code>Baz's impl</code>.</p>
<p>Для того, чтобы вызвать метод типажа <code>Foo</code> из экземпляра <code>Foo</code> необходимо использовать
полное имя метода (<em>fully qualified syntax</em>):</p>
<pre><code class="language-rust ignore">receiver.method(args);
</code></pre>
<p>Описание полного имени метода выглядит следующим образом:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::method(receiver, args);
</code></pre>
<p>Поэтому для устранения неоднозначности и получения возможности вызова всех методов
<code>f</code>, определенных в листинге 19-27 мы указываем, что мы хотим рассматривать тип
<code>Baz</code>, как каждый признак в угловых скобках, затем используйте два двоеточия, затем
вызовите метод <code>f</code> и использовать экземпляр <code>Baz</code> в качестве первого аргумента.
В листинге 19-28 показано, как вызвать <code>f</code> из<code>Foo</code>, а затем <code>f</code> из<code>Bar</code> на <code>b</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"># trait Foo {
#     fn f(&amp;self);
# }
# trait Bar {
#     fn f(&amp;self);
# }
# struct Baz;
# impl Foo for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
# }
# impl Bar for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
# }
# impl Baz {
#     fn f(&amp;self) { println!(&quot;Baz's impl&quot;); }
# }
#
fn main() {
    let b = Baz;
    b.f();
    &lt;Baz as Foo&gt;::f(&amp;b);
    &lt;Baz as Bar&gt;::f(&amp;b);
}
</code></pre></pre>
<p><span class="caption">код 19-28: использование синтаксиса полного пути к методу
<code>f</code> в типажах <code>Foo</code> и <code>Bar</code></span></p>
<p>Будет напечатано:</p>
<pre><code class="language-text">Baz's impl
Baz’s impl of Foo
Baz’s impl of Bar
</code></pre>
<p>Для выбора нужного типажа вам необходимо указать нужный типаж в <code>&lt;&gt;</code>. Если же
необходимо вызвать метод типажа <code>Foo</code> непосредственно из <code>Baz</code>  можно написать так:
<code>Foo::f(&amp;b)</code>.</p>
<p>Таким образом можно вызвать и метод структуры <code>Baz::f(&amp;b)</code>.</p>
<a class="header" href="print.html#aСупертипажи-Реализация-наследования" id="aСупертипажи-Реализация-наследования"><h3>Супертипажи. Реализация наследования</h3></a>
<p>Бывает, что необходимо использовать функционал одного типажа в другом. Родительский
типаж называют супертипажом (<em>supertrait</em>).</p>
<p>Например, мы хотим реализовать типаж <code>OutlinePrint</code> с методом <code>outline_print</code>,
который печатает значения внутри звёздочек. Т.е. если структура <code>Point</code> реализует
<code>Display</code> и результатом будет текст <code>(x, y)</code>, то вызов <code>outline_print</code> текст вывода
будет выглядеть:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>В реализации <code>outline_print</code> мы хотим иметь возможность использовать <code>Display</code>.
Для этого необходимо описать типаж <code>OutlinePrint</code>, чтобы дать компилятору понять,
что он реализовал типаж <code>Display</code>. Мы можем сделать это в описании типажа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
#}</code></pre></pre>
<p><span class="caption">код 19-29: реализация типажа <code>OutlinePrint</code>, которая наследует
функциона <code>Display</code></span></p>
<p>Т.к. мы определили зависимость типажа <code>OutlinePrint</code> от <code>Display</code>, мы можим
использовать метод <code>to_string</code> в <code>outline_print</code>.</p>
<p>Если мы попытаемся реализовать <code>OutlinePrint</code>, в типе который не реализовал <code>Display</code>,
мы получим ошибку:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait OutlinePrint {}
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
#}</code></pre></pre>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for
   `Point`
   |
   = note: `Point` cannot be formatted with the default formatter; try using
   `:?` instead if you are using a format string
   = note: required by `OutlinePrint`
</code></pre>
<p>Реализация типажа <code>Display</code> в <code>Point</code> выглядит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point {
#     x: i32,
#     y: i32,
# }
#
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
#}</code></pre></pre>
<p>реализация типажа <code>OutlinePrint</code> в <code>Point</code> скомпилируется без ошибок. Мы можем
вызвать <code>outline_print</code> из экземпляра <code>Point</code> и увидеть результат.</p>
<a class="header" href="print.html#aШаблон-newtype-для-реализация-внешних-типажей-во-внешних-типах" id="aШаблон-newtype-для-реализация-внешних-типажей-во-внешних-типах"><h3>Шаблон Newtype для реализация внешних типажей во внешних типах</h3></a>
<p>В главе 10 мы упоминали о правиле, по которому следует, что дозволено реализация
типажей в типе только если они находятся в одном контейнере. Способом обойти это
ограничение является <em>newtype pattern</em>, который предназначен для создания нового
типа используя структур кортежа с одним полем.</p>
<p>In Chapter 10, we mentioned the orphan rule, which says we’re allowed to
implement a trait on a type as long as either the trait or the type are local
to our crate. One way to get around this restriction is to use the <em>newtype
pattern</em>, which involves creating a new type using a tuple struct with one
field as a thin wrapper around the type we want to implement a trait for. Then
the wrapper type is local to our crate, and we can implement the trait on the
wrapper. “Newtype” is a term originating from the Haskell programming language.
There’s no runtime performance penalty for using this pattern. The wrapper type
is elided at compile time.</p>
<p>Например, если мы хотим реализовать <code>Display</code> в <code>Vec</code>, мы можем создать структуру
<code>Wrapper</code>, которая содержит экземпляр <code>Vec</code>. Далее, мы реализуем <code>Display</code> для
<code>Wraper</code> и используем значение <code>Vec</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">код 19-30: создание типа <code>Wrapper</code> вокруг <code>Vec&lt;String&gt;</code>
для реализации <code>Display</code></span></p>
<p>Реализация <code>Display</code> использует <code>self.0</code> для доступа к внутреннему <code>Vec</code> и далее
мы можем использовать функционал <code>Display</code> в <code>Wrapper</code>.</p>
<p>Недостатком является то, что, поскольку «Wrapper» является новым типом, он не имеет
методов данных, которую он держит; мы должны были бы реализовать все методы <code>Vec</code>,
как <code>push</code>,<code>pop</code> и все остальное непосредственно на <code>Wrapper</code>, чтобы делегировать
<code>self.0</code> для того, чтобы иметь возможность рассматривать «Wrapper» точно так же,
как «Vec». Если бы мы хотим, чтобы новый тип имел все методы, который имеет
внутренний тип, реализуя <code>Deref</code>. Если мы не хотим, чтобы тип обертки имел все
методы внутреннего типа, чтобы ограничить поведение типа обертки, нам нужно будет
реализовать только те методы, которые мы хотим сами.</p>
<p>Вот как используется шаблон newtype по отношению к типажам; это также
полезный шаблон без вовлечения типажей. В следующей секции мы переключим внимание
на разговор о некоторых продвинутых способах взаимодействия с системой типов в Rust.</p>
<a class="header" href="print.html#aРасширенные-типы" id="aРасширенные-типы"><h2>Расширенные типы</h2></a>
<p>Система типа Rust имеет некоторые функции, которые мы упоминали или использовали
без обсуждение. Мы начали говорить о шаблоне newtype в отношении признаков;
мы начнем с более общей дискуссии о том, почему newtypes полезны как
типы. Затем мы перейдем к типу псевдонимов, который похож на newtypes
но имеет немного другую семантику. Мы также обсудим тип <code>!</code> И
динамически размерные типы.</p>
<a class="header" href="print.html#aИспользование-шаблон-для-безопасности-типов-и-реализации-абстракций" id="aИспользование-шаблон-для-безопасности-типов-и-реализации-абстракций"><h3>Использование шаблон для безопасности типов и реализации абстракций</h3></a>
<p>Шаблон newtype, который мы начали обсуждать в конце предыдущей секции, где мы
создаем новый тип как структуру кортежа с одним полем который обертывает тип,
также может быть полезен для статического применения этих значений.</p>
<a class="header" href="print.html#aСинонимы-типов" id="aСинонимы-типов"><h3>Синонимы типов</h3></a>
<p>Существует ключевое слово, которое позволяет создавать синониы типов. Например,
чтобы создать синоним <code>Kilometers</code> для <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;
#}</code></pre></pre>
<p>Это значит, что <code>Kilometers</code> является синонимом для <code>i32</code>. <code>Millimeters</code> и <code>Meters</code>
являются различными типами данных. Значения, к которым будет применяться тип
<code>Kilometers</code> будет считаться типом <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
#}</code></pre></pre>
<p>Т.к. <code>Kilometers</code> является синонимом <code>i32</code> они являются одинаковыми типами, т.е.
они взаимозаменяемы.</p>
<p>Синонимы в основном используются для уменьшения повторяемости. Например, мы у нас
есть тип:</p>
<pre><code class="language-rust ignore">Box&lt;Fn() + Send + 'static&gt;
</code></pre>
<p>Написание сигнатур функций и аннотаций типов может быть весьма утомительным и
нести ошибки. Например, у нас есть код:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f: Box&lt;Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;Fn() + Send + 'static&gt;) {
    // ...snip...
}

fn returns_long_type() -&gt; Box&lt;Fn() + Send + 'static&gt; {
    // ...snip...
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">код 19-31: использование длинных описаний типов</span></p>
<p>Синонимы типов могут сделать этот код более удобный для изучения и работы. В следующем
примере мы покажем как можно применить синонимы. Создадим синоним <code>Thunk</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Thunk = Box&lt;Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // ...snip...
}

fn returns_long_type() -&gt; Thunk {
    // ...snip...
#     Box::new(|| ())
}
#}</code></pre></pre>
<p><span class="caption">код 19-32: использование синонима <code>Thunk</code> для уменьшения
повторений</span></p>
<p>Ещё один пример использование синонима (в стандартной библиотеке):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
#}</code></pre></pre>
<p>Сделаем замену  <code>Result&lt;..., Error&gt;</code>:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<p>Because this is in the <code>std::io</code> module, the fully qualified alias that we can
use is <code>std::io::Result&lt;T&gt;</code>; that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code> filled in
as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up looking like
this:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<a class="header" href="print.html#the-never-type--that-never-returns" id="the-never-type--that-never-returns"><h3>The Never Type, <code>!</code>, that Never Returns</h3></a>
<p>Rust имеет специальный тип <code>!</code>. Это пустой тип, т.к. он не имеет знанчений. Мы
предпочитаем называть его, как <em>тип никогда</em> (<em>never type</em>). При использовании этого
типа в описании функции - он обозначает, что данная функция не возвращает какого-либо
значения:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // ...snip...
}
</code></pre>
<p>This is read as “the function <code>bar</code> returns never,” and functions that return
never are called <em>diverging functions</em>. We can’t create values of the type <code>!</code>,
so <code>bar</code> can never possibly return. What use is a type you can never create
values for? If you think all the way back to Chapter 2, we had some code that
looked like this, reproduced here in Listing 19-33:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let guess = &quot;3&quot;;
# loop {
let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
# break;
# }
#}</code></pre></pre>
<p><span class="caption">код 19-33: пример использования <code>continue</code> в <code>match</code></span></p>
<p>Рассмотрим другой пример (из главы 6). Данный код в отличии от предыдущего
не скомпилируется.</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse()  {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>Каким будет тип переменной <code>guess</code>? В Rust нельзя чтобы тип одновременно имеет
возможность содержать данные разных типов. Так почему же в предыдущем пример
всё работало. Это потому что <code>continue</code> возвращает тип <code>!</code>.</p>
<p>Еще один пример использования <code>!</code>-типа - макрос <code>panic!</code>. Пимер использования
<code>panic!</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>Т.к. <code>panic!</code> не возвращает типа - код компилируется.</p>
<p>Ещё одно выражение имеющее тип <code>!</code> является <code>loop</code>:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<a class="header" href="print.html#aТипы-динамического-размера--sized" id="aТипы-динамического-размера--sized"><h3>Типы динамического размера &amp; <code>Sized</code></h3></a>
<p>Т.к. Rust нужно знать размер памяти заранее, концепция динамической памяти может
возникнуть ощущение противоречивость. Далее раскроем эту концепцию.</p>
<p>Для этого рассмотрим тип, который мы использовали на протяжении всей книги - <code>str</code>.
<code>str</code> является примером использования динамической памяти. Обратите внимание, что
вы не можете создать переменную с данным типом данных:</p>
<pre><code class="language-rust ignore">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<p>Тут мы видим две переменные имеют разную длину. Поэтому нельзя создать переменную
динамической размерности.</p>
<p>Что же нам делать? Ответ мы уже знаем. Нужно создавать переменные ссылочного типа
<code>&amp;str</code>.</p>
<p>Обратите внимание, почему такой тип данные является действительным - ссылочный тип
всегда имеет фиксированный тип данных. Он состоит из двух частей - адреса и размера.</p>
<!-- Note for Carol: `Rc<str>` is only in an accepted RFC right now, check on
its progress and pull this out if it's not going to be stable by Oct -->
<p>While we’ve talked a lot about <code>&amp;str</code>, we can combine <code>str</code> with all kinds of
pointers: <code>Box&lt;str&gt;</code>, for example, or <code>Rc&lt;str&gt;</code>. In fact, you’ve already seen
this before, but with a different dynamically sized type: traits. Every trait
is a dynamically sized type we can refer to by using the name of the trait. In
Chapter 17, we mentioned that in order to use traits as trait objects, we have
to put them behind a pointer like <code>&amp;Trait</code> or <code>Box&lt;Trait&gt;</code> (<code>Rc&lt;Trait&gt;</code> would
work too). Traits being dynamically sized is the reason we have to do that!</p>
<a class="header" href="print.html#the-sized-trait" id="the-sized-trait"><h4>The <code>Sized</code> Trait</h4></a>
<!-- If we end up keeping the section on object safety in ch 17, we should add
a back reference here. /Carol -->
<p>Существует типаж, функционал которого сообщает компилятору имеет ли тип определённый
размер или нет. Это типа <code>Sized</code>. Этот типаж добавляется неявным образом каждый
раз при декларировании обобщенных типов:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // ...snip...
}
</code></pre>
<p>вот так выглядит код, если указывать супертипы явным образом:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // ...snip...
}
</code></pre>
<p>Также существую синтаксис который может сделать требования к типам более либеральные::</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // ...snip...
}
</code></pre>
<p>Т.е. может размер может быть известным, но может и не быть. Обратите внимание, что
такой синтаксис работает только совместно с типажом <code>Sized</code>.</p>
<p>Также обратите внимание, что мы переключили тип параметра <code>t</code> с<code>T</code> на <code>&amp; T</code>: поскольку
тип не может быть <code>Sized</code>, мы должны использовать его за каким-то указателем. В
в этом случае мы выбрали ссылку.</p>
<p>В следующей секции поговорим о функциях и закрытиях!</p>
<a class="header" href="print.html#aДополнительные-сведения-о-функциях-и-замыканиях" id="aДополнительные-сведения-о-функциях-и-замыканиях"><h2>Дополнительные сведения о функциях и замыканиях</h2></a>
<p>И наконец рассмотрим дополнительные сведения о функциях и замыканиях: указателях
на функции, наследующие функции и возвращение замыканий.</p>
<p>Finally, let’s discuss some advanced features having to do with functions and
closures: function pointers, diverging functions, and returning closures.</p>
<a class="header" href="print.html#aУказатели-на-функции" id="aУказатели-на-функции"><h3>Указатели на функции</h3></a>
<p>Вы уже знаете, как отправлять замыкания в функцию. Теперь мы рассмотри отправление
функции в функцию. Тип функции <code>fn</code>. Типаж функции <code>Fn</code>. <code>fn</code> является указателем
на функцию.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">код 19-34: использование типа <code>fn</code></span></p>
<p>будет напечатано <code>The answer is: 12</code>. Мы установили параметра <code>f</code> функции <code>do_twice</code>,
как  <code>fn</code>, который получает один параметр типа <code>i32</code> и возвращает <code>i32</code>. Далее
мы можем вызвать <code>f</code> в теле функции <code>do_twice</code>. В <code>main</code> мы можем отправить имя
функции <code>add_one</code>, как первый аргумент в <code>do_twice</code>.</p>
<p>В отличии от замыканий, <code>fn</code> является типом, а не типажом. Поэтому мы определяем
<code>fn</code>, как тип данных параметра.</p>
<p>Указатели на функции реализуют все три типажа замыканий (<code>Fn</code>, <code>FnMut</code> и <code>FnOnce</code>).
Поэтому мы всегда можем отправить указатель на функцию в качестве аргумента.
Предпочтительнее создавать функции используя обобщенные типы и типажи замыканий.
Единственное где вам обязательно могут понадобиться указатели на функции - это при работе
с внешними функциями (например, C-функциями).</p>
<p>Например, если мы хотим использовать функцию <code>map</code>, чтобы преобразовать числовой
вектор в строковый вектор, мы можем использовать замыкания:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
#}</code></pre></pre>
<p>Или мы можем использовать имя функции в качестве аргумента в <code>map</code> вместо замыкания:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
#}</code></pre></pre>
<p>Использовать замыкания или имена функций - выбор вкуса. Результат будет одинаковый.</p>
<a class="header" href="print.html#aВозвращение-замыканий" id="aВозвращение-замыканий"><h3>Возвращение замыканий</h3></a>
<p>Т.к. замыкания представляют типажами, возвращение замыканий немного сложно, т.к.
мы не можем этот сделать явным образом.
Because closures are represented by traits, returning closures is a little
tricky; we can’t do it directly. In most cases where we may want to return a
trait, we can instead use the concrete type that implements the trait of what
we’re returning as the return value of the function. We can’t do that with
closures, though. They don’t have a concrete type that’s returnable; we’re not
allowed to use the function pointer <code>fn</code> as a return type, for example.</p>
<p>Этот код не скомпилируется:</p>
<pre><code class="language-rust ignore">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>Описание ошибки:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt; &lt;anon&gt;:2:25
  |
2 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ the trait `std::marker::Sized` is
  not implemented for `std::ops::Fn(i32) -&gt; i32 + 'static`
  |
  = note: `std::ops::Fn(i32) -&gt; i32 + 'static` does not have a constant size
  known at compile-time
  = note: the return type of a function must have a statically known size
</code></pre>
<p>Опять типаж <code>Sized</code>! Rust не знает размер для хранения замыкания заранее. Для решения
задачи используем объект типажа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
#}</code></pre></pre>
<a class="header" href="print.html#aИтоги-14" id="aИтоги-14"><h2>Итоги</h2></a>
<p>Вуф! К этой части книги мы рассмотрели возможности Rust, которые не часто используются,
но доступны если ни вам понадобятся. Мы обзорно рассмотрели множество сложных тем.
Мы надеемся, что когда вы столкнетесь с описанными трудностями, вы сможете найти
решение, или, по крайней мере, будет знать что и где искать.</p>
<p>Теперь давайте воспользуемся всем тем, что мы изучили на протяжении всей книги,
реализуем ещё один проект!</p>
<a class="header" href="print.html#aЗаключительный-проект-реализация-многопоточного-веб-сервера" id="aЗаключительный-проект-реализация-многопоточного-веб-сервера"><h1>Заключительный проект: реализация многопоточного веб-сервера</h1></a>
<p>Это было длинным путешествием, но мы сделали это! Это окончание книги. Расставаться
всегда немного печально. Но прежде чем мы закончим, давайте построим еще один проект,
чтобы показать некоторые из вещей, которые мы узнали в этих заключительных главах,
а также переделайте некоторые из предыдущих.</p>
<p>Вот что мы собираемся сделать: веб-сервер, который приветствует:</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p>Шаги решения:</p>
<ol>
<li>Углубимся в тонкости TCP и HTTP</li>
<li>Реализуем обработчик TCP-соединений с помощью сокета</li>
<li>Проанализируем некоторое количество HTTP-запросов</li>
<li>Реализуем корректный HTTP-ответ (response)</li>
<li>Увеличьте пропускную способность нашего сервера с помощью пула потоков</li>
</ol>
<p>Прежде чем мы начнём, мы хотели бы вам сообщить, что уже существует множество
контейнеров с помощью функционала которых можно реализовать, или уже реализовавших
описанный нами функционал.</p>
<p>Однако в этой главе мы намерены учиться, а не просто найти простое решение. Т.к.
Rust является языком системного программирования, мы можем выбрать уровень абстракции,
с которым мы хотим работать. Мы можем перейти на более низкий уровень,
чем это возможно или практично на других языках. Итак, мы будем создавать
HTTP-сервер и пул потоков для того, чтобы понять идеи и методы, лежащие в основе
уже созданных решений, которые мы могли бы использовать в будущем.</p>
<a class="header" href="print.html#aОднопоточный-веб-сервер" id="aОднопоточный-веб-сервер"><h2>Однопоточный веб-сервер</h2></a>
<p>Для начала рассмотрим работу однопоточного веб-сервера. Мы будет работать с
байтовыми TCP и HTTP запросами и в качестве ответа будем возвращать HTML от клиента
к веб-серверу. Кратко рассмотрим протоколы, с которыми будет работать.</p>
<p><em>Протокол передачи гипертекста</em> (<em>HTTP</em>), который использует Интернет, построен
над <em>Протоколом управления передачей</em> (<em>TCP</em>). Мы не будем вдаваться в подробности,
но вот краткий обзор: TCP - это протокол низкого уровня, а HTTP строит протокол
более высокого уровня поверх TCP. Оба протокола - это то, что называется
<em>протокол запроса-ответа</em>, то есть <em>клиент</em>, который инициирует
запросов и <em>сервера</em>, который прослушивает запросы и предоставляет ответ
клиент. Содержание этих запросов и ответов определяют сами протоколы.</p>
<p>TCP описывает низкоуровневые сведения о том, как информация поступает с одного
сервера на другой, но не указывает, что это за информация; это всего лишь куча
единиц и нулей. HTTP строит поверх TCP, определяя, чем содержимое запросов и ответов
должны быть. Таким образом, технически возможно использовать HTTP с другими протоколами,
но в подавляющем большинстве случаев HTTP отправляет данные поверх TCP.</p>
<p>Итак, первое, что нам нужно создать для нашего веб-сервера - это прослушивание
TCP-соединение. В стандартной библиотеке есть модуль <code>std::net</code>, который позволяет
делать это. Создадим новый проект:</p>
<pre><code class="language-text">$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>И добавим код 20-1 в файл <code>src/main.rs</code>. Функционал будет прослушивать адрес
<code>127.0.0.1:8080</code> входящих TCP-потоков. Когда мы получим входящий поток, будет
напечатано <code>Connection established!</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">код 20-1: чтение входящих потоков и печать сообщения, когда
мы получаем поток </span></p>
<p><code>TcpListener</code> позволяет прослушивать TCP-соединения. Мы решили прослушивать адрес
<code>127.0.0.1:8080</code>. Адрес делится  <code>:</code> на две части. Левая часть содержать IP-адрес,
идентифицирующий компьютер в сети, а правая часть содержит порт <code>8080</code>. Мы выбрали
именно этот порт, т.к. HTTP обычно принимает порт 80, но подключение к порту 80
требует привилегий администратора. Обычные пользователи могу прослушивать порты
с номером начиная с 1024. Порт 8080 легко запомнить, т.к. он повторяет порт HTTP 80.</p>
<p>Функция <code>bind</code> что-то типа функции <code>new</code>. Она возвращает экземпляр <code>TcpListener</code>.
В сетевой терминологии, мы часто говорим о &quot;связывании с портом&quot;, поэтому функция,
которая создающая прослушивающее соединение называется <code>bind</code>.</p>
<p>Функция <code>bind</code> возвращает <code>Result&lt;T, E&gt;</code>. Связывание может быть неудачным, например,
если мы попытаемся соединиться с портом 80 без прав администратора. Другим примером
неудачи при связывании, это когда несколько программ пытаются получить доступ к
одному порту (например, два экземпляра одной программы). Т.к. мы собираемся делать
простой сервер и не собираемся беспокоится о подобных ошибках - мы просто будем
использовать <code>unwrap</code> для обработки возможных ошибок.</p>
<p>Метод <code>incoming</code> в<code>TcpListener</code> возвращает итератор, который предоставляет
последовательность потоков (более конкретно, потоки типа <code>TcpStream</code>).
<em>stream</em> представляет собой открытое соединение между клиентом и сервером.
<em>connection</em> - это имя для полного процесса запроса / ответа, когда клиент
подключается к серверу, сервер генерирует ответ, а сервер закрывает соединение.
Таким образом, «TcpStream» позволяет нам читать, чтобы увидеть, что клиент
отправил и мы можем написать наш ответ ему. Итак, этот цикл <code>for</code> будет обрабатывать
каждое соединение по очереди и производить серию потоков для обработки.</p>
<p>На данный момент обработка потока означает вызов <code>unwrap</code> для завершения нашей
программы, если поток имеет какие-либо ошибки, а затем печатает сообщение.
Ошибки могут произойти, потому что мы фактически не итерируем данные соединения,
мы итерируем через <em>попытки соединение</em>. Соединение может не работать по нескольким
причинам, многие из них специфические для операционной системы. Например, многие
операционные системы имеют ограниченное количество одновременных открытых соединений;
новые попытки подключения будут вызвать ошибку, пока некоторые из открытых соединений
не будут закрыты.</p>
<p>Давайте посмотрим, как работает этот код! Сначала вызовем <code>cargo run</code>, затем загрузим
<code>127.0.0.1:8080</code> в веб-браузере. В браузере появится сообщение об ошибке
скажет что-то похожее на «Сброс соединения», так как мы сейчас
отправка любых данных назад. Если мы посмотрим на наш терминал, мы увидим кучу
сообщения, которые были напечатаны при подключении браузера к серверу!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Мы получили несколько сообщений, распечатанных для одного запроса браузера; эти
соединения делал браузер для получения различных данных: делающий запрос на страницу
запрос на значок <code>favicon.ico</code>, отображаемый на вкладке браузера, или браузер может
быть повторить соединение. Наш браузер общается запросами HTTP, но мы не
ответили ни на один запрос, просто закрываем соединение, перейдя к следующему
итерации цикла. Когда <code>stream</code> выходит за пределы области действия и удалён в конце
цикла, его соединение закрывается как часть реализации <code>drop</code> для
<code>TcpStream</code>. Браузеры иногда обрабатывают закрытые соединения, повторяя, поскольку
проблема может быть временной. Важно то, что мы успешно создали простой обработчик
TCP-соединении!</p>
<p>Не забудьте остановить программу с помощью комбинации клавиш <span class="keystroke">ctrl-C</span>.</p>
<a class="header" href="print.html#aЧтение-запросов" id="aЧтение-запросов"><h3>Чтение запросов</h3></a>
<p>Давайте прочитаем запрос браузера! Для этого нам понадобится добавить функциональных
возможностей для этих целей. Создадим новую функцию для обработки соединения. В
этой функции (назовём её <code>handle_connection</code>) мы будем читать данные из потока
<code>stream</code> и выводить их на печать. Код 20-2:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">код 20-2: чтение из потока <code>TcpStream</code> и печать данных</span></p>
<p>Мы добавили <code>std::io::prelude</code> в начало, чтобы получить возможность использовать
функционал чтения и записи потока данных. Вместо того, чтобы печатать сообщение,
которое мы получили, мы используем функцию <code>handle_connection</code> и отправляем
<code>stream</code> в неё.</p>
<p>В функции <code>handle_connection</code> параметра <code>stream</code> является изменяемым <code>mut</code>. Во время
чтения из потока <code>TcpStream</code> мы можем прочитать больше запрашиваемых данных в буфер.
Также мы можем отслеживать полученную информацию. <code>mut</code> нам нужна т.к. поток
может изменяться.</p>
<p>Затем нам нужно прочитать из потока. Мы делаем это в два этапа: во-первых,
мы объявляем переменную <code>buffer</code> в стеке для хранения данных, которые мы читаем.
Мы сделали буфер размером 512 байт, который достаточно велик, чтобы хранить данные
запроса. Этого достаточно для наших целей в этой главе. Если бы мы хотели
обрабатывать запросы произвольного размера, управление буфером должно быть больше
сложным, но мы сохраняем его простым. Затем мы передаем буфер в <code>stream.read</code>,
который будет читать байты из<code>TcpStream</code> и помещать их в буфер.</p>
<p>Затем мы преобразуем байты в буфер в строку и распечатаем эту строку.
Функция <code>String::from_utf8_lossy</code> принимает <code>&amp;[u8]</code> и создает <code>String</code>.
<code>lossy</code> часть имени происходит от поведения, когда эта функция видит недействительные
последовательности UTF-8: она заменяет недопустимые последовательности на
�, <code>U+FFFD REPLACEMENT CHARACTER</code>. Вы можете увидеть заменяющие символы для оставшихся
символов в буфере, которые не заполняются данными запроса.</p>
<p>Давайте попробуем! Запустите программу и сделайте запрос в веб-браузере еще раз.
Обратите внимание, что в браузере все равно будет отображаться страница с ошибкой,
но вывод нашей программы в терминале теперь будут выглядеть примерно так:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>Вероятно, вы получите немного другой результат (это зависимости от вашего браузера).
Вы также может повторить этот запрос. Теперь, когда мы печатаем запрашивать данные,
мы можем понять, почему мы получаем несколько соединений от одного
запрос браузера, посмотрев путь после <code>Request: GET</code>. Если повторение
все соединения запрашивают <code>/</code>, мы знаем, что браузер пытается извлечь <code>/</code>
неоднократно, так как он не получает от нас ответа.</p>
<p>Давайте разберем данные запроса, чтобы понять, что браузер запрашивает у нас.
HTTP - это текстовый протокол, и запрос принимает этот формат:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>Первая строка называется <em>строкой запроса</em>, и она содержит информацию о
что клиенте. Первая часть строки запроса - это <em>метод</em>, например <code>GET</code> или<code>POST</code>,
который описывает, как клиент делает этот запрос.</p>
<p>Затем идёт <em>URI</em> запроса, который обозначает <em>Uniform Resource Identifier</em>.
URI являются почти, но не совсем такими же, как URL (<em>Uniform Resource Locators</em>),
что мы обычно называем адресами, которые мы вводим в веб-браузер.
Спецификация HTTP использует термин URI, а разница между URI и URL-адресами не является
важной для наших целей этой главы, поэтому мы можем просто мысленно заменить
URL для URI здесь.</p>
<p>Затем идёт версия HTTP, которую использовал клиент, а затем строка запроса
заканчивается последовательностью CRLF. Последовательность CRLF также может быть
записана как <code>\ r \ n</code>:<code>\ r</code> - это <em>возврат каретки</em>, а <code>\ n</code> - <em>перевод строка</em>.
Эти термины остались со времён пишущие машинки! Последовательность CRLF отделяет
строку запроса от остальной части данные запроса.</p>
<p>Взглянув на данные строки запроса, мы увидели наш код:</p>
<pre><code class="language-text">GET / HTTP/1.1
</code></pre>
<p><code>GET</code> является методом, <code>/</code> URI запроса и <code>HTTP/1.1</code> версией протокола.</p>
<p>Остальные строки, начинающиеся с <code>Host:</code> - являются заголовками; Запросы <code>GET</code>
не имеют тела.</p>
<p>Посмотрите, как будут меняться данные при использовании разных браузеров или при попытке
получить разные данные (<code>127.0.0.1:8080/test</code>).</p>
<p>Теперь, когда мы знаем, что запрашивает браузер, давайте вернем некоторые данные!</p>
<a class="header" href="print.html#aНаписание-ответа-браузеру" id="aНаписание-ответа-браузеру"><h3>Написание ответа браузеру</h3></a>
<p>Отправим данные обратно в наш браузер в ответ на его запрос. Формат ответа:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>Первая строка называется <em>строкой статуса</em> и содержит версию HTTP, используемую в
ответе, числовой код состояния, который описывает результат запроса текстовое описание
кода состояния. После последовательности CRLF могут идти заголовки в любом порядке,
другую последовательность CRLF и тело ответа.</p>
<p>Вот пример ответа, который использует версию 1.1 HTTP, имеет код состояния
<code>200</code>, фразу <code>OK</code> и никаких заголовков и тела:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>Этот текст является простым успешным ответом HTTP. Давайте напишем его в поток!
Удалите <code>println!</code>, который печатает данные запроса, и добавьте код в код 20-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">код 20-3: написание простого успешного HTTP-ответа в поток</span></p>
<p>Первая новая строка определяет переменную <code>response</code>, которая содержит данные
успешного ответа, который мы отправляем обратно. Затем мы вызываем <code>as_bytes</code>
<code>response</code>, потому что метод<code>write</code> в <code>stream</code> принимает<code>&amp; [u8]</code>и отправляет
эти байты непосредственно вниз по соединению.</p>
<p>Операция <code>write</code> может завершиться неудачей, поэтому<code>write</code> возвращает <code>Result &lt;T, E&gt;</code>;
мы продолжает использовать <code>unwrap</code> для обработки ошибок. Наконец, <code>flush</code> будет
ожидать, пока все байты записываются в соединение; <code>TcpStream</code> содержит внутренний
буфер для минимизирования вызовов в базовую операционную систему.</p>
<p>С этими изменениями давайте запустим наш код и сделаем запрос! Мы больше не будем
печатать каких-либо данных на терминал, поэтому мы не увидим каких-либо результатов,
кроме выход от Cargo. Когда мы загружаем <code>127.0.0.1:8080</code> в веб-браузере, вместо
ошибки мы получаем пустую страницу. Ура! Вы только что закодированы вручную
HTTP-запрос и ответ!</p>
<a class="header" href="print.html#aВозвращение-html-браузеру" id="aВозвращение-html-браузеру"><h3>Возвращение HTML браузеру</h3></a>
<p>Давайте вернем больше, чем просто пустую страницу. Создайте новый файл, * hello.html *,
в корневой папке вашего каталога проекта, то есть не в каталоге <code>src</code>. Вы можете
поместите любой HTML-код в него. Например, код 20-4:</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">код 20-4: содержание HTML-файла, который будет возвращаться
при ответе</span></p>
<p>Это простой HTML-файл с заголовком и абзацем. Для его отправке браузеру изменим
код нашей программы (функцию <code>handle_connection</code>), как показано в коде 20-5:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
use std::fs::File;

// ...snip...

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let mut file = File::open(&quot;hello.html&quot;).unwrap();

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">код 20-5: отправка содержания HTML-файла <em>hello.html</em> браузеру</span></p>
<p>Мы добавили строку вверху, чтобы добавить ссылку на <code>File</code> стандартной библиотеки.
Код открытия и чтения файла должен быть вам уже знаком, поскольку мы уже имели
аналогичный код в главе 12, когда мы читали содержимое файла для нашего ввода-вывода
в коде 12-4.</p>
<p>Затем мы используем макрос `format!', чтобы добавить содержимое файла в качестве
тела ответ ответа, который мы пишем в поток.</p>
<p>С помощью команды <code>cargo run</code> и запроса браузера <code>127.0.0.1:8080</code> мы можем увидеть
результат работы программы в окне браузера.</p>
<p>Обратите внимание, что мы в настоящее время игнорируем данные запроса в переменной
<code>buffer</code> и отправляем содержимое файла HTML. Попробуйте запросить
<code>127.0.0.1:8080/something-else</code> в вашем браузере, и мы увидим тот же HTML-код.
Отправка назад того же ответа для всех запросов довольно ограничена. Давайте теперь
анализировать запрос и будем обрабатывать только правильно оформленные запросы
на адрес <code>/</code>.</p>
<a class="header" href="print.html#aПроверка-запроса-и-выборочное-возвращение-ответа" id="aПроверка-запроса-и-выборочное-возвращение-ответа"><h3>Проверка запроса и выборочное возвращение ответа</h3></a>
<p>Прямо сейчас наш веб-сервер возвращает HTML независимо от того, что клиент запросил.
Давайте проверим, что браузер запрашивает <code>/</code> или будем возвращать ошибку, если
браузер запрашивает что-либо еще. Давайте изменим <code>handle_connection</code>, как показано
в коде 20-6, который содержать необходимые изменения. Этот код проверяет содержимое
полученного нами запроса:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// ...snip...

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let mut file = File::open(&quot;hello.html&quot;).unwrap();

        let mut contents = String::new();
        file.read_to_string(&amp;mut contents).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    };
}
#}</code></pre></pre>
<p><span class="caption">код 20-6: Согласование запроса с содержанием. Мы ожидаем запрос
<code>/</code>. Для этого мы настраиваем анализ строки</span></p>
<p>Here, we hardcoded the data corresponding to the request that we’re looking for
in the variable <code>get</code>. Because we’re reading raw bytes into the buffer, we use
a byte string, created with <code>b&quot;&quot;</code>, to make <code>get</code> a byte string too. Then, we
check to see if <code>buffer</code> starts with the bytes in <code>get</code>. If it does, we’ve
gotten a well-formed request to <code>/</code>, which is the success case that we want to
handle in the <code>if</code> block. The <code>if</code> block contains the code we added in Listing
20-5 that returns the contents of our HTML file.</p>
<p>If <code>buffer</code> does not start with the bytes in <code>get</code>, we’ve gotten some other
request. We’ll respond to all other requests using the code we’re about to add
in the <code>else</code> block.</p>
<p>If you run this code and request <code>127.0.0.1:8080</code>, you’ll get the HTML that’s
in <em>hello.html</em>. If you make any other request, such as
<code>127.0.0.1:8080/something-else</code>, you’ll get a connection error like we saw when
running the code in Listing 20-1 and Listing 20-2.</p>
<p>Let’s add code to the <code>else</code> block as shown in Listing 20-7 to return a
response with the status code <code>404</code>, which signals that the content for the
request was not found. We’ll also return HTML for a page to render in the
browser indicating as such to the end user:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
# fn handle_connection(mut stream: TcpStream) {
# if true {
// ...snip...

} else {
    let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let mut file = File::open(&quot;404.html&quot;).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
# }
#}</code></pre></pre>
<p><span class="caption">Listing 20-7: Responding with status code <code>404</code> and an
error page if anything other than <code>/</code> was requested</span></p>
<p>Here, our response has a status line with status code <code>404</code> and the reason phrase
<code>NOT FOUND</code>. We still aren’t returning any headers, and the body of the
response will be the HTML in the file <em>404.html</em>. Also create a <em>404.html</em> file
next to <em>hello.html</em> for the error page; again feel free to use any HTML you’d
like or use the example HTML in Listing 20-8:</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Sample content for the page to send back
with any <code>404</code> response</span></p>
<p>With these changes, try running your server again. Requesting <code>127.0.0.1:8080</code>
should return the contents of <em>hello.html</em>, and any other request, like
<code>127.0.0.1:8080/foo</code>, should return the error HTML from <em>404.html</em>!</p>
<p>There’s a lot of repetition between the code in the <code>if</code> and the <code>else</code> blocks:
they’re both reading files and writing the contents of the files to the stream.
The only differences between the two cases are the status line and the
filename. Let’s pull those differences out into an <code>if</code> and <code>else</code> of one line
each that will assign the values of the status line and the filename to
variables; we can then use those variables unconditionally in the code to read
the file and write the response. The resulting code after this refactoring is
shown in Listing 20-9:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// ...snip...

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
#
#     let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    // ...snip...

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let mut file = File::open(filename).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
#}</code></pre></pre>
<p><span class="caption">код 20-9: сокращение строчек кода</span></p>
<p>Here, the only thing the <code>if</code> and <code>else</code> blocks do is return the appropriate
values for the status line and filename in a tuple; we then use destructuring
to assign these two values to <code>status_line</code> and <code>filename</code> using a pattern in
the <code>let</code> statement like we discussed in Chapter 18.</p>
<p>The duplicated code to read the file and write the response is now outside the
<code>if</code> and <code>else</code> blocks, and uses the <code>status_line</code> and <code>filename</code> variables.
This makes it easier to see exactly what’s different between the two cases, and
makes it so that we only have one place to update the code if we want to change
how the file reading and response writing works. The behavior of the code in
Listing 20-9 will be exactly the same as that in Listing 20-8.</p>
<p>Отлично! Мы реализовали простейший веб-сервер и уложилисьв 40 строчек кода. Мы
реализовали логичные ответ - если запрашивается страница - возвращаем страницу,
если что-либо ещё - возвращаем страницу с информацией об ошибке <code>404</code>.</p>
<p>Т.к. сервер работает в однопоточном режиме, одновременно он может обрабатывать
только один запрос. Далее мы смоделируем работу сервера под нагрузкой.</p>
<a class="header" href="print.html#aКак-медленные-запросы-влияют-на-пропускную-способность" id="aКак-медленные-запросы-влияют-на-пропускную-способность"><h2>Как медленные запросы влияют на пропускную способность</h2></a>
<p>Сейчас наш сервер обрабатывает каждый запрос по очереди. Это работает для систем
с небольшой загрузкой (которая получает не очень много запросов), но как только
приложения становятся более сложными, такая реализация уже не будет оптимальной.</p>
<p>Поскольку наша текущая программа последовательно обрабатывает соединения, она не будет
обработать второе соединение, пока оно не завершит обработку первого. Если мы
получить один запрос, который требует много времени для обработки, запросам,
поступающие во время обработки придется подождать, пока длинный запрос не будет
завершен, даже если новый запрос может быть обработан быстро. Давайте посмотрим
на это в действии.</p>
<a class="header" href="print.html#aИмитация-медленного-запроса-в-реализации-текущего-сервера" id="aИмитация-медленного-запроса-в-реализации-текущего-сервера"><h3>Имитация медленного запроса в реализации текущего сервера</h3></a>
<p>Давайте посмотрим на эффект от запроса, который требует много времени для обработки.
В коде 20-10 показано, пример симуляции медленной обработки запроса. Код при ответе
на запрос <code>/sleep</code>, сервер &quot;заснёт&quot; на пять секунд.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;
# use std::io::prelude::*;
# use std::net::TcpStream;
# use std::fs::File;
// ...snip...

fn handle_connection(mut stream: TcpStream) {
#     let mut buffer = [0; 512];
#     stream.read(&amp;mut buffer).unwrap();
    // ...snip...

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // ...snip...
}
#}</code></pre></pre>
<p><span class="caption">код 20-10: симуляция обработки медленного запроса</span></p>
<p>Мы создали специальный запрос <code>sleep</code>. При выполнении данного запроса будет 5-секундная
задержка, перед тем, как отобразиться содержимое файла &quot;hello.html&quot;.</p>
<p>Вы можете увидеть в реальном времени, насколько прост наш сервер. В реальных проекта
может происходить и более длинная задержка.</p>
<p>Запустите программу командой <code>cargo run</code>, а затем в окне браузеры запросите данные
по адресам <code>http://localhost:8080/</code> и <code>http://localhost:8080/sleep</code>. Если вы запросите
данные и строка запроса будет начинаться с <code>/</code> даже несколько раз - вы получите
быстрый ответ. Но если вы запросите <code>/sleep</code> и затем попробуете ещё раз получить
данные стартовой страницы - вы будете ожидать пока <code>sleep</code> код функции не закончит
ожидания и не приступит к дальнейшей работе.</p>
<p>Существует несколько способов изменить работу нашего веб-сервера, чтобы избежать
повторного запроса всех запросов следовавших за медленным запросом. Тот, что мы
собираемся реализовать называется пулом потоков.</p>
<a class="header" href="print.html#aУлучшение-пропускной-способности-пула-потоков" id="aУлучшение-пропускной-способности-пула-потоков"><h3>Улучшение пропускной способности пула потоков</h3></a>
<p><em>Пул потоков</em> - группа порожденных потоков, которые готовы обрабатывать некоторые
задача. Когда программа получает новую задачу, один из потоков в пуле будет
назначен выполнять эту задачу. Остальные потоки в пуле доступны для обработки
любых других задач, которые могут возникнуть во врем работы занятого потока.</p>
<p>Пул потоков позволит нам одновременно обрабатывать соединения: мы можем начать
обработку нового соединения до завершения старого соединения. Это увеличит
пропускную способность нашего сервера.</p>
<p>Итак, вот что мы собираемся реализовать: вместо ожидания каждого запроса
перед тем, как начать с следующей, мы отправим обработку каждого
соединение с другой поток. Потоки будут поступать из пула, который мы будем создавать
после запуска программы на выполнение. Причина, по которой мы ограничиваем
число потоков на небольшое число (четыре) - потому, что если бы мы создавали бы
новый поток для каждого запроса, то ресурсы системы были бы быстро израсходованы
при увеличении количества запросов.</p>
<p>Вместо того, чтобы создавать неограниченное количество потоков, у нас будет фиксированное
их количество в пуле. По мере поступления запросов мы будем отправлять запросы в
пул для обработки. Пул будет поддерживать очередь входящих запросов. Каждый из
потоков в пуле получает запрос из этой очереди, обрабатывает его, а затем запрашивает
следующий. С таким дизайном мы можем обрабатывает <code>N</code> запросы одновременно, где
<code>N</code> - количество потоков. Эта все равно означает, что длительные запросы <code>N</code> могут
привести к резервному копированию запросов в очереди, но мы увеличили количество
длительных запросов, которые мы можем обрабатывать до этого момента от одного до <code>N</code>.</p>
<p>Такое решение является одним из способов повысить пропускную способность нашего
веб-сервера. Однако, это книга не о веб-серверах, поэтому мы не будем углубляться
в проблемы реализаций. Скажем только, что способами увеличения пропускной способности
является модель fork/join и модель однопоточного асинхронного ввода-выводы. Если
вас интересует эта тема, вы можете больше узнать о ней и попытаться реализовать их
в Rust. Rust является языком низкого уровня и может реализовать все эти модели.</p>
<a class="header" href="print.html#aПроектирование-интерфейса-пула-потоков" id="aПроектирование-интерфейса-пула-потоков"><h2>Проектирование интерфейса пула потоков</h2></a>
<p>Давайте поговорим о том, как должен выглядеть пул. Авторы часто находят
что при попытке создать некоторый код, напив сначала клиентский интерфейс можно
лучше понять как лучше реализовать серверную часть. Напишите API кода, который будет
структурирован таким образом, чтобы его было удобно вызывать, а затем реализуйте
функциональность этой структуры, а не наоборот.</p>
<p>Подобно тому, как мы использовали Test Driven Development в проекте в главе 12,
здесь мы собираемся использовать Compiler Driven Development. Мы собираемся написать
код, который вызывает функции, которые мы хотели бы иметь. Ошибки компиляции будут
направлять нашу дальнейшую разработку</p>
<a class="header" href="print.html#aСтруктура-кода-при-использовании-threadspawn" id="aСтруктура-кода-при-использовании-threadspawn"><h3>Структура кода при использовании <code>thread::spawn</code></h3></a>
<p>Первое, мы рассмотрим код, который нам нужно реализовать для создания нового
потока. Это не будет окончательным решение, т.к. существует потенциальная проблема
(создание множества потоков), о которой мы говорили ранее. В коде 20-11 показаны
изменения в функции <code>main</code>, которые необходимы для создания нового потока в цикле
<code>for</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">код 20-11: Создание нового потока для каждого соединения с колентом</span></p>
<p>Как мы узнали в главе 16, <code>thread::spawn</code> создаст новый поток, а затем запустит
код в замыкании. Если вы запустите этот код и загрузите <code>/sleep</code> и затем <code>/</code> в
двух вкладках браузера, вы действительно увидите, что запрос <code>/</code> не будет
дождаться окончания <code>/sleep</code>. Но, как мы уже говорили, это в конечном итоге
будет избыточно расходовать ресурсы системы, так как мы создаем новые потоки
без ограничений.</p>
<a class="header" href="print.html#aРеализация-подобного-интерфейса-с-помощью-threadpool" id="aРеализация-подобного-интерфейса-с-помощью-threadpool"><h3>Реализация подобного интерфейса с помощью <code>ThreadPool</code></h3></a>
<p>Мы хотим, чтобы пул потоков работал похожим образом. В коде 20-12 заменим
предыдущее решения использование структуры <code>ThreadPool</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"># use std::thread;
# use std::io::prelude::*;
# use std::net::TcpListener;
# use std::net::TcpStream;
# struct ThreadPool;
# impl ThreadPool {
#    fn new(size: u32) -&gt; ThreadPool { ThreadPool }
#    fn execute&lt;F&gt;(&amp;self, f: F)
#        where F: FnOnce() + Send + 'static {}
# }
#
fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
# fn handle_connection(mut stream: TcpStream) {}
</code></pre></pre>
<p><span class="caption">код 20-12: использование <code>ThreadPool</code> без реализации</span></p>
<p>Мы используем <code>ThreadPool::new</code> для создания нового пула с изменяемым количеством
потоков (в данном случае 4). Далее в цикле <code>for</code> мы выполняем <code>pool.execute</code> также
как мы выполняли <code>thread::spawn</code>.</p>
<a class="header" href="print.html#aИспользование-compiler-driven-development-для-реализации-рабочего-кода" id="aИспользование-compiler-driven-development-для-реализации-рабочего-кода"><h3>Использование Compiler Driven Development для реализации рабочего кода</h3></a>
<p>Давайте попробуем скомпилировать данный код. Мы получим следующие ошибки:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<p>Отлично! Нам нужен <code>ThreadPool</code>. Давайте вернёмся к контейнеру из бинарного файла.
Реализация <code>ThreadPool</code> будет независимой от работы веб-сервера. После того, как
библиотека реализующая работу пула потоков будет написана, мы сможем использовать
её в любых реализациях.</p>
<p>Итак, контейнер будет содержать файл <em>src/lib.rs</em>  с простыми определением структуры
<code>ThreadPool</code>, которую мы сейчас можем иметь:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;
#}</code></pre></pre>
<p>Далее, мы создаём новую папку <em>src/bin</em> и перемещаем бинарный контейнер  <em>src/main.rs</em>
в <em>src/bin/main.rs</em>. Это сделает библиотечный контейнер основным в папке <em>hello</em>.
Это перемещение не повлияет на порядок запуска <code>cargo run</code> бинарного файла. После
перемещения файла <em>main.rs</em> внесите в самом верху текста программы изменения,
описав подключение библиотеки <code>hello</code> и её содержания в область программы
<em>src/bin/main.rs</em>:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;
</code></pre>
<p>Далее, попытайтесь теперь проверить корректность нашего кода, получил следующие
указания компилятора для нас:</p>
<pre><code class="language-text">$ cargo check --bins
   Compiling hello v0.1.0 (file:///projects/hello)
error: no associated item named `new` found for type `hello::ThreadPool` in the
current scope
  --&gt; src\main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^
   |
</code></pre>
<p>Отлично! Следующим нашим действием будет реализация функции <code>new</code> для структуры
<code>ThreadPool</code>. Также мы знаем, что функции <code>new</code> потребуется один параметр, который
может принять знание <code>4</code> в качестве аргумента. Также эта функция должна возвращать
экземпляр структуры <code>ThreadPool</code>. Давайте реализуем такую функцию, которая будет
иметь все эти характеристики:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: u32) -&gt; ThreadPool {
        ThreadPool
    }
}
#}</code></pre></pre>
<p>Му установили <code>u32</code> в качестве типа входящего параметра переменной <code>size</code>, т.к.
отрицательные значения не имеют смысла. Запустим проверку узнаем наше следующее
рекомендуемое действие:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`, #[warn(unused_variables)] on by default
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: u32) -&gt; ThreadPool {
  |                ^^^^

error: no method named `execute` found for type `hello::ThreadPool` in the
current scope
  --&gt; src/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<p>Отлично. Предостережение и ошибка. Пока проигнорируем предостережение. Исправим
ошибку. Реализуем метод <code>execute</code>. Если вы помните главу 13, мы можем использовать
замыкание в качестве параметра, как в трёх различных типажах: <code>Fn</code>, <code>FnMut</code> и <code>FnOnce</code>.
Какой же типаж нам лучше использовать? Т.к. мы должны реализовать что-то вроде
<code>thread::spawn</code> мы можем посмотреть документацию:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p><code>F</code> is the parameter we care about here; <code>T</code> is related to the return value and
we’re not concerned with that. Given that <code>spawn</code> uses <code>FnOnce</code> as the trait
bound on <code>F</code>, it’s probably what we want as well, since we’ll eventually be
passing the argument we get in <code>execute</code> to <code>spawn</code>. We can be further
confident that <code>FnOnce</code> is the trait that we want to use since the thread for
running a request is only going to execute that request’s closure one time.</p>
<p><code>F</code> also has the trait bound <code>Send</code> and the lifetime bound <code>'static</code>, which
also make sense for our situation: we need <code>Send</code> to transfer the closure from
one thread to another, and <code>'static</code> because we don’t know how long the thread
will execute. Let’s create an <code>execute</code> method on <code>ThreadPool</code> that will take a
generic parameter <code>F</code> with these bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    // ...snip...

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
#}</code></pre></pre>
<p>The <code>FnOnce</code> trait still needs the <code>()</code> after it since this <code>FnOnce</code> is
representing a closure that takes no parameters and doesn’t return a value.
Just like function definitions, the return type can be omitted from the
signature, but even if we have no parameters, we still need the parentheses.</p>
<p>Again, since we’re working on getting the interface compiling, we’re adding the
simplest implementation of the <code>execute</code> method, which does nothing. Let’s
check again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`, #[warn(unused_variables)] on by default
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: u32) -&gt; ThreadPool {
  |                ^^^^

warning: unused variable: `f`, #[warn(unused_variables)] on by default
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
</code></pre>
<p>Обратите внимание, что код компилируется. Но если вы попытаетесь запустить программу
<code>cargo run</code> вы получите ошибки, как в начала нашей главы. Пока наша библиотека не
готова к использованию.</p>
<blockquote>
<p>О языках со строгими компиляторами говорят (как о Haskell  и Rust), что если
код компилируется - он работает. Очень важно понять, что это всего лишь этап, а
не конечное решение. Наш код компилируется, но он пока ещё ничего не делает. Сейчас
наступает этап написать тесты, которые бы проверили бы корректность поведения кода.</p>
</blockquote>
<a class="header" href="print.html#aСоздание-пула-потоков-и-сохранение-в-него-потоков" id="aСоздание-пула-потоков-и-сохранение-в-него-потоков"><h2>Создание пула потоков и сохранение в него потоков</h2></a>
<p>Предостережения компилятора сообщают о том, что код не использует методы и параметры.
Далее мы реализуем функционал.</p>
<a class="header" href="print.html#aПроверка-количества-потоков-в-пуле" id="aПроверка-количества-потоков-в-пуле"><h3>Проверка количества потоков в пуле</h3></a>
<p>Для начала рассмотрим метод <code>new</code>. Он получает целочисленное положительное значение.
Обратите внимание, что пул с нулевым количеством потоков имеет смысл, т.к. 0 может
иметь тип <code>u32</code>. Реализуем проверку значения параметра количества потоков перед
возвращение экземпляра <code>ThreadPool</code> и используем макрос <code>panic!</code> если значение равно</p>
<ol start="0">
<li>Для этого используем макрос <code>assert!</code>:</li>
</ol>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# pub struct ThreadPool;
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: u32) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // ...snip...
}
#}</code></pre></pre>
<p><span class="caption">код 20-13: реалазация функции <code>ThreadPool::new</code>, которая прервёт
работу программы, если переменная <code>size</code> будет равна <code>0</code></span></p>
<p>Обратите внимание, что добавили информацию для генерации документации. Это хороший
тон добавлять секции документации. Она будет весьма полезна, чтобы узнать почему
же код не сработал (это мы обсуждали в главе 14). Запустим нашу программу с помощью
команды <code>cargo doc --open</code> и посмотрим на созданную документацию.</p>
<p>Вместо добавления макроса <code>assert!</code> мы также могли бы использовать решение и примера
12-9. Если вы уверены в своих знаниях Rust API, реализуйте метод <code>new</code> такого вида:</p>
<pre><code class="language-rust ignore">fn new(size: u32) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<a class="header" href="print.html#aСохранение-потоков-в-пуле" id="aСохранение-потоков-в-пуле"><h3>Сохранение потоков в пуле</h3></a>
<p>После того, как вы проверили корректность входных данных мы можем приступить к
созданию нужного количества потоков и сохранить их в экземпляре структуры <code>ThreadPool</code>
перед тем как возвратить экземпляр.</p>
<p>Возникает вопрос, как же всё-таки сохранять потоки? Рассмотрим метод <code>thread::spawn</code>
ещё раз:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p><code>spawn</code> возвращает экземпляр <code>JoinHandle&lt;T&gt;</code>, где <code>T</code> является типом возвращаемого
значения из замыкания. Попробуем использовать <code>JoinHandle&lt;T&gt;</code>.  В нашем случае,
замыкание, которое мы посылаем в пул потоков будет обрабатывать соединение и ничего
не возвращать. Т.е. <code>T</code> будет действительно пока будет действителен пустой кортеж
<code>()</code>.</p>
<p>Приведём идею решения, которое ещё пока не будет компилироваться (код 201-14).
Мы изменим определение <code>ThreadPool</code>, чтобы он хранил вектор с объемом и размером,
реализуем цикл <code>for</code> таким образом, чтобы о н создавал потоки и возвращал экземпляр
<code>ThreadPool</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // ...snip...
    pub fn new(size: u32) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // ...snip...
}
</code></pre>
<p><span class="caption"> 20-14: создание вектора для хранения потоков в <code>ThreadPool</code></span></p>
<p>Мы добавили использование <code>std::thread</code>, т.к. нам понадобиться использовать
<code>thread::JoinHandle</code> в качестве типа элементов в <code>ThreadPool</code>. Мы ещё не использовали
функцию <code>with_capacity</code>. Она делает то же самое, что и <code>Vec::new</code> - изменяет размеры
при вставке элементов. Поскольку мы создали вектор нужного размера, который нам
нужен, никаких изменений размера не потребуется.</p>
<p>Давайте скомпилируем этот код и посмотрим на ошибку:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0308]: mismatched types
  --&gt; src\main.rs:70:46
   |
70 |         let mut threads = Vec::with_capacity(size);
   |                                              ^^^^ expected usize, found u32

error: aborting due to previous error
</code></pre>
<p><code>size</code> имеет тип <code>u32</code>. Функции <code>Vec::with_capacity</code> нужен входной параметр типа
<code>usize</code>. У нас есть две опции - мы можем изменить тип параметра функции или мы можем
привести тип <code>u32</code> к типу <code>usize</code>. Как вы помните, когда мы объявляли функцию <code>new</code>
мы не задумывались о типе входных данных. Задумаемся сейчас. Тип данных <code>usize</code>
имеет большое значение для вектора. Давайте изменим описание функции:</p>
<pre><code class="language-rust ignore">fn new(size: usize) -&gt; ThreadPool {
</code></pre>
<p>Если вы запустите команду <code>cargo check</code> - код скомпилируется.</p>
<p>Как же всё-таки создавать потоки в цикле? Мы ещё не можем знать для чего они нам
понадобятся - мы просто вносим замыкания Это сложный вопрос. Какие
должен идти в этих потоках? Мы не знаем, какую работу они должны делать при этом
поскольку метод <code>execute</code> берет замыкание и передаем его в пул.</p>
<p>Давим некоторых изменений. Вместо создания экземпляров  <code>JoinHandle&lt;()&gt;</code>,
создадим новую структуру, которая реализует концепцию <em>Рабочий</em> (<em>Worker</em>). <em>Рабочий</em>
будет получать замыкание в методе <code>execute</code> и будет вызывать её. Дополнительно,
нам даст это возможность иметь ограниченное количество экземпляров <em>Рабочих</em> и
будет реализована абстракция.</p>
<p>Итак, реализуем сттукру. Описание изменений:</p>
<ol>
<li>Создадим структуры <code>Worker</code>, полями которой будут <code>id</code> и <code>JoinHandle&lt;()&gt;</code></li>
<li>Сделаем так, чтобы вектор в <code>ThreadPool</code> содержал бы экземпляры <code>Worker</code></li>
<li>Опишем функцию <code>Worker::new</code>, чтобы она получала бы <code>id</code> и возвращала бы
экземпляр <code>Worker</code> с <code>id</code> и поток с пустым замыканием</li>
<li>В <code>ThreadPool::new</code>, будем использовать цикл <code>for</code> и его счётчик будет <code>id</code>.
Будет создаваться экземпляр <code>Worker</code> с этим <code>id</code> и этот вектор будет сохраняться в
вектор.</li>
</ol>
<p>Если вы чувствуете в себе силы, пожалуйста, реализуйте свое решение этой задачи,
а потом посмотрите на решение 20-15.</p>
<p>Готовы? Вот код 20-15, который реализует  with one way to make these modifications:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // ...snip...
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">код 20-15: изменения структуры <code>ThreadPool</code> для хранения
экземпляров <code>Worker</code> вместо хранение непосредственно потоков</span></p>
<p>Мы решили изменить имя поля с <code>threads</code> на <code>workers</code>, т.к. мы изменили тип данных
поля. Мы используем счётчик в цикле.</p>
<p>Этот код компилируется и сохраняет экземпляры структур. Пока мы никак не обрабатываем,
т.е. не делаем никаких действий, не предоставляем никаких действий над потоками.
Об этом мы поговорим в следующий секции.</p>
<a class="header" href="print.html#aОтправка-запросов-потокам-с-помощью-каналов" id="aОтправка-запросов-потокам-с-помощью-каналов"><h2>Отправка запросов потокам с помощью каналов</h2></a>
<p>Проблемы, котрая у нас имеется в текущей реализации следующая - наше замыкание
не делает полезной работы.</p>
<p>We’ve been working around the problem that we get the actual closure we want to
execute in the <code>execute</code> method, but it feels like we need to know the actual
closures when we create the <code>ThreadPool</code>.</p>
<p>Итак, мы хотим чтобы экземпляр <code>Worker</code> создавал бы задачи, который <code>ThreadPool</code>
выполял бы в потоке.</p>
<p>В главе 16 мы изучали каналы. Каналы отличный способ общения между потоками и
этот функционал подойдет для решения нашей задачи. Канал работает, как цепочка задач
и функция <code>execute</code> будет отправлять задания из экземпляра <code>ThreadPool</code> в <code>Worker</code>.</p>
<p>Алгоритм работы:</p>
<ol>
<li><code>ThreadPool</code> будет создавать канал и будет находиться на стороне отправки.</li>
<li>Каждый <code>Worker</code> будет находится на стороне принимающей стороне.</li>
<li>Новая структа <code>Job</code> будет содержать замыкание, которое мы хотим отправить в канал.</li>
<li>Метод <code>execute</code> структуры <code>ThreadPool</code> будет отпралять задание, которые мы хотим отослать.</li>
<li>В потоке, экземпляр <code>Worker</code> в цикле получает из канала и выполняет замыкания.</li>
</ol>
<p>Приступим к созданию канала в функции <code>ThreadPool::new</code> и содержащуюся на отпраляющей
стороне экземпляр <code>ThreadPool</code>, как показано в коде 201-16. <code>Job</code> является типом
данных, который мы будем отправлять в канал. Это код структуры, который пока ничего
не содержит:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
// ...snip...
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // ...snip...
}
#
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
# impl Worker {
#     fn new(id: usize) -&gt; Worker {
#         let thread = thread::spawn(|| {});
#
#         Worker {
#             id,
#             thread,
#         }
#     }
# }
#}</code></pre></pre>
<p><span class="caption">код 20-16: изменение <code>ThreadPool</code>. Добавление возможности
хранения отправленной информации в канал, которая отправляет экземпляры <code>Job</code></span></p>
<p>В функции <code>ThreadPool::new</code> мы создаём новый канал и затем отправляем данные. Этот
код компилируются (хотя и предуприждениями).</p>
<p>Попробуем передать принимающий конец канала каждому работнику (worker) в время их
создания. Мы знаем, что хотим использовать принимающий канал в потоке, который
появляются у рабочих, поэтому мы будем ссылаться на <code>receiver</code> при закрытии.
Этот код 20-17 пока не будет компилироваться:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // ...snip...
}

// ...snip...

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">код 20-17: Передача принимающего конца канала
рабочим в экземпляр <code>Worker</code></span></p>
<p>Это простые и очевидные изменения/</p>
<p>Тестируем. Получаем ошибку компиляции:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>Т.к. мы пытаемся отправить <code>receiver</code> в несколько экземпляров <code>Worker</code>. Вспомнив
материал главы 16, где реализация канала предоставляла множество отправителей
и одного получателя, мы не можем просто клонировать получащаю часть канала для
решения проблемы.</p>
<p>Для решения межпотокового взаимодействия будем использовать умный указатель
<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. Данный указатель позволяет множеству экземпляров иметь получателя и
<code>Mutex</code> будет отслеживать монопольный доступ к задаче. Код 201-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

// ...snip...

# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# struct Job;
#
impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver.clone()));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // ...snip...
}
# struct Worker {
#     id: usize,
#     thread: thread::JoinHandle&lt;()&gt;,
# }
#
impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // ...snip...
#         let thread = thread::spawn(|| {
#            receiver;
#         });
#
#         Worker {
#             id,
#             thread,
#         }
    }
}
#}</code></pre></pre>
<p><span class="caption">код 20-18: разделение получающую часть канала между экземплярами
используя <code>Arc</code> и <code>Mutex</code></span></p>
<p>Код будет компилироваться.</p>
<p>Теперь реализуем метод <code>execute</code> в <code>ThreadPool</code>. Мы также изменим структуру <code>Job</code>.
Вместо того, чтобы быть структурой - сделаем её псивдонимом сложного типа данных:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ...snip...
# pub struct ThreadPool {
#     workers: Vec&lt;Worker&gt;,
#     sender: mpsc::Sender&lt;Job&gt;,
# }
# use std::sync::mpsc;
# struct Worker {}

type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // ...snip...

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// ...snip...
#}</code></pre></pre>
<p><span class="caption">код 20-19: создание типа данных <code>Job</code>, как <code>Box</code>, который
содержит замыкание, далее отправляем задание в канал</span></p>
<p>После создания нового экземпляра <code>Job</code>, используя метод <code>execute</code> мы отправляем
задание в канал.</p>
<p>Далее мы напривим задание в <code>thread::spawn</code>. Нам нужно использовать бесконечный цикл
для отслеживания задания внутри:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// ...snip...

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">код 20-20: получение и выполнение заданий в цикле, в потоке</span></p>
<p>Здесь мы сначала вызываем <code>lock</code> в <code>receiver</code> для получения мьютекса, затем
<code>unwrap</code>. Приобретение блокировки может не сработать, если мьютекс находится в
состояние, называемое <em>отравленным</em> (<em>poisoned</em>), которое может произойти, если
какая-то другая нить запаниковала удерживая замок и не освобождает его.</p>
<p>К сожалению, мы получим ошибку при компиляции этого кода
Theoretically, this code should compile. Unfortunately, the Rust compiler isn’t
perfect yet, and we get this error:</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<p>Ошибку трудно понять, т.к. проблема сложная.</p>
<p>This error is fairly cryptic, and that’s because the problem is fairly cryptic.
In order to call a <code>FnOnce</code> closure that is stored in a <code>Box&lt;T&gt;</code> (which is what
our <code>Job</code> type alias is), the closure needs to be able to move itself out of
the <code>Box&lt;T&gt;</code> since when we call the closure, it takes ownership of <code>self</code>. In
general, moving a value out of a <code>Box&lt;T&gt;</code> isn’t allowed since Rust doesn’t know
how big the value inside the <code>Box&lt;T&gt;</code> is going to be; recall in Chapter 15 that
we used <code>Box&lt;T&gt;</code> precisely because we had something of an unknown size that we
wanted to store in a <code>Box&lt;T&gt;</code> to get a value of a known size.</p>
<p>We saw in Chapter 17, Listing 17-15 that we can write methods that use the
syntax <code>self: Box&lt;Self&gt;</code> so that the method takes ownership of a <code>Self</code> value
that is stored in a <code>Box&lt;T&gt;</code>. That’s what we want to do here, but unfortunately
the part of Rust that implements what happens when we call a closure isn’t
implemented using <code>self: Box&lt;Self&gt;</code>. So Rust doesn’t yet understand that it
could use <code>self: Box&lt;Self&gt;</code> in this situation in order to take ownership of the
closure and move the closure out of the <code>Box&lt;T&gt;</code>.</p>
<p>In the future, the code in Listing 20-20 should work just fine. Rust is still a
work in progress with places that the compiler could be improved. There are
people just like you working to fix this and other issues! Once you’ve finished
the book, we would love for you to join in.</p>
<p>But for now, let’s work around this problem. Luckily, there’s a trick that
involves telling Rust explicitly that we’re in a case where we can take
ownership of the value inside the <code>Box&lt;T&gt;</code> using <code>self: Box&lt;Self&gt;</code>, and once we
have ownership of the closure, we can call it. This involves defining a new
trait that has a method <code>call_box</code> that uses <code>self: Box&lt;Self&gt;</code> in its
signature, defining that trait for any type that implements <code>FnOnce()</code>,
changing our type alias to use the new trait, and changing <code>Worker</code> to use the
<code>call_box</code> method. These changes are shown in Listing 20-21:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

// ...snip...

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">код 20-21: добавление типажа <code>FnBox</code> для устранения ограничений
<code>Box&lt;FnOnce()&gt;</code></span></p>
<p>First, we create a new trait named <code>FnBox</code>. This trait has one method,
<code>call_box</code>, similar to the <code>call</code> methods on the other <code>Fn*</code> traits, except
this method takes <code>self: Box&lt;Self&gt;</code> in order to take ownership of <code>self</code> and
move the value out of the <code>Box&lt;T&gt;</code>.</p>
<p>Next, we implement the <code>FnBox</code> trait for any type <code>F</code> that implements the
<code>FnOnce()</code> trait. Effectively, this means that any <code>FnOnce()</code> closures can use
our <code>call_box</code> method. The implementation of <code>call_box</code> uses <code>(*self)()</code> to
move the closure out of the <code>Box&lt;T&gt;</code> and call the closure.</p>
<p>Instead of <code>FnOnce()</code>, we now want our <code>Job</code> type alias to be a <code>Box</code> of
anything that implements our new trait <code>FnBox</code>. This will allow us to use
<code>call_box</code> in <code>Worker</code> when we get a <code>Job</code> value. Because we implemented the
<code>FnBox</code> trait for any <code>FnOnce()</code> closure, we don’t have to change anything
about the actual values we’re sending down the channel.</p>
<p>Finally, in the closure run in the thread in <code>Worker::new</code>, we use <code>call_box</code>
instead of invoking the closure directly. Now Rust is able to understand that
what we want to do is fine.</p>
<p>This is a very sneaky, complicated trick. Don’t worry too much if it doesn’t
make perfect sense; someday, it will be completely unnecessary.</p>
<p>With this trick, our thread pool is in a working state! Give it a <code>cargo run</code>,
and make some requests:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
     Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool executing connections asynchronously. We
never create more than four threads, so our system won’t get overloaded if the
server gets a lot of requests. If we make a request to <code>/sleep</code>, the server
will be able to serve other requests by having another thread run them.</p>
<p>What about those warnings, though? Don’t we use the <code>workers</code>, <code>id</code>, and
<code>thread</code> fields? Well, right now, we’re using all three of these fields to hold
onto some data, but we don’t actually <em>do</em> anything with the data once we’ve
set up the thread pool and started running the code that sends jobs down the
channel to the threads. If we didn’t hold onto these values, though, they’d go
out of scope: for example, if we didn’t return the <code>Vec&lt;Worker&gt;</code> value as part
of the <code>ThreadPool</code>, the vector would get cleaned up at the end of
<code>ThreadPool::new</code>.</p>
<p>So are these warnings wrong? In one sense yes, the warnings are wrong, since we
are using the fields to store data we need to keep around. In another sense,
no, the warnings aren’t wrong, and they’re telling us that we’ve forgotten to
do something: we never do anything to clean up our thread pool once it’s done
being used, we just use <span class="keystroke">ctrl-C</span> to stop the
program and let the operating system clean up after us. Let’s implement a
graceful shutdown that cleans up everything we’ve created instead.</p>
<a class="header" href="print.html#graceful-shutdown-and-cleanup" id="graceful-shutdown-and-cleanup"><h2>Graceful Shutdown and Cleanup</h2></a>
<p>The code in Listing 20-21 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about fields that
we’re not using in a direct way, which are a reminder that we’re not cleaning
anything up. When we use <span class="keystroke">ctrl-C</span> to halt the main
thread, all the other threads are stopped immediately as well, even if they’re
in the middle of serving a request.</p>
<p>We’re now going to implement the <code>Drop</code> trait for <code>ThreadPool</code> to call <code>join</code>
on each of the threads in the pool so that the threads will finish the requests
they’re working on. Then we’ll implement a way for the <code>ThreadPool</code> to tell the
threads they should stop accepting new requests and shut down. To see this code
in action, we’ll modify our server to only accept two requests before
gracefully shutting down its thread pool.</p>
<p>Let’s start with implementing <code>Drop</code> for our thread pool. When the pool is
dropped, we should join on all of our threads to make sure they finish their
work. Listing 20-22 shows a first attempt at a <code>Drop</code> implementation; this code
won’t quite work yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-22: Joining each thread when the thread pool
goes out of scope</span></p>
<p>We loop through each of the thread pool <code>workers</code>, using <code>&amp;mut</code> because <code>self</code>
is itself a mutable reference and we also need to be able to mutate <code>worker</code>.
We print out a message saying that this particular worker is shutting down, and
then we call <code>join</code> on that worker’s thread. If the call to <code>join</code> fails, we
<code>unwrap</code> the error to panic and go into an ungraceful shutdown.</p>
<p>Here’s the error we get if we compile this code:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<p>Because we only have a mutable borrow of each <code>worker</code>, we can’t call <code>join</code>:
<code>join</code> takes ownership of its argument. In order to solve this, we need a way
to move the <code>thread</code> out of the <code>Worker</code> instance that owns <code>thread</code> so that
<code>join</code> can consume the thread. We saw a way to do this in Listing 17-15: if the
<code>Worker</code> holds an <code>Option&lt;thread::JoinHandle&lt;()&gt;</code> instead, we can call the
<code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code> variant and
leave a <code>None</code> variant in its place. In other words, a <code>Worker</code> that is running
will have a <code>Some</code> variant in <code>thread</code>, and when we want to clean up a worker,
we’ll replace <code>Some</code> with <code>None</code> so the worker doesn’t have a thread to run.</p>
<p>So we know we want to update the definition of <code>Worker</code> like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
#}</code></pre></pre>
<p>Now let’s lean on the compiler to find the other places that need to change. We
get two errors:</p>
<pre><code class="language-text">error: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:21
   |
89 |             thread,
   |             ^^^^^^ expected enum `std::option::Option`, found
   struct `std::thread::JoinHandle`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<p>The second error is pointing to the code at the end of <code>Worker::new</code>; we need
to wrap the <code>thread</code> value in <code>Some</code> when we create a new <code>Worker</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // ...snip...

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>The first error is in our <code>Drop</code> implementation, and we mentioned that we’ll be
calling <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code>. Here’s
what that looks like:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p>As we saw in Chapter 17, the <code>take</code> method on <code>Option</code> takes the <code>Some</code> variant
out and leaves <code>None</code> in its place. We’re using <code>if let</code> to destructure the
<code>Some</code> and get the thread, then call <code>join</code> on the thread. If a worker’s thread
is already <code>None</code>, then we know this worker has already had its thread cleaned
up so we don’t do anything in that case.</p>
<p>With this, our code compiles without any warnings. Bad news though, this code
doesn’t function the way we want it to yet. The key is the logic in the
closures that the spawned threads of the <code>Worker</code> instances run: calling <code>join</code>
won’t shut down the threads since they <code>loop</code> forever looking for jobs. If we
try to drop our <code>ThreadPool</code> with this implementation, the main thread will
block forever waiting for the first thread to finish.</p>
<p>To fix this, we’re going to modify the threads to listen for either a <code>Job</code> to
run or a signal that they should stop listening and exit the infinite loop. So
instead of <code>Job</code> instances, our channel will send one of these two enum
variants:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Job;
enum Message {
    NewJob(Job),
    Terminate,
}
#}</code></pre></pre>
<p>This <code>Message</code> enum will either be a <code>NewJob</code> variant that holds the <code>Job</code> the
thread should run, or it will be a <code>Terminate</code> variant that will cause the
thread to exit its loop and stop.</p>
<p>We need to adjust the channel to use values of type <code>Message</code> rather than type
<code>Job</code>, as shown in Listing 20-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// ...snip...

impl ThreadPool {
    // ...snip...
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        // ...snip...
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// ...snip...

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-23: Sending and receiving <code>Message</code> values and
exiting the loop if a <code>Worker</code> receives <code>Message::Terminate</code></span></p>
<p>We need to change <code>Job</code> to <code>Message</code> in the definition of <code>ThreadPool</code>, in
<code>ThreadPool::new</code> where we create the channel, and in the signature of
<code>Worker::new</code>. The <code>execute</code> method of <code>ThreadPool</code> needs to send jobs wrapped
in the <code>Message::NewJob</code> variant. Then, in <code>Worker::new</code> where we receive a
<code>Message</code> from the channel, we’ll process the job if we get the <code>NewJob</code>
variant and break out of the loop if we get the <code>Terminate</code> variant.</p>
<p>With these changes, the code will compile again and continue to function in the
same way as it has been. We’ll get a warning, though, because we aren’t using
the <code>Terminate</code> variant in any messages. Let’s change our <code>Drop</code> implementation
to look like Listing 20-24:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-24: Sending <code>Message::Terminate</code> to the
workers before calling <code>join</code> on each worker thread</span></p>
<p>We’re now iterating over the workers twice, once to send one <code>Terminate</code>
message for each worker, and once to call <code>join</code> on each worker’s thread. If we
tried to send a message and join immediately in the same loop, it’s not
guaranteed that the worker in the current iteration will be the one that gets
the message from the channel.</p>
<p>To understand better why we need two separate loops, imagine a scenario with
two workers. If we iterated through each worker in one loop, on the first
iteration where <code>worker</code> is the first worker, we’d send a terminate message
down the channel and call <code>join</code> on the first worker’s thread. If the first
worker was busy processing a request at that moment, the second worker would
pick up the terminate message from the channel and shut down. We’re waiting on
the first worker to shut down, but it never will since the second thread picked
up the terminate message. We’re now blocking forever waiting for the first
worker to shut down, and we’ll never send the second message to terminate.
Deadlock!</p>
<p>To prevent this, we first put all of our <code>Terminate</code> messages on the channel,
and then we join on all the threads. Because each worker will stop receiving
requests on the channel once it gets a terminate message, we can be sure that
if we send the same number of terminate messages as there are workers, each
worker will receive a terminate message before we call <code>join</code> on its thread.</p>
<p>In order to see this code in action, let’s modify <code>main</code> to only accept two
requests before gracefully shutting the server down as shown in Listing 20-25:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();
    let pool = ThreadPool::new(4);

    let mut counter = 0;

    for stream in listener.incoming() {
        if counter == 2 {
            println!(&quot;Shutting down.&quot;);
            break;
        }

        counter += 1;

        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
</code></pre>
<p><span class="caption">Listing 20-25: Shut down the server after serving two
requests by exiting the loop</span></p>
<p>Only serving two requests isn’t behavior you’d like a production web server to
have, but this will let us see the graceful shutdown and cleanup working since
we won’t be stopping the server with <span class="keystroke">ctrl-C</span>.</p>
<p>We’ve added a <code>counter</code> variable that we’ll increment every time we receive an
incoming TCP stream. If that counter reaches 2, we’ll stop serving requests and
instead break out of the <code>for</code> loop. The <code>ThreadPool</code> will go out of scope at
the end of <code>main</code>, and we’ll see the <code>drop</code> implementation run.</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request
should error, and in your terminal you should see output that looks like:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You may get a different ordering, of course. We can see how this works from the
messages: workers zero and three got the first two requests, and then on the
third request, we stop accepting connections. When the <code>ThreadPool</code> goes out of
scope at the end of <code>main</code>, its <code>Drop</code> implementation kicks in, and the pool
tells all workers to terminate. The workers each print a message when they see
the terminate message, and then the thread pool calls <code>join</code> to shut down each
worker thread.</p>
<p>One interesting aspect of this particular execution: notice that we sent the
terminate messages down the channel, and before any worker received the
messages, we tried to join worker zero. Worker zero had not yet gotten the
terminate message, so the main thread blocked waiting for worker zero to
finish. In the meantime, each of the workers received the termination messages.
Once worker zero finished, the main thread waited for the rest of the workers
to finish, and they had all received the termination message and were able to
shut down at that point.</p>
<p>Congrats! We now have completed our project, and we have a basic web server
that uses a thread pool to respond asynchronously. We’re able to perform a
graceful shutdown of the server, which cleans up all the threads in the pool.
Here’s the full code for reference:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs::File;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();
    let pool = ThreadPool::new(4);

    let mut counter = 0;

    for stream in listener.incoming() {
        if counter == 2 {
            println!(&quot;Shutting down.&quot;);
            break;
        }

        counter += 1;

        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let mut file = File::open(filename).unwrap();
     let mut contents = String::new();

     file.read_to_string(&amp;mut contents).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver.clone()));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
#}</code></pre></pre>
<p>There’s more we could do here! If you’d like to continue enhancing this
project, here are some ideas:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods</li>
<li>Add tests of the library’s functionality</li>
<li>Change calls to <code>unwrap</code> to more robust error handling</li>
<li>Use <code>ThreadPool</code> to perform some other task rather than serving web requests</li>
<li>Find a thread pool crate on crates.io and implement a similar web server
using the crate instead and compare its API and robustness to the thread pool
we implemented</li>
</ul>
<a class="header" href="print.html#summary-2" id="summary-2"><h2>Summary</h2></a>
<p>Well done! You’ve made it to the end of the book! We’d like to thank you for
joining us on this tour of Rust. You’re now ready to go out and implement your
own Rust projects or help with other people’s. Remember there’s a community of
other Rustaceans who would love to help you with any challenges you encounter
on your Rust journey.</p>
<a class="header" href="print.html#aДополнительная-информация" id="aДополнительная-информация"><h1>Дополнительная информация</h1></a>
<p>Следующие секции содержат материалы, которые будут полезны вам во время изучения
и дальнейшего использования Rust.</p>
<a class="header" href="print.html#aДополнение-А-Ключевые-слова" id="aДополнение-А-Ключевые-слова"><h2>Дополнение А: Ключевые слова</h2></a>
<p>Ключевые слова - это словарь языка программирования Rust слова. Данные слова
испльзуются для описания ваших прогамм и не могут быть испльзованы в качестве
идентификаторов (имён функций (fn), переменных (let), параметров, имена полей
структур, модулей (mod), контейнеров (crate), костант (const), макросов,
статических переменных (static), атрибутов, типов, типажей (trait)).</p>
<a class="header" href="print.html#aКлючевые-слова-языка-программирования-rust" id="aКлючевые-слова-языка-программирования-rust"><h3>Ключевые слова языка программирования Rust</h3></a>
<ul>
<li><code>as</code> - простое приведение типа</li>
<li><code>break</code> - немедленное прекращение цикла</li>
<li><code>const</code> - обозначение константы</li>
<li><code>continue</code> - прекратить текущую итерацию цикла и перейти к следующей</li>
<li><code>crate</code> - внешнее связывание или обозначение макро переменной компонента</li>
<li><code>else</code> - альтернатива для <code>if</code> и <code>if let</code></li>
<li><code>enum</code> - определение перечисления</li>
<li><code>extern</code> - определение использования внешнего компонента, функции или связывания</li>
<li><code>false</code> - логический литерал ЛОЖЬ</li>
<li><code>fn</code> - определение функции и ссылочной переменной на переменную типа функция</li>
<li><code>for</code> - итератор</li>
<li><code>if</code> - оператор сравнения</li>
<li><code>impl</code> - наследование и реализация типажа</li>
<li><code>in</code> - часть синтаксической конструкции итератора <code>for</code></li>
<li><code>let</code> - определение переменной</li>
<li><code>loop</code> - итератор бесконечного цикла</li>
<li><code>match</code> - шаблонный селектор</li>
<li><code>mod</code> - оператор определения модуля</li>
<li><code>move</code> - оператор перемещения кучи, передача прав</li>
<li><code>mut</code> -  обозначение возможности изменения переменной</li>
<li><code>pub</code> - обозначение уровня доступа к структуре, блоку, модулю, <code>impl</code> блокам</li>
<li><code>ref</code> - ссылочное связывание</li>
<li><code>return</code> - оператор возврата из функции</li>
<li><code>Self</code> - тип псевдонима для типа реализации типажа</li>
<li><code>self</code> - заголовок метода или текущего модуля</li>
<li><code>static</code> - обозначение глобальной переменной или переменной, которая будет доступна на протяжении работы программы</li>
<li><code>struct</code> - определение структуры</li>
<li><code>super</code> - обозначение ссылки на родительский модуль относительно текущего</li>
<li><code>trait</code> - обозначение типажа</li>
<li><code>true</code> - логический литерал ПРАВДА</li>
<li><code>type</code> - псевдоним типа и оператор его определения</li>
<li><code>unsafe</code> - определение небезопасного кода, функции, типажа и реализаций</li>
<li><code>use</code> - оператор импорта</li>
<li><code>where</code> - оператор условия</li>
<li><code>while</code> - логический итератор</li>
</ul>
<a class="header" href="print.html#aЗарезервированные-ключевые-слова-для-будущего-использования" id="aЗарезервированные-ключевые-слова-для-будущего-использования"><h3>Зарезервированные ключевые слова для будущего использования</h3></a>
<p>Хотя эти не ключевые слова языка программирования Rust, они, возможно, будут
использоваться в новых его версиях.</p>
<ul>
<li><code>abstract</code></li>
<li><code>alignof</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>offsetof</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>proc</code></li>
<li><code>pure</code></li>
<li><code>sizeof</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<a class="header" href="print.html#aПриложение-Б-Операторы" id="aПриложение-Б-Операторы"><h2>Приложение Б: Операторы</h2></a>
<a class="header" href="print.html#aОператоры-имеющие-один-операнд-тн-унарные-выражения" id="aОператоры-имеющие-один-операнд-тн-унарные-выражения"><h3>Операторы имеющие один операнд (т.н. унарные выражения)</h3></a>
<p>В языке программирования Rust имеются унарные выражения. Их местоположение - перед
переменной.</p>
<ul>
<li><code>-</code>
: Знак отрицательной величины. Знаковые переменный как целочисленные литералы,
так с плавающей точкой могут быть отрицательными. Беззнаковые литералы, которые
имеют префикс <code>-</code> вызывают ошибку компиляции: например, <code>-1u32</code>.</li>
<li><code>*</code>
: Оператор разыменования. Если данные оператор применяется к переменной ссылочного
типа (указателя), то этот оператор обозначает данные на место в памяти.
Данные оператор может быть применён для указателей на переменное значение памяти.
Для других типов переменных (не ссылочных), он вызывает метод <code>deref</code> типажа
<code>std::ops::Deref</code> или метод <code>deref_mut</code> типажа <code>std::ops::DerefMut</code>.</li>
<li><code>!</code>
: Логическое отрицание. Если переменная логического типа - значение инвертируется.
Если тип данных целочисленное значение - инвертируются биты данного числа.</li>
<li><code>&amp;</code> и <code>&amp;mut</code>
: Заимствование. Когда этот оператор применятся к значению, этот оператор возвращает
ссылку на это значение. Также это значение переходит в состояние &quot;заимствовано&quot;
на период существования ссылочной переменной. При использовании оператора (<code>&amp;</code>)
накладывается также ещё одно ограничение - она не может содержать иное значение.
При использовании оператора  (<code>&amp;mut</code>) значение переменной не может быть прочтено
на период существования ссылочной переменной.</li>
</ul>
<a class="header" href="print.html#aОператоры-имеющие-два-оператора-тн-бинарные-выражения" id="aОператоры-имеющие-два-оператора-тн-бинарные-выражения"><h3>Операторы имеющие два оператора (т.н. бинарные выражения)</h3></a>
<p>Бинарные выражения в порядке приоритета (т.е. сначала выполняются арифметические
операции, потом бинарные, потом логические.</p>
<a class="header" href="print.html#aАрифметические-операции" id="aАрифметические-операции"><h4>Арифметические операции</h4></a>
<p>Бинарные арифметические выражения - это синтаксические выражения заменяющие в коде
вызовы функций соответствующих типажей, определённых в модуле <code>std::ops</code> библиотеки
<code>std</code>. Это значит, что арифметические операторы могут быть переопределены (перезагружены)
в пользовательских типах данных. Список значений операций:</p>
<ul>
<li><code>+</code>
: Сложение, а также объединение массивов и строк.
Вызывается метод <code>add</code> типажа <code>std::ops::Add</code>.</li>
<li><code>-</code>
: Вычитание.
Вызывается метод <code>sub</code> типажа <code>std::ops::Sub</code>.</li>
<li><code>*</code>
: Умножение.
Вызывается метод <code>mul</code> типажа <code>std::ops::Mul</code>.</li>
<li><code>/</code>
: Деление.
Вызывается метод <code>div</code> типажа <code>std::ops::Div</code>.</li>
<li><code>%</code>
: Остаток от деления.
Вызывается метод <code>rem</code> типажа <code>std::ops::Rem</code>.</li>
</ul>
<p>Обратите внимание, что Rust не имеет стандартного оператора возведения в степень
(power). Существует метод <code>pow</code> у численных типов данных.</p>
<a class="header" href="print.html#aБитовые-операторы" id="aБитовые-операторы"><h4>Битовые операторы</h4></a>
<p>Также как и арифметические операторы, битовые операторы - это синтаксические
выражения заменяющие в коде вызовы функций соответствующих типажей. Это значит,
что битовые операторы могут быть переопределены в пользовательских типах данных.
Смысл синтаксических конструкций стандартных типов следующий: если операторы <code>&amp;</code>,
<code>|</code> и <code>^</code> применяются к логическим переменным они соответствуют их логическим
операторам-эквивалентам <code>&amp;&amp;</code>, <code>||</code> и <code>!=</code>. Правда, результат их использования будет
отличаться.</p>
<ul>
<li><code>&amp;</code>
: Битовое И (&amp;).
Вызывает метод <code>bitand</code> типажа <code>std::ops::BitAnd</code>.</li>
<li><code>|</code>
: Битовое включающее ИЛИ (|).
Вызывает метод <code>bitor</code> типажа <code>std::ops::BitOr</code>.</li>
<li><code>^</code>
: Битовое исключающее ИЛИ (^).
Вызывает метод <code>bitxor</code> типажа <code>std::ops::BitXor</code>.</li>
<li><code>&lt;&lt;</code>
: Здвиг в лево (&lt;&lt;).
Вызывает метод <code>shl</code> типажа <code>std::ops::Shl</code>.</li>
<li><code>&gt;&gt;</code>
: Здвиг в право (&gt;&gt;).
Вызывает метод <code>shr</code> типажа <code>std::ops::Shr</code>.</li>
</ul>
<a class="header" href="print.html#aЛогические-операторы" id="aЛогические-операторы"><h4>Логические операторы</h4></a>
<p>Операторы <code>||</code> и <code>&amp;&amp;</code> могут быть применены к операторам логического типа. Оператор
<code>||</code> обозначает логическое &quot;или&quot;. Оператор <code>&amp;&amp;</code> обозначает логическое &quot;и&quot;.
Разница между их бинарными аналогами следующая: если левый оператор - &quot;истина&quot;,
то выполнения логического анализа прекращается даже если справа есть ещё логические
операторы.</p>
<a class="header" href="print.html#aОперации-сравнения" id="aОперации-сравнения"><h4>Операции сравнения</h4></a>
<p>Операторы сравнения, также как и предыдущие операторы (арифметические и битовые)</p>
<ul>
<li>
<p>это синтаксические выражения заменяющие в коде вызовы функций соответствующих
типажей. Это значит, что операторы сравнения могут быть переопределены в
пользовательских типах данных. Далее приведено стандартное поведение этих операторов.</p>
</li>
</ul>
<ul>
<li><code>==</code>
: Равно.
Вызывает метод <code>eq</code> типажа <code>std::cmp::PartialEq</code>.</li>
<li><code>!=</code>
: Unequal to.
Вызывает метод <code>ne</code> типажа <code>std::cmp::PartialEq</code>.</li>
<li><code>&lt;</code>
: Less than.
Вызывает метод <code>lt</code> типажа <code>std::cmp::PartialOrd</code>.</li>
<li><code>&gt;</code>
: Greater than.
Вызывает метод <code>gt</code> типажа <code>std::cmp::PartialOrd</code>.</li>
<li><code>&lt;=</code>
: Less than or equal.
Вызывает метод <code>le</code> типажа <code>std::cmp::PartialOrd</code>.</li>
<li><code>&gt;=</code>
: Greater than or equal.
Вызывает метод <code>ge</code> типажа <code>std::cmp::PartialOrd</code>.</li>
</ul>
<a class="header" href="print.html#aВыражения-приведения-типа" id="aВыражения-приведения-типа"><h4>Выражения приведения типа</h4></a>
<p>Выражение приведение типа обозначается с помощью оператора <code>as</code>.</p>
<p>Выполняя выражение <code>as</code> приводит значение переменной слева к типу справа.</p>
<p>Пример использования оператора <code>as</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
# fn len(values: &amp;[f64]) -&gt; i32 { 0 }

fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
#}</code></pre></pre>
<p>Некоторые конвертации, которые могут быть произведены с использованием оператора
<code>as</code>, также могут быть выполнены косвенным образом. Так, например, значение, которое
присваивается в момент определения переменной с помощью оператора <code>let</code> явным
образом приводит присваиваемое значение к определённому типу данных.
Косвенные конвертация предпочтительнее, т.к. она сводит к минимуму риски потери
данных при приведении типа.</p>
<a class="header" href="print.html#aВыражения-присваивания" id="aВыражения-присваивания"><h4>Выражения присваивания</h4></a>
<p><em>Выражения присваивания</em> состоит из шаблонного выражения, за которым следует знак
(<code>=</code>). Далее следует выражение.</p>
<p>Результатом присваивания является присвоение левой части или копии или значения
правого оператора.</p>
<pre><code># let mut x = 0;
# let y = 0;
x = y;
</code></pre>
<a class="header" href="print.html#aМногокомпонентные-операции" id="aМногокомпонентные-операции"><h4>Многокомпонентные операции</h4></a>
<p>Операторы <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, и <code>&gt;&gt;</code> могут быть объединены
с помощью оператора <code>=</code>. Выражение <code>lval OP= val</code> эквивалентно следующему
<code>lval = lval OP val</code>. Например, <code>x = x + 1</code> может быть записано следующим образом
<code>x += 1</code>.</p>
<p>Все эти выражения всегда имеют беззнаковые целочисленный тип данных <code>unit</code>.</p>
<a class="header" href="print.html#aПриоритет-операторов" id="aПриоритет-операторов"><h4>Приоритет операторов</h4></a>
<p>Приоритет бинарных операторов Rust (от большего к меньшему):</p>
<pre><code class="language-text">as :
* / %
+ -
&lt;&lt; &gt;&gt;
&amp;
^
|
== != &lt; &gt; &lt;= &gt;=
&amp;&amp;
||
.. ...
&lt;-
=
</code></pre>
<p>Операторы находящиеся на одном уровне, имеют приоритет с лева на право (лево - наивысший приоритет уровня).
Унарные операторы имеют такой же приоритет, что их бинарные аналоги, т.е. сначала сложение, потом вычитание.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
